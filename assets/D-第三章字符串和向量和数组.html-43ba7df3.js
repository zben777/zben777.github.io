import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as l,c as i,d as r,a as n,e as t,w as p,b as s,f as e}from"./app-2a2d189a.js";const u="/assets/table3-4-c879c09c.png",k="/assets/table3-5-55851ba1.png",d="/assets/table3-6-61f6f149.png",v="/assets/table3-7-eb30138a.png",m="/assets/table3-8-2b77628e.png",b={},g=n("h1",{id:"d-第三章字符串和向量和数组",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#d-第三章字符串和向量和数组","aria-hidden":"true"},"#"),s(" D-第三章字符串和向量和数组")],-1),y=n("p",null,"D-第三章字符串和向量和数组",-1),h=e('<div class="hint-container info"><p class="hint-container-title">说明</p><p>主要是各种搜索找的学习；<br><strong>百度链接：</strong><br> :<br> :</p><p><strong>知乎链接：</strong><br> :<br> :</p><p><strong>B站链接：</strong><br> ：<br> ：</p><p><strong>博客链接：</strong><br> ：<br> ：</p><p><strong>GitHub链接：</strong><br> ：<br> ：</p></div>',1),w={class:"table-of-contents"},f=e(`<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="第3章-字符串、向量和数组" tabindex="-1"><a class="header-anchor" href="#第3章-字符串、向量和数组" aria-hidden="true">#</a> 第3章　字符串、向量和数组</h2><h2 id="_3-1-命名空间的using声明" tabindex="-1"><a class="header-anchor" href="#_3-1-命名空间的using声明" aria-hidden="true">#</a> 3.1　命名空间的using声明</h2><h2 id="_3-3-标准库类型vector" tabindex="-1"><a class="header-anchor" href="#_3-3-标准库类型vector" aria-hidden="true">#</a> 3.3　标准库类型vector</h2><ul><li><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同。<br> 集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为<br> vector“容纳着”其他对象，所以它也常被称作容器（container）。第II部<br> 将对容器进行更为详细的介绍。</p></li><li><p>要想使用vector，必须包含适当的头文件。在后续的例子中，都将<br> 假定做了如下using声明：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>C++语言既有类模板（class template），也有函数模板，其中vector<br> 是一个类模板。只有对C++有了相当深入的理解才能写出模板，事实<br> 上，我们直到第16章才会学习如何自定义模板。幸运的是，即使还不会<br> 创建模板，我们也可以先试着用用它。</p></li><li><p>模板本身不是类或函数，相反可以将模板看作为编译器生成类或函<br> 数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化<br> （instantiation），当使用模板时，需要指出编译器应把类或函数实例化<br> 成何种类型。</p></li><li><p>对于类模板来说，我们通过提供一些额外信息来指定模板到底实例<br> 化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是<br> 这样：即在模板名字后面跟一对尖括号，在括号内放上信息。</p></li><li><p>以vector为例，提供的额外信息是vector内所存放对象的类型：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span> <span class="token comment">//ivec 保存 int 类型的对象</span>
vector<span class="token operator">&lt;</span>Sales_item<span class="token operator">&gt;</span> Sales_vec<span class="token punctuation">;</span> <span class="token comment">//保存Sales_item类型的对象</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> file<span class="token punctuation">;</span> <span class="token comment">//该向量的元素 是 vector对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在上面的例子中，编译器根据模板vector生成了三种不同的类型：<br><code>vector&lt;int&gt;、vector&lt;Sales_item&gt;和vector&lt;vector&lt;string&gt;&gt;。</code></li></ul><br><br><ul><li><p><mark>Note</mark></p></li><li><p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如<code>vector&lt;int&gt;</code>。</p></li><li><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是<br> 对象（参见2.3.1节，第45页），所以不存在包含引用的vector。除此之<br> 外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，<br> 甚至组成vector的元素也可以是vector。</p></li><li><p>需要指出的是，在早期版本的C++标准中如果vector的元素还是<br> vector（或者其他模板类型），则其定义的形式与现在的C++11新标准<br> 略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间<br> 添加一个空格，<code>如应该写成vector&lt;vector&lt;int&gt;&gt;而非vector&lt;vector&lt;int&gt;&gt;</code>。</p></li></ul><br><ul><li><mark>Warning</mark></li><li>某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如<code>vector&lt;vector&lt;int&gt;&gt;</code>。</li></ul><h3 id="_3-3-1-定义和初始化vector对象" tabindex="-1"><a class="header-anchor" href="#_3-3-1-定义和初始化vector对象" aria-hidden="true">#</a> 3.3.1　定义和初始化vector对象</h3><ul><li><p>和任何一种类类型一样，vector模板控制着定义和初始化向量的方<br> 法。表3.4列出了定义vector对象的常用方法。<br><img src="`+u+`" alt="table3-4" loading="lazy"></p></li><li><p>可以默认初始化vector对象（参见2.2.1节，第40页），从而创建一<br> 个指定类型的空vector：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span> <span class="token comment">// default initialization; svec has no elements</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>看起来空vector好像没什么用，但是很快我们就会知道程序在运行<br> 时可以很高效地往vector对象中添加元素。事实上，最常见的方式就是<br> 先定义一个空vector，然后当运行时获取到元素的值后再逐一添加。</p></li><li><p>当然也可以在定义vector对象时指定元素的初始值。例如，允许把<br> 一个vector对象的元素拷贝给另外一个vector对象。此时，新vector对象<br> 的元素就是原vector对象对应元素的副本。注意两个vector对象的类型必<br> 须相同：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span> <span class="token comment">// initially empty</span>
<span class="token comment">// give ivec some values</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec2</span><span class="token punctuation">(</span>ivec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy elements of ivec into ivec2</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec3 <span class="token operator">=</span> ivec<span class="token punctuation">;</span> <span class="token comment">// copy elements of ivec into ivec3</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span>ivec2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: svec holds strings, not ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>列表初始化vector对象</mark></p></li><li><p>C++11新标准还提供了另外一种为vector对象的元素赋初值的方<br> 法，即列表初始化（参见2.2.1节，第39页）。此时，用花括号括起来的<br> 0个或多个初始元素值被赋给vector对象：<br><code>vector&lt;string&gt; articles = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};</code></p></li><li><p>上述vector对象包含三个元素：第一个是字符串&quot;a&quot;，第二个是字符<br> 串&quot;an&quot;，最后一个是字符串&quot;the&quot;。</p></li><li><p>之前已经讲过，C++语言提供了几种不同的初始化方式（参见2.2.1<br> 节，第39页）。在大多数情况下这些初始化方式可以相互等价地使用，<br> 不过也并非一直如此。目前已经介绍过的两种例外情况是：其一，使用<br> 拷贝初始化时（即使用=时）（参见3.2.1节，第76页），只能提供一个<br> 初始值；其二，如果提供的是一个类内初始值（参见2.6.1节，第64<br> 页），则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊<br> 的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花<br> 括号里进行列表初始化，而不能放在圆括号里：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v1<span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// list initialization</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建指定数量的元素.还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten int elements, each initialized to -1</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten strings; each element is &quot;hi!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>值初始化</p></li><li><p>通常情况下，可以只提供vector对象容纳的元素数量而不用略去初<br> 始值。此时库会创建一个值初始化的（value-initialized）元素初值，并<br> 把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决<br> 定。</p></li><li><p>如果vector对象的元素是内置类型，比如int，则元素初始值自动设<br> 为0。如果元素是某种类类型，比如string，则元素由类默认初始化：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten elements, each initialized to 0</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten elements, each an empty string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>对这种初始化的方式有两个特殊限制：其一，有些类要求必须明确<br> 地提供初始值（参见2.2.1节，第40页），如果vector对象中元素的类型<br> 不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象<br> 来说，只提供元素的数量而不设定初始值无法完成初始化工作。</p></li><li><p>其二，如果只提供了元素的数量而没有设定初始值，只能使用直接<br> 初始化：<br><code>vector&lt;int&gt; vi = 10; // error: must use direct initialization to supply a size</code></p></li><li><p>这里的10是用来说明如何初始化vector对象的，我们用它的本意是<br> 想创建含有10个值初始化了的元素的vector对象，而非把数字10“拷<br> 贝”到vector中。因此，此时不宜使用拷贝初始化，7.5.4节（第265页）将对这一点做更详细的介绍。</p></li></ul><br><ul><li><mark>列表初始值还是元素数量？</mark></li><li>在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括<br> 号还是圆括号。例如，用一个整数来初始化<code>vector&lt;int&gt;</code>时，整数的含义<br> 可能是vector对象的容量也可能是元素的值。类似的，用两个整数来初<br> 始化<code>vector&lt;int&gt;</code>时，这两个整数可能一个是vector对象的容量，另一个是<br> 元素的初值，也可能它们是容量为2的vector对象中两个元素的初值。通<br> 过使用花括号或圆括号可以区分上述这些含义：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// v1 has ten elements with value 0</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// v2 has one element with value 10</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// v3 has ten elements with value 1</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// v4 has two elements with values 10 and 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果用的是圆括号，可以说提供的值是用来构造（construct）vector<br> 对象的。例如，v1的初始值说明了vector对象的容量；v3的两个初始值<br> 则分别说明了vector对象的容量和元素的初值。</p></li><li><p>如果用的是花括号，可以表述成我们想列表初始化（list initialize）<br> 该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成<br> 是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其<br> 他初始化方式。在上例中，给v2和v4提供的初始值都能作为元素的值，<br> 所以它们都会执行列表初始化，vector对象v2包含一个元素而vector对象<br> v4包含两个元素。</p></li><li><p>另一方面，如果初始化时使用了花括号的形式但是提供的值又不能<br> 用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要<br> 想列表初始化一个含有string对象的vector对象，应该提供能赋给string对<br> 象的初值。此时不难区分到底是要列表初始化vector对象的元素还是用<br> 给定的容量值来构造vector对象：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v5<span class="token punctuation">{</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// list initialization: v5 has one element</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">v6</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t construct a vector from a stringliteral</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v7<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// v7 has ten default-initialized elements</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v8<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// v8 has ten elements with value &quot;hi&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只<br> 有v5是列表初始化。要想列表初始化vector对象，花括号里的值必须与<br> 元素类型相同。显然不能用int初始化string对象，所以v7和v8提供的值<br> 不能作为元素的初始值。确认无法执行列表初始化后，编译器会尝试用<br> 默认值初始化vector对象。</li></ul><br><ul><li><mark>3.3.1节练习</mark></li><li>练习3.12：下列vector对象的定义有不正确的吗？如果有，请指出来。<br> 对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ivec<span class="token punctuation">;</span>         <span class="token comment">// 在C++11当中合法</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec <span class="token operator">=</span> ivec<span class="token punctuation">;</span>       <span class="token comment">// 不合法，类型不一样</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 合法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.13：下列的vector对象各包含多少个元素？这些元素的值分别是<br> 多少？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>         <span class="token comment">// size:0,  no values.</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// size:10, value:0</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// size:10, value:42</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">// size:1,  value:10</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v5<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// size:2,  value:10, 42</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v6<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// size:10, value:&quot;&quot;</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v7<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// size:10, value:&quot;hi&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-2-向vector对象中添加元素" tabindex="-1"><a class="header-anchor" href="#_3-3-2-向vector对象中添加元素" aria-hidden="true">#</a> 3.3.2　向vector对象中添加元素</h3><ul><li><p>对vector对象来说，直接初始化的方式适用于三种情况：初始值已<br> 知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值<br> 都一样。然而更常见的情况是：创建一个vector对象时并不清楚实际所<br> 需的元素个数，元素的值也经常无法确定。还有些时候即使元素的初值<br> 已知，但如果这些值总量较大而各不相同，那么在创建vector对象的时<br> 候执行初始化操作也会显得过于烦琐。</p></li><li><p>举个例子，如果想创建一个vector对象令其包含从0到9共10个元<br> 素，使用列表初始化的方法很容易做到这一点；但如果vector对象包含<br> 的元素是从0到99或者从0到999呢？这时通过列表初始化把所有元素都<br> 一一罗列出来就不太合适了。对于此例来说，更好的处理方法是先创建<br> 一个空vector，然后在运行时再利用vector的成员函数push_back向其中<br> 添加元素。push_back负责把一个值当成vector对象的尾元素“压到<br> （push）”vector对象的“尾端（back）”。例如：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span> <span class="token comment">// empty vector</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
 v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// append sequential integers to v2</span>
<span class="token comment">// at end of loop v2 has 100 elements, values 0 . . . 99</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在上例中，尽管知道vector对象最后会包含100个元素，但在一开始<br> 还是把它声明成空vector，在每次迭代时才顺序地把下一个整数作为v2<br> 的新元素添加给它。</p></li><li><p>同样的，如果直到运行时才能知道vector对象中元素的确切个数，<br> 也应该使用刚刚这种方法创建vector对象并为其赋值。例如，有时需要<br> 实时读入数据然后将其赋予vector对象：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// read words from the standard input and store them as elements in a vector</span>
string word<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> text<span class="token punctuation">;</span> <span class="token comment">// empty vector</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 text<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// append word to text</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>和之前的例子一样，本例也是先创建一个空vector，之后依次读入<br> 未知数量的值并保存到text中。</li></ul><br><ul><li><p><mark>关键概念：vector对象能高效增长</mark></p></li><li><p>C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能<br> 高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果<br> 这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一旦元<br> 素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加<br> 具体值。此外，9.4节（第317页）将介绍，vector还提供了方法，允许我们进一步提升<br> 动态添加元素的性能。</p></li><li><p>开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及<br> 其他大多数语言中内置数组类型的用法不同。特别是如果用惯了C或者Java，可以预计<br> 在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。</p></li></ul><br><ul><li><p><mark>向vector对象添加元素蕴含的编程假定</mark></p></li><li><p>由于能高效便捷地向vector对象中添加元素，很多编程工作被极大<br> 简化了。然而，这种简便性也伴随着一些对编写程序更高的要求：其中<br> 一条就是必须要确保所写的循环正确无误，特别是在循环有可能改变<br> vector对象容量的时候。</p></li><li><p>随着对vector的更多使用，我们还会逐渐了解到其他一些隐含的要<br> 求，其中一条是现在就要指出的：如果循环体内部包含有向vector对象<br> 添加元素的语句，则不能使用范围for循环，具体原因将在5.4.3节（第<br> 168页）详细解释。</p></li></ul><br><ul><li><mark>warning</mark></li><li>范围for语句体内不应改变其所遍历序列的大小。</li></ul><br><ul><li><mark>3.3.2节练习</mark></li><li>练习3.14：编写一段程序，用cin读入一组整数并把它们存入一个vector对象。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.15：改写上题的程序，不过这次读入的是字符串。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	string i<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-3-其他vector操作" tabindex="-1"><a class="header-anchor" href="#_3-3-3-其他vector操作" aria-hidden="true">#</a> 3.3.3　其他vector操作</h3><ul><li><p>除了push_back之外，vector还提供了几种其他操作，大多数都和<br> string的相关操作类似，表3.5列出了其中比较重要的一些。<br><img src="`+k+`" alt="table3-5" loading="lazy"></p></li><li><p>访问vector对象中元素的方法和访问string对象中字符的方法差不<br> 多，也是通过元素在vector对象中的位置。例如，可以使用范围for语句<br> 处理vector对象中的所有元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token comment">// for each element in v (note: i is a reference)</span>
 i <span class="token operator">*=</span> i<span class="token punctuation">;</span> <span class="token comment">// square the element value</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token comment">// for each element in v</span>
 cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span> <span class="token comment">// print the element</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第一个循环把控制变量i定义成引用类型，这样就能通过i给v的元素<br> 赋值，其中i的类型由auto关键字指定。这里用到了一种新的复合赋值运<br> 算符（参见1.4.1节，第10页）。如我们所知，+=把左侧运算对象和右侧<br> 运算对象相加，结果存入左侧运算对象；类似的，＊=把左侧运算对象<br> 和右侧运算对象相乘，结果存入左侧运算对象。最后，第二个循环输出<br> 所有元素。</p></li><li><p>vector的empty和size两个成员与string的同名成员（参见3.2.2节，第<br> 78页）功能完全一致：empty检查vector对象是否包含元素然后返回一个<br> 布尔值；size则返回vector对象中元素的个数，返回值的类型是由vector<br> 定义的size_type类型。</p></li></ul><br><ul><li><mark>Note</mark></li><li>要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含<br> 着元素的类型（参见3.3节，第87页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type <span class="token comment">// ok</span>
vector<span class="token double-colon punctuation">::</span>size_type <span class="token comment">// error</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>各个相等性运算符和关系运算符也与string的相应运算符（参见<br> 3.2.2节，第79页）功能一致。两个vector对象相等当且仅当它们所含的<br> 元素个数相同，而且对应位置的元素值也相同。关系运算符依照字典顺<br> 序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元<br> 素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元<br> 素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小<br> 关系决定。</p></li><li><p>只有当元素的值可比较时，vector对象才能被比较。一些类，如<br> string等，确实定义了自己的相等性运算符和关系运算符；另外一些，<br> 如Sales_item类支持的运算已经全都罗列在1.5.1节（第17页）中了，显<br> 然并不支持相等性判断和关系运算等操作。因此，不能比较两个<br> vector&lt;Sales_item&gt;对象。</p></li></ul><br><ul><li><p><mark>计算vector内对象的索引</mark></p></li><li><p>使用下标运算符（参见3.2.3节，第84页）能获取到指定的元素。和<br> string一样，vector对象的下标也是从0开始计起，下标的类型是相应的<br> size_type类型。只要vector对象不是一个常量，就能向下标运算符返回<br> 的元素赋值。此外，如3.2.3节（第85页）所述的那样，也能通过计算得<br> 到vector内对象的索引，然后直接获取索引位置上的元素。</p></li><li><p>举个例子，假设有一组成绩的集合，其中成绩的取值是从0到100。<br> 以10分为一个分数段，要求统计各个分数段各有多少个成绩。显然，从<br> 0到100总共有101种可能的成绩取值，这些成绩分布在11个分数段上：<br> 每10个分数构成一个分数段，这样的分数段有10个，额外还有一个分数<br> 段表示满分100分。这样第一个分数段将统计成绩在0到9之间的数量；<br> 第二个分数段将统计成绩在10到19之间的数量，以此类推。最后一个分<br> 数段统计满分100分的数量。</p></li><li><p>按照上面的描述，如果输入的成绩如下：<br> 42 65 95 100 39 67 95 76 88 76 83 92 76 93</p></li><li><p>则输出的结果应该是：<br> 0 0 0 1 1 0 2 3 2 4 1</p></li><li><p>结果显示：成绩在30分以下的没有、30分至39分有1个、40分至49<br> 分有1个、50分至59分没有、60分至69分有2个、70分至79分有3个、80<br> 分至89分有2个、90分至99分有4个，还有1个是满分。</p></li><li><p>在具体实现时使用一个含有11个元素的vector对象，每个元素分别<br> 用于统计各个分数段上出现的成绩个数。对于某个成绩来说，将其除以<br> 10就能得到对应的分数段索引。注意：两个整数相除，结果还是整数，<br> 余数部分被自动忽略掉了。例如，42/10=4、65/10=6、100/10=10等。一<br> 旦计算得到了分数段索引，就能用它作为vector对象的下标，进而获取<br> 该分数段的计数值并加1：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// count the number of grades by clusters of ten: 0--9, 10--19, . .. 90--99, 100</span>
vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">&gt;</span> <span class="token function">scores</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11 buckets, all initially 0</span>
<span class="token keyword">unsigned</span> grade<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> grade<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// read the grades</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// handle only valid grades</span>
 <span class="token operator">++</span>scores<span class="token punctuation">[</span>grade<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// increment the counter for the current cluster</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在上面的程序中，首先定义了一个vector对象存放各个分数段上成<br> 绩的数量。此例中，由于初始状态下每个元素的值都相同，所以我们为<br> vector对象申请了11个元素，并把所有元素的初始值都设为0。while语<br> 句的条件部分负责读入成绩，在循环体内部首先检查读入的成绩是否合<br> 法（即是否小于等于100分），如果合法，将成绩对应的分数段的计数<br> 值加1。</p></li><li><p>执行计数值累加的那条语句很好地体现了C++程序代码的简洁性。表达式<br> ++scores[grade/10]; // increment the counter for the current cluster</p></li><li><p>等价于<br> auto ind = grade/10; // get the bucket index<br> scores[ind] = scores[ind] + 1; // increment the count</p></li><li><p>上述语句的含义是：用grade除以10来计算成绩所在的分数段，然<br> 后将所得的结果作为变量scores的下标。通过运行下标运算获取该分数<br> 段对应的计数值，因为新出现了一个属于该分数段的成绩，所以将计数<br> 值加1。</p></li><li><p>如前所述，使用下标的时候必须清楚地知道它是否在合理范围之内<br> （参见3.2.3节，第85页）。在这个程序里，我们事先确认了输入的成绩<br> 确实在0到100之间，这样计算所得的下标就一定在0到10之间，属于0到<br> scores.size（）-1规定的有效范围，一定是合法的。</p></li></ul><br><ul><li><mark>不能用下标形式添加元素</mark></li><li>刚接触C++语言的程序员也许会认为可以通过vector对象的下标形<br> 式来添加元素，事实并非如此。下面的代码试图为vector对象ivec添加10<br> 个元素：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span> <span class="token comment">// empty vector</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
 ivec<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">=</span> ix<span class="token punctuation">;</span> <span class="token comment">// disaster: ivec has no elements</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>然而，这段代码是错误的：ivec是一个空vector，根本不包含任何元<br> 素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是<br> 使用push_back：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
 ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: adds a new element with value ix</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>warining</mark></li><li>vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用<br> 于添加元素。</li></ul><br><ul><li><mark>提示：只能对确知已存在的元素执行下标操作！</mark></li><li>关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。例如，</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span> <span class="token comment">// empty vector</span>
cout <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error: ivec has no elements!</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vector with ten elements</span>
cout <span class="token operator">&lt;&lt;</span> ivec2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error: ivec2 has elements 0 . . . 9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编<br> 译器发现，而是在运行时产生一个不可预知的值。</p></li><li><p>不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重<br> 的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致PC及其<br> 他设备上应用程序出现安全问题的一个重要原因。</p></li><li><p><mark>确保下标合法的一种有效手段就是尽可能使用范围for语句。</mark></p></li></ul><h3 id="_3-3-3节练习" tabindex="-1"><a class="header-anchor" href="#_3-3-3节练习" aria-hidden="true">#</a> 3.3.3节练习</h3><ul><li>练习3.16：编写一段程序，把练习3.13中vector对象的容量和具体内容输<br> 出出来。检验你之前的回答是否正确，如果不对，回过头重新学习3.3.1<br> 节（第87页）直到弄明白错在何处为止。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>         <span class="token comment">// size:0,  no values.</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// size:10, value:0</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// size:10, value:42</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">// size:1,  value:10</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v5<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// size:2,  value:10, 42</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v6<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// size:10, value:&quot;&quot;</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v7<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// size:10, value:&quot;hi&quot;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v1 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v2 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v3 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v3<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v4 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v4<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v5 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v5<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v6 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v6<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v7 size :&quot;</span> <span class="token operator">&lt;&lt;</span> v7<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v1 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v1<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v2 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v2<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v3 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v3<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v4 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v4<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v5 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v5<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v6 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v6<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;v7 content: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v7<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; , &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.17：从cin读入一组词并把它们存入一个vector对象，然后设法把<br> 所有词都改写为大写形式。输出改变后的结果，每个词占一行。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	string s<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>str <span class="token operator">:</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> str<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			c <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.18：下面的程序合法吗？如果不合法，你准备如何修改？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
ivec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token operator">-</span> 不合法。应改为：ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.19：如果想定义一个含有10个元素的vector对象，所有元素的值<br> 都是42，请列举出三种不同的实现方法。哪种方法更好呢？为什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec2<span class="token punctuation">{</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec3<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	ivec3<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

第一种方式最好。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.20：读入一组整数并把它们存入一个vector对象，将每对相邻整<br> 数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素<br> 的和，接着输出第2个和倒数第2个元素的和，以此类推。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> ivec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//---------------------------------</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;---------------------------------&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">+</span> ivec<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token operator">++</span>m<span class="token punctuation">;</span>
		<span class="token operator">--</span>n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-4-迭代器介绍" tabindex="-1"><a class="header-anchor" href="#_3-4-迭代器介绍" aria-hidden="true">#</a> 3.4　迭代器介绍</h2><ul><li><p>我们已经知道可以使用下标运算符来访问string对象的字符或vector<br> 对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就<br> 是迭代器（iterator）。在第II部分中将要介绍，除了vector之外，标准库<br> 还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中<br> 只有少数几种才同时支持下标运算符。严格来说，string对象不属于容<br> 器类型，但是string支持很多与容器类型类似的操作。vector支持下标运<br> 算符，这点和string一样；string支持迭代器，这也和vector是一样的。</p></li><li><p>类似于指针类型（参见2.3.2节，第47页），迭代器也提供了对对象<br> 的间接访问。就迭代器而言，其对象是容器中的元素或者string对象中<br> 的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到<br> 另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效<br> 的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他<br> 所有情况都属于无效。</p></li></ul><h3 id="_3-4-1-使用迭代器" tabindex="-1"><a class="header-anchor" href="#_3-4-1-使用迭代器" aria-hidden="true">#</a> 3.4.1　使用迭代器</h3><ul><li>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类<br> 型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end<br> 的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的<br> 迭代器。如有下述语句：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// the compiler determines the type of b and e; see § 2.5.2 (p. 68)</span>
<span class="token comment">// b denotes the first element and e denotes one past the last element in v</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b and e have the same type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>end成员则负责返回指向容器（或string对象）“尾元素的下一位置<br> （one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一<br> 个本不存在的“尾后（off the end）”元素。这样的迭代器没什么实际含<br> 义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end<br> 成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称<br> 为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin和end<br> 返回的是同一个迭代器。</li></ul><br><ul><li><p><mark>Note</mark></p></li><li><p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p></li><li><p>一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。<br> 在上面的例子中，使用auto关键字定义变量b和e（参见2.5.2节，第61<br> 页），这两个变量的类型也就是begin和end的返回值类型，第97页将对<br> 相关内容做更详细的介绍。</p></li></ul><br><ul><li><p><mark>迭代器运算符</mark></p></li><li><p>表3.6列举了迭代器支持的一些运算。使用==和！=来比较两个合法<br> 的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容<br> 器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。<br><img src="`+d+`" alt="table3-6" loading="lazy"></p></li><li><p>和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行<br> 解引用的迭代器必须合法并确实指示着某个元素（参见2.3.2节，第48<br> 页）。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行<br> 为。</p></li><li><p>举个例子，3.2.3节（第84页）中的程序利用下标运算符把string对<br> 象的第一个字母改为了大写形式，下面利用迭代器实现同样的功能：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;some string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// make sure s is not empty</span>
 <span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it denotes the first character in s</span>
 <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make that character uppercase</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>本例和原来的程序一样，首先检查s是否为空，显然通过检查begin<br> 和end返回的结果是否一致就能做到这一点。如果返回的结果一样，说<br> 明s为空；如果返回的结果不一样，说明s不为空，此时s中至少包含一个<br> 字符。</p></li><li><p>我们在if内部，声明了一个迭代器变量it并把begin返回的结果赋给<br> 它，这样就得到了指示s中第一个字符的迭代器，接下来通过解引用运<br> 算符将第一个字符更改为大写形式。和原来的程序一样，输出结果将<br> 是：Some string</p></li></ul><br><ul><li><mark>将迭代器从一个元素移动到另外一个元素</mark></li><li>迭代器使用递增（++）运算符（参见1.4.1节，第11页）来从一个元<br> 素移动到下一个元素。从逻辑上来说，迭代器的递增和整数的递增类<br> 似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前<br> 移动一个位置”。</li></ul><br><ul><li><p><mark>Note</mark></p></li><li><p>因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p></li><li><p>之前有一个程序把string对象中第一个单词改写为大写形式，现在<br> 利用迭代器及其递增运算符可以实现相同的功能：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// process characters in s until we run out of characters or we hit a whitespace</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isspace</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span>
 <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// capitalize the current character</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>和3.2.3节（第84页）的那个程序一样，上面的循环也是遍历s的字<br> 符直到遇到空白字符为止，只不过之前的程序用的是下标运算符，现在<br> 这个程序用的是迭代器。</p></li><li><p>循环首先用s.begin的返回值来初始化it，意味着it指示的是s中的第<br> 一个字符（如果有的话）。条件部分检查是否已到达s的尾部，如果尚<br> 未到达，则将it解引用的结果传入isspace函数检查是否遇到了空白。每<br> 次迭代的最后，执行++it令迭代器前移一个位置以访问s的下一个字符。</p></li><li><p>循环体内部和上一个程序if语句内的最后一句话一样，先解引用it，<br> 然后将结果传入toupper函数得到该字母对应的大写形式，再把这个大写<br> 字母重新赋值给it所指示的字符。</p></li></ul><br><ul><li><p><mark>关键概念：泛型编程</mark></p></li><li><p>原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非&lt;<br> 进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C++程序员习惯性地使<br> 用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标<br> 准库提供的所有容器上都有效。</p></li><li><p>之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都<br> 如此。与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数<br> 都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用<br> 的到底是哪种容器类型。</p></li></ul><br><ul><li><mark>迭代器类型</mark></li><li>就像不知道string和vector的size_type成员（参见3.2.2节，第79页）<br> 到底是什么类型一样，一般来说我们也不知道（其实是无须知道）迭代<br> 器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和<br> const_iterator来表示迭代器的类型：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it<span class="token punctuation">;</span> <span class="token comment">// it can read and write vector&lt;int&gt; elements</span>
string<span class="token double-colon punctuation">::</span>iterator it2<span class="token punctuation">;</span> <span class="token comment">// it2 can read and write characters in a string</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it3<span class="token punctuation">;</span> <span class="token comment">// it3 can read but not write elements</span>
string<span class="token double-colon punctuation">::</span>const_iterator it4<span class="token punctuation">;</span> <span class="token comment">// it4 can read but not write characters</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>const_iterator和常量指针（参见2.4.2节，第56页）差不多，能读取<br> 但不能修改它所指的元素值。相反，iterator的对象可读可写。如果<br> vector对象或string对象是一个常量，只能使用const_iterator；如果vector<br> 对象或string对象不是常量，那么既能使用iterator也能使用<br> const_iterator。</li></ul><br><ul><li><p><mark>术语：迭代器和迭代器类型</mark></p></li><li><p>迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定<br> 义的迭代器类型，还可能是指某个迭代器对象。</p></li><li><p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它<br> 支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个<br> 元素。</p></li><li><p>每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套<br> 操作。</p></li></ul><br><ul><li><mark>begin和end运算符</mark></li><li>begin和end返回的具体类型由对象是否是常量决定，如果对象是常<br> 量，begin和end返回const_iterator；如果对象不是常量，返回iterator：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
<span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> cv<span class="token punctuation">;</span>
<span class="token keyword">auto</span> it1 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it1 has type vector&lt;int&gt;::iterator</span>
<span class="token keyword">auto</span> it2 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it2 has type vector&lt;int&gt;::const_iterator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>有时候这种默认的行为并非我们所要。在6.2.3节（第191页）中将<br> 会看到，如果对象只需读操作而无须写操作的话最好使用常量类型（比<br> 如const_iterator）。为了便于专门得到const_iterator类型的返回值，<br> C++11新标准引入了两个新函数，分别是cbegin和cend：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> it3 <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it3 has type vector&lt;int&gt;::const_iterator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>类似于begin和end，上述两个新函数也分别返回指示容器第一个元<br> 素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或<br> string对象）本身是否是常量，返回值都是const_iterator。</li></ul><br><ul><li><mark>结合解引用和成员访问操作</mark></li><li>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是<br> 类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成<br> 的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭<br> 代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>注意，（＊it）.empty（）中的圆括号必不可少，具体原因将在<br> 4.1.2节（第121页）介绍，该表达式的含义是先对it解引用，然后解引用<br> 的结果再执行点运算符（参见1.5.2节，第20页）。如果不加圆括号，点<br> 运算符将由it来执行，而非it解引用的结果：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// dereferences it and calls the member empty on the resulting object</span>
<span class="token operator">*</span>it<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error: attempts to fetch the member named empty from it</span>
 <span class="token comment">// but it is an iterator and has no member named empty</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>上面第二个表达式的含义是从名为it的对象中寻找其empty成员，显<br> 然it是一个迭代器，它没有哪个成员是叫empty的，所以第二个表达式将<br> 发生错误。</p></li><li><p>为了简化上述表达式，C++语言定义了箭头运算符（-&gt;）。箭头运<br> 算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和<br> （＊it）.mem表达的意思相同。</p></li><li><p>例如，假设用一个名为text的字符串向量存放文本文件中的数据，<br> 其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。如<br> 果要输出text中第一段的内容，可以利用迭代器写一个循环令其遍历<br> text，直到遇到空字符串的元素为止：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// print each line in text up to the first blank line</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 it <span class="token operator">!=</span> text<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>it<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们首先初始化it令其指向text的第一个元素，循环重复执行直至处<br> 理完了text的所有元素或者发现某个元素为空。每次迭代时只要发现还<br> 有元素并且尚未遇到空元素，就输出当前正在处理的元素。值得注意的<br> 是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用<br> 了cbegin和cend来控制整个迭代过程。</li></ul><br><ul><li><mark>某些对vector对象的操作会使迭代器失效</mark></li><li>3.3.2节（第90页）曾经介绍过，虽然vector对象可以动态地增长，<br> 但是也会有一些副作用。已知的一个限制是不能在范围for循环中向<br> vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量<br> 的操作，比如push_back，都会使该vector对象的迭代器失效。9.3.6节<br> （第315页）将详细解释迭代器是如何失效的。</li></ul><br><ul><li><mark>Warning</mark></li><li>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</li></ul><h3 id="_3-4-1节练习" tabindex="-1"><a class="header-anchor" href="#_3-4-1节练习" aria-hidden="true">#</a> 3.4.1节练习</h3><ul><li>练习3.21：请使用迭代器重做3.3.3节（第94页）的第一个练习。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">check_and_print</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;size: &quot;</span> <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;  content: [&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;]\\n&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">check_and_print</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;size: &quot;</span> <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;  content: [&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;]\\n&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v5<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v6<span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v7<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v6<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">check_and_print</span><span class="token punctuation">(</span>v7<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>练习3.22：修改之前那个输出text第一段的程序，首先把text的第一段全<br> 都改成大写形式，然后再输出它。</p></li><li><p>练习3.23：编写一段程序，创建一个含有10个整数的vector对象，然后<br> 使用迭代器将所有元素的值都变成原来的两倍。输出vector对象的内<br> 容，检验程序是否正确。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">*</span>it <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> one <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> one <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-2-迭代器运算" tabindex="-1"><a class="header-anchor" href="#_3-4-2-迭代器运算" aria-hidden="true">#</a> 3.4.2　迭代器运算</h3><ul><li><p>迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器<br> 都有支持递增运算的迭代器。类似的，也能用==和！=对任意标准库类<br> 型的两个有效迭代器（参见3.4节，第95页）进行比较。</p></li><li><p>string和vector的迭代器提供了更多额外的运算符，一方面可使得迭<br> 代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有<br> 这些运算被称作迭代器运算（iterator arithmetic），其细节由表3.7列<br> 出。<br><img src="`+v+`" alt="table3-7" loading="lazy"></p></li></ul><br><ul><li><mark>迭代器的算术运算</mark></li><li>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或<br> 向后）移动了若干个位置的迭代器。执行这样的操作时，结果迭代器或<br> 者指示原vector对象（或string对象）内的一个元素，或者指示原vector<br> 对象（或string对象）尾元素的下一位置。举个例子，下面的代码得到<br> 一个迭代器，它指向某vector对象中间位置的元素：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// compute an iterator to the element closest to the midpoint of vi</span>
<span class="token keyword">auto</span> mid <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果vi有20个元素，vi.size（）/2得10，此例中即令mid等于<br> vi.begin（）+10。已知下标从0开始，则迭代器所指的元素是vi[10]，也<br> 就是从首元素开始向前相隔10个位置的那个元素。</p></li><li><p>对于string或vector的迭代器来说，除了判断是否相等，还能使用关<br> 系运算符（&lt;、&lt;=、&gt;、&gt;=）对其进行比较。参与比较的两个迭代器必<br> 须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例<br> 如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码<br> 来比较它们所指的位置孰前孰后：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span>
 <span class="token comment">// process elements in the first half of vi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位<br> 置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右<br> 侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名<br> 为difference_type的带符号整型数。string和vector都定义了<br> difference_type，因为这个距离可正可负，所以difference_type是带符号<br> 类型的。</li></ul><br><ul><li><p><mark>使用迭代器运算</mark></p></li><li><p>使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列<br> 中寻找某个给定的值。二分搜索从序列中间的位置开始搜索，如果中间<br> 位置的元素正好就是要找的元素，搜索完成；如果不是，假如该元素小<br> 于要找的元素，则在序列的后半部分继续搜素；假如该元素大于要找的<br> 元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中<br> 间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜<br> 索。</p></li><li><p>下面的程序使用迭代器完成了二分搜索：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// text must be sorted</span>
<span class="token comment">// beg and end will denote the range we&#39;re searching</span>
<span class="token keyword">auto</span> beg <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> mid <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// original midpoint</span>
<span class="token comment">// while there are still elements to look at and we haven&#39;t yet found sought</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>mid <span class="token operator">!=</span> end <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>mid <span class="token operator">!=</span> sought<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>sought <span class="token operator">&lt;</span> <span class="token operator">*</span>mid<span class="token punctuation">)</span> <span class="token comment">// is the element we want in the first half?</span>
 end <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment">// if so, adjust the range to ignore the second</span>
half
 <span class="token keyword">else</span> <span class="token comment">// the element we want is in the second half</span>
 beg <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// start looking with the element just after mid</span>
 mid <span class="token operator">=</span> beg <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// new midpoint</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>程序的一开始定义了三个迭代器：beg指向搜索范围内的第一个元
素、end指向尾元素的下一位置、mid指向中间的那个元素。初始状态
下，搜索范围是名为text的vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>的全部范围。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>循环部分先检查搜索范围是否为空，如果mid和end的当前值相等，<br> 说明已经找遍了所有元素。此时条件不满足，循环终止。当搜索范围不<br> 为空时，可知mid指向了某个元素，检查该元素是否就是我们所要搜索<br> 的，如果是，也终止循环。</p></li><li><p>当进入到循环体内部后，程序通过某种规则移动beg或者end来缩小<br> 搜索的范围。如果mid所指的元素比要找的元素sought大，可推测若text<br> 含有sought，则必出现在mid所指元素的前面。此时，可以忽略mid后面<br> 的元素不再查找，并把mid赋给end即可。另一种情况，如果＊mid比<br> sought小，则要找的元素必出现在mid所指元素的后面。此时，通过令<br> beg指向mid的下一个位置即可改变搜索范围。因为已经验证过mid不是<br> 我们要找的对象，所以在接下来的搜索中不必考虑它。</p></li><li><p>循环过程终止时，mid或者等于end或者指向要找的元素。如果mid<br> 等于end，说明text中没有我们要找的元素。</p></li></ul><h3 id="_3-4-2节练习" tabindex="-1"><a class="header-anchor" href="#_3-4-2节练习" aria-hidden="true">#</a> 3.4.2节练习</h3><ul><li>练习3.24：请使用迭代器重做3.3.3节（第94页）的最后一个练习。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> ivec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">+</span> <span class="token operator">*</span><span class="token punctuation">(</span>it <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//---------------------------------</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;---------------------------------&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">auto</span> it1 <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> it2 <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it1 <span class="token operator">&lt;</span> it2<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it1 <span class="token operator">+</span> <span class="token operator">*</span>it2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token operator">++</span>it1<span class="token punctuation">;</span>
		<span class="token operator">--</span>it2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.25：3.3.3节（第93页）划分分数段的程序是使用下标运算符实现<br> 的，请利用迭代器改写该程序并实现完全相同的功能。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">&gt;</span> <span class="token function">scores</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> grade<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> grade<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>
			<span class="token operator">++</span><span class="token operator">*</span><span class="token punctuation">(</span>scores<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> grade <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> scores<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>练习3.26：在100页的二分搜索程序中，为什么用的是mid = beg + （end - beg） / 2，而非mid = （beg + end） /2；？</p></li><li><p>因为两个迭代器相互之间支持的运算只有 - ，而没有 + 。 但是迭代器和迭代器差值（整数值）之间支持 +</p></li></ul><h2 id="_3-5-数组" tabindex="-1"><a class="header-anchor" href="#_3-5-数组" aria-hidden="true">#</a> 3.5　数组</h2><ul><li><p>数组是一种类似于标准库类型vector（参见3.3节，第86页）的数据<br> 结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似<br> 的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名<br> 字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确<br> 定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某<br> 些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵<br> 活性。</p></li><li><p><mark>如果不清楚元素的确切个数，请使用vector。</mark></p></li></ul><h3 id="_3-5-1-定义和初始化内置数组" tabindex="-1"><a class="header-anchor" href="#_3-5-1-定义和初始化内置数组" aria-hidden="true">#</a> 3.5.1　定义和初始化内置数组</h3><ul><li>数组是一种复合类型（参见2.3节，第45页）。数组的声明形如<br> a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的<br> 个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，<br> 编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式<br> （参见2.4.4节，第58页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> cnt <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// not a constant expression</span>
<span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> sz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// constant expression</span>
 <span class="token comment">// constexpr see § 2.4.4 (p. 66)</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of ten ints</span>
<span class="token keyword">int</span> <span class="token operator">*</span>parr<span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of 42 pointers to int</span>
string bad<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error: cnt is not a constant expression</span>
string strs<span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok if get_size is constexpr, error otherwise</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>默认情况下，数组的元素被默认初始化（参见2.2.1节，第40页）。</li></ul><br><ul><li><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认<br> 初始化会令数组含有未定义的值。</p></li><li><p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始<br> 值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不<br> 存在引用的数组。</p></li></ul><br><ul><li><mark>显式初始化数组元素</mark></li><li>可以对数组的元素进行列表初始化（参见3.3.1节，第88页），此时<br> 允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始<br> 值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数<br> 量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供<br> 的初始值初始化靠前的元素，剩下的元素被初始化成默认值（参见3.3.1<br> 节，第88页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">unsigned</span> sz <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia1<span class="token punctuation">[</span>sz<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// array of three ints with values 0, 1, 2</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// an array of dimension 3</span>
<span class="token keyword">int</span> a3<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to a3[] = {0, 1, 2, 0, 0}</span>
string a4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bye&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// same as a4[] = {&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;}</span>
<span class="token keyword">int</span> a5<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: too many initializers</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>字符数组的特殊性</mark></li><li>字符数组有一种额外的初始化形式，我们可以用字符串字面值（参<br> 见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注<br> 意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的<br> 其他字符一样被拷贝到字符数组中去：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// list initialization, no null</span>
<span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// list initialization, explicit null</span>
<span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;C++&quot;</span><span class="token punctuation">;</span> <span class="token comment">// null terminator added automatically</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Daniel&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error: no space for the null!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>a1的维度是3，a2和a3的维度都是4，a4的定义是错误的。尽管字符<br> 串字面值&quot;Daniel&quot;看起来只有6个字符，但是数组的大小必须至少是7，<br> 其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。</li></ul><br><ul><li><mark>不允许拷贝和赋值</mark></li><li>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为<br> 其他数组赋值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// array of three ints</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// error: cannot initialize one array with another</span>
a2 <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// error: cannot assign one array to another</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><mark>Warning</mark></p></li><li><p>一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。<br> 但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编<br> 译器上无法正常工作。</p></li><li><p><mark>理解复杂的数组声明</mark></p></li><li><p>和vector一样，数组能存放大多数类型的对象。例如，可以定义一<br> 个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指<br> 针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直<br> 接，但是定义数组的指针或数组的引用就稍微复杂一点了：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ptrs is an array of ten pointers to int</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token comment">/* ? */</span><span class="token punctuation">;</span> <span class="token comment">// error: no arrays of references</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>Parray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span> <span class="token comment">// Parray points to an array of ten ints</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arrRef<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">// arrRef refers to an array of ten ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右<br> 向左（参见2.3.3节，第52页）理解其含义比较简单：首先知道我们定义<br> 的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是<br> 指向int的指针。</p></li><li><p>但是对于Parray来说，从右向左理解就不太合理了。因为数组的维<br> 度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右<br> 向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义：首<br> 先是圆括号括起来的部分，＊Parray意味着Parray是个指针，接下来观<br> 察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左<br> 边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是<br> 一个指针，它指向一个int数组，数组中包含10个元素。同理，<br> （&amp;arrRef）表示arrRef是一个引用，它引用的对象是一个大小为10的数<br> 组，数组中元素的类型是int。</p></li><li><p>当然，对修饰符的数量并没有特殊限制：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arry<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> ptrs<span class="token punctuation">;</span> <span class="token comment">// arry is a reference to an array of ten pointers</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然<br> 后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左<br> 边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10<br> 个int型指针的数组的引用。</p></li><li><p><mark>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</mark></p></li></ul><h3 id="_3-5-1节练习" tabindex="-1"><a class="header-anchor" href="#_3-5-1节练习" aria-hidden="true">#</a> 3.5.1节练习</h3><ul><li>练习3.27：假设txt_size是一个无参数的函数，它的返回值是int。请回答<br> 下列哪个定义是非法的？为什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> buf_size <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span>buf_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">-</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token function">txt_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">char</span> st<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;fundamental&quot;</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>a<span class="token punctuation">)</span> 非法。维度必须是一个常量表达式。
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> 合法。
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> 非法。<span class="token function">txt_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 的值必须要到运行时才能得到。
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> 非法。数组的大小应该是<span class="token number">12</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.28：下列数组中元素的值是什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string sa<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	string sa2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ia2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

数组的元素会被默认初始化。 sa的元素值全部为空字符串，ia 的元素值全部为<span class="token number">0</span>。 
sa2的元素值全部为空字符串，ia2的元素值全部未定义。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.29：相比于vector来说，数组有哪些缺点，请列举一些。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>数组的大小是确定的。
不能随意增加元素。
不允许拷贝和赋值。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-5-2-访问数组元素" tabindex="-1"><a class="header-anchor" href="#_3-5-2-访问数组元素" aria-hidden="true">#</a> 3.5.2　访问数组元素</h3><ul><li><p>与标准库类型vector和string一样，数组的元素也能使用范围for语句<br> 或下标运算符来访问。数组的索引从0开始，以一个包含10个元素的数<br> 组为例，它的索引从0到9，而非从1到10。</p></li><li><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种<br> 机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象<br> 的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库<br> stddef.h头文件的C++语言版本。</p></li><li><p>数组除了大小固定这一特点外，其他用法与vector基本类似。例<br> 如，可以用数组来记录各分数段的成绩个数，从而实现与3.3.3节（第93<br> 页）的程序一样的功能：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100</span>
<span class="token keyword">unsigned</span> scores<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 11 buckets, all value initialized to 0</span>
<span class="token keyword">unsigned</span> grade<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> grade<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>
 <span class="token operator">++</span>scores<span class="token punctuation">[</span>grade<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// increment the counter for the current cluster</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>与93页的程序相比，上面程序最大的不同是scores的声明。这里<br> scores是一个含有11个无符号元素的数组。另外一处不太明显的区别<br> 是，本例所用的下标运算符是由C++语言直接定义的，这个运算符能用<br> 在数组类型的运算对象上。93页的那个程序所用的下标运算符是库模板<br> vector定义的，只能用于vector类型的运算对象。</p></li><li><p>与vector和string一样，当需要遍历数组的所有元素时，最好的办法<br> 也是使用范围for语句。例如，下面的程序输出所有的scores：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token comment">// for each counter in scores</span>
 cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span> <span class="token comment">// print the value of that counter</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因为维度是数组类型的一部分，所以系统知道数组scores中有多少<br> 个元素，使用范围for语句可以减轻人为控制遍历过程的负担。<br> 检查下标的值</p></li><li><p>与vector和string一样，数组的下标是否在合理范围之内由程序员负<br> 责检查，所谓合理就是说下标应该大于等于0而且小于数组的大小。要<br> 想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测<br> 试之外，没有其他好办法。对于一个程序来说，即使顺利通过编译并执<br> 行，也不能肯定它不包含此类致命的错误。</p></li><li><p><mark>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</mark></p></li></ul><h3 id="_3-5-2节练习" tabindex="-1"><a class="header-anchor" href="#_3-5-2节练习" aria-hidden="true">#</a> 3.5.2节练习</h3><ul><li>指出下面代码中的索引错误。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> size_t array_size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span>array_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t ix <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> ix <span class="token operator">&lt;=</span> array_size<span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
	ia<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">=</span> ix<span class="token punctuation">;</span>

当ix增长到 <span class="token number">10</span> 的时候，ia<span class="token punctuation">[</span>ix<span class="token punctuation">]</span>的下标越界。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.31：编写一段程序，定义一个含有10个int的数组，令每个元素的<br> 值就是其下标值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.32：将上一题刚刚创建的数组拷贝给另外一个数组。利用vector<br> 重写程序，实现类似的功能。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// array</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// vector</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v2<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.33：对于104页的程序来说，如果不初始化scores将发生什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>数组中所有元素的值将会未定义。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-5-3-指针和数组" tabindex="-1"><a class="header-anchor" href="#_3-5-3-指针和数组" aria-hidden="true">#</a> 3.5.3　指针和数组</h3><ul><li><p>在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，<br> 使用数组的时候编译器一般会把它转换成指针。</p></li><li><p>通常情况下，使用取地址符（参见2.3.2节，第47页）来获取指向某<br> 个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对<br> 数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一<br> 样，对数组的元素使用取地址符就能得到指向该元素的指针：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;two&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;three&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// array of strings</span>
string <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p points to the first element in nums</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>然而，数组还有一个特性：在很多用到数组名字的地方，编译器都<br> 会自动地将其替换为一个指向数组首元素的指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token operator">*</span>p2 <span class="token operator">=</span> nums<span class="token punctuation">;</span> <span class="token comment">// equivalent to p2 = &amp;nums[0]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><mark>在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针</mark></li></ul><br><ul><li>由上可知，在一些情况下数组的操作实际上是指针的操作，这一结<br> 论有很多隐含的意思。其中一层意思是当使用数组作为一个auto（参见<br> 2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ia is an array of ten ints</span>
<span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ia2 is an int* that points to the first element in ia</span>
ia2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// error: ia2 is a pointer, and we can&#39;t assign an int to a pointer</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译<br> 器实际执行的初始化过程类似于下面的形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ia<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// now it&#39;s clear that ia2 has type int*</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>必须指出的是，当使用decltype关键字（参见2.5.3节，第62页）时<br> 上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数<br> 组：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ia3 is an array of ten ints</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span> ia3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
ia3 <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t assign an int* to an array</span>
ia3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// ok: assigns the value of i to an element in ia3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>指针也是迭代器</mark></li><li>与2.3.2节（第47页）介绍的内容相比，指向数组元素的指针拥有更<br> 多功能。vector和string的迭代器（参见3.4节，第95页）支持的运算，数<br> 组的指针全都支持。例如，允许使用递增运算符将指向数组元素的指针<br> 向前移动到下一个位置上：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">// p points to the first element in arr</span>
<span class="token operator">++</span>p<span class="token punctuation">;</span> <span class="token comment">// p points to arr[1]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历<br> 数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素<br> 的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数<br> 组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取<br> 尾后指针就要用到数组的另外一个特殊性质了。我们可以设法获取数组<br> 尾元素之后的那个并不存在的元素的地址：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// pointer just past the last element in arr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>这里显然使用下标运算符索引了一个不存在的元素，arr有10个元<br> 素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处<br> 就是提供其地址用于初始化e。就像尾后迭代器（参见3.4.1节，第95<br> 页）一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行<br> 解引用或递增的操作。</p></li><li><p>利用上面得到的指针能重写之前的循环，令其输出arr的全部元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> arr<span class="token punctuation">;</span> b <span class="token operator">!=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// print the elements in arr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>标准库函数begin和end</mark></li><li>尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使<br> 用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。<br> 这两个函数与容器中的两个同名成员（参见3.4.1节，第95页）功能类<br> 似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的<br> 使用形式是将数组作为它们的参数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ia is an array of ten ints</span>
<span class="token keyword">int</span> <span class="token operator">*</span>beg <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pointer to the first element in ia</span>
<span class="token keyword">int</span> <span class="token operator">*</span>last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pointer one past the last element in ia</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一<br> 位置的指针，这两个函数定义在iterator头文件中。</li><li>使用begin和end可以很容易地写出一个循环并处理数组中的元素。<br> 例如，假设arr是一个整型数组，下面的程序负责找到arr中的第一个负<br> 数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// pbeg points to the first and pend points just past the last element in arr</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pbeg <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>pend <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// find the first negative element, stopping if we&#39;ve seen all the elements</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>pbeg <span class="token operator">!=</span> pend <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pbeg <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token operator">++</span>pbeg<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>首先定义了两个名为pbeg和pend的整型指针，其中pbeg指向arr的第<br> 一个元素，pend指向arr尾元素的下一位置。while语句的条件部分通过<br> 比较pbeg和pend来确保可以安全地对pbeg解引用，如果pbeg确实指向了<br> 一个元素，将其解引用并检查元素值是否为负值。如果是，条件失效、<br> 退出循环；如果不是，将指针向前移动一位继续考查下一个元素。</p></li><li><p><mark>一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector<br> 的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增<br> 操作</mark></p></li></ul><br><ul><li><p><mark>指针运算</mark></p></li><li><p>指向数组元素的指针可以执行表3.6（第96页）和表3.7（第99页）<br> 列出的所有迭代器运算。这些运算，包括解引用、递增、比较、与整数<br> 相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。</p></li><li><p>给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针<br> 指向的元素与原来的指针相比前进了（后退了）该整数值个位置：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> size_t sz <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span>sz<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">// equivalent to int *ip = &amp;arr[0]</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ip2 <span class="token operator">=</span> ip <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// ip2 points to arr[4], the last element in arr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ip加上4所得的结果仍是一个指针，该指针所指的元素与ip原来所指<br> 的元素相比前进了4个位置。</li><li>给指针加上一个整数，得到的新指针仍需指向同一数组的其他元<br> 素，或者指向同一数组的尾元素的下一位置：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ok: arr is converted to a pointer to its first element; p points one past the end of arr</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> arr <span class="token operator">+</span> sz<span class="token punctuation">;</span> <span class="token comment">// use caution -- do not dereference!</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// error: arr has only 5 elements; p2 has undefined value</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当给arr加上sz时，编译器自动地将arr转换成指向数组arr中首元素的<br> 指针。执行加法后，指针从首元素开始向前移动了sz（这里是5）个位<br> 置，指向新位置的元素。也就是说，它指向了数组arr尾元素的下一位<br> 置。如果计算所得的指针超出了上述范围就将产生错误，而且这种错误<br> 编译器一般发现不了。</p></li><li><p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算<br> 的两个指针必须指向同一个数组当中的元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// n is 5, the number of elements in arr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和<br> size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类<br> 型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。</p></li><li><p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的<br> 下一位置，就能利用关系运算符对其进行比较。例如，可以按照如下的<br> 方式遍历数组中的元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> arr<span class="token punctuation">,</span> <span class="token operator">*</span>e <span class="token operator">=</span> arr <span class="token operator">+</span> sz<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// use *b</span>
 <span class="token operator">++</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果两个指针分别指向不相关的对象，则不能比较它们：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">;</span>
<span class="token comment">// undefined: p and e are unrelated; comparison is meaningless!</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> e<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管作用可能不是特别明显，但必须说明的是，上述指针运算同样<br> 适用于空指针（参见2.3.2节，第48页）和所指对象并非数组的指针。在<br> 后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如<br> 果p是空指针，允许给p加上或减去一个值为0的整型常量表达式（参见<br> 2.4.4节，第58页）。两个空指针也允许彼此相减，结果当然是0。</li></ul><br><ul><li><mark>解引用和指针运算的交互</mark></li><li>指针加上一个整数所得的结果还是一个指针。假设结果指针指向了<br> 一个元素，则允许解引用该结果指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// array with 5 elements of type int</span>
<span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ia <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: initializes last to 8, the value of ia[4]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>表达式＊（ia+4）计算ia前进4个元素后的新地址，解引用该结果指<br> 针的效果等价于表达式ia[4]。</li><li>回忆一下在3.4.1节（第98页）中介绍过如果表达式含有解引用运算<br> 符和点运算符，最好在必要的地方加上圆括号。类似的，此例中指针加<br> 法的圆括号也不可缺少。如果写成下面的形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>last <span class="token operator">=</span> <span class="token operator">*</span>ia <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// ok: last = 4, equivalent to ia[0] + 4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>含义就与之前完全不同了，此时先解引用ia，然后给解引用的结果<br> 再加上4。4.1.2节（第121页）将对这一问题做进一步分析。</li></ul><br><ul><li><mark>下标和指针</mark></li><li>如前所述，在很多情况下使用数组的名字其实用的是一个指向数组<br> 首元素的指针。一个典型的例子是当对数组使用下标运算符时，编译器<br> 会自动执行上述转换操作。给定</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// array with 5 elements of type int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算<br> 其实是对指向数组元素的指针执行下标运算：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ia is converted to a pointer to the first element in ia</span>
 <span class="token comment">// ia[2] fetches the element to which (ia + 2) points</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> ia<span class="token punctuation">;</span> <span class="token comment">// p points to the first element in ia</span>
i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to i = ia[2]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只要指针指向的是数组中的元素（或者数组中尾元素的下一位<br> 置），都可以执行下标运算：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p points to the element indexed by 2</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p[1] is equivalent to *(p + 1),</span>
 <span class="token comment">// p[1] is the same element as ia[3]</span>
<span class="token keyword">int</span> k <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p[-2] is the same element as ia[0]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>虽然标准库类型string和vector也能执行下标运算，但是数组与它们<br> 相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而<br> 内置的下标运算无此要求，上面的最后一个例子很好地说明了这一点。<br> 内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针<br> 所指同一数组中的元素（或是同一数组尾元素的下一位置）。</p></li><li><p><mark>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样</mark></p></li></ul><h3 id="_3-5-3节练习" tabindex="-1"><a class="header-anchor" href="#_3-5-3节练习" aria-hidden="true">#</a> 3.5.3节练习</h3><ul><li>练习3.34：假定p1和p2指向同一个数组中的元素，则下面程序的功能是<br> 什么？什么情况下该程序是非法的？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>p1 <span class="token operator">+=</span> p2 <span class="token operator">-</span> p1<span class="token punctuation">;</span>

将 p1 移动到 p2 的位置。任何情况下都合法。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.35：编写一段程序，利用指针将数组中的元素置为0。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span> ptr <span class="token operator">!=</span> arr <span class="token operator">+</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.36：编写一段程序，比较两个数组是否相等。再写一段程序，比<br> 较两个vector对象是否相等。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>begin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>end<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token comment">// pb point to begin of the array, pe point to end of the array.</span>
<span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> pb1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> pe1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> pb2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> pe2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pe1 <span class="token operator">-</span> pb1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>pe2 <span class="token operator">-</span> pb2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// have different size.</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> i <span class="token operator">=</span> pb1<span class="token punctuation">,</span> <span class="token operator">*</span>j <span class="token operator">=</span> pb2<span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> pe1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> pe2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>i <span class="token operator">!=</span> <span class="token operator">*</span>j<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The two arrays are equal.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The two arrays are not equal.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;==========&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>vec1 <span class="token operator">==</span> vec2<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The two vectors are equal.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The two vectors are not equal.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-5-4-c风格字符串" tabindex="-1"><a class="header-anchor" href="#_3-5-4-c风格字符串" aria-hidden="true">#</a> 3.5.4 C风格字符串</h3><ul><li><p><mark>Warning</mark></p></li><li><p>尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C<br> 风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本<br> 原因。</p></li><li><p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承<br> 而来的C风格字符串（C-style character string）。C风格字符串不是一种<br> 类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此<br> 习惯书写的字符串存放在字符数组中并以空字符结束（null<br> terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着<br> 一个空字符（&#39;\\0&#39;）。一般利用指针来操作这些字符串。</p></li></ul><br><ul><li><mark>C标准库String函数</mark></li><li>表3.8列举了C语言标准库提供的一组函数，这些函数可用于操作C<br> 风格字符串，它们定义在cstring头文件中，cstring是C语言头文件string.h<br> 的C++版本。</li></ul><figure><img src="`+m+`" alt="table3-8" tabindex="0" loading="lazy"><figcaption>table3-8</figcaption></figure><ul><li><mark>表3.8所列的函数不负责验证其字符串参数。</mark></li><li>传入此类函数的指针必须指向以空字符作为结束的数组：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> ca<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;+&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// not null terminated</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// disaster: ca isn&#39;t null terminated</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，<br> 因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中<br> 的位置不断向前寻找，直到遇到空字符才停下来。</p></li><li><p><mark>比较字符串</mark></p></li><li><p>比较两个C风格字符串的方法和之前学习过的比较标准库string对象<br> 的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运<br> 算符和相等性运算符：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string s1 <span class="token operator">=</span> <span class="token string">&quot;A string example&quot;</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> <span class="token string">&quot;A different string&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;</span> s2<span class="token punctuation">)</span> <span class="token comment">// false: s2 is less than s1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针<br> 而非字符串本身：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> ca1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;A string example&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> ca2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;A different string&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ca1 <span class="token operator">&lt;</span> ca2<span class="token punctuation">)</span> <span class="token comment">// undefined: compares two unrelated addresses</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>谨记之前介绍过的，当使用数组的时候其实真正用的是指向数组首<br> 元素的指针（参见3.5.3节，第105页）。因此，上面的if条件实际上比较<br> 的是两个const char＊的值。这两个指针指向的并非同一对象，所以将得<br> 到未定义的结果。</p></li><li><p>要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不<br> 再是指针了。如果两个字符串相等，strcmp返回0；如果前面的字符串<br> 较大，返回正值；如果后面的字符串较大，返回负值：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ca1<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// same effect as string comparison s1 &lt; s2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><ul><li><mark>目标字符串的大小由调用者指定</mark></li><li>连接或拷贝C风格字符串也与标准库string对象的同类操作差别很<br> 大。例如，要想把刚刚定义的那两个string对象s1和s2连接起来，可以直<br> 接写成下面的形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// initialize largeStr as a concatenation of s1, a space, and s2</span>
string largeStr <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>同样的操作如果放到ca1和ca2这两个数组身上就会产生错误了。表<br> 达式ca1 + ca2试图将两个指针相加，显然这样的操作没什么意义，也肯<br> 定是非法的。</p></li><li><p>正确的方法是使用strcat函数和strcpy函数。不过要想使用这两个函<br> 数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以<br> 便容纳下结果字符串及末尾的空字符。下面的代码虽然很常见，但是充<br> 满了安全风险，极易引发严重错误：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// disastrous if we miscalculated the size of largeStr</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copies ca1 into largeStr</span>
<span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// adds a space at the end of largeStr</span>
<span class="token function">strcat</span><span class="token punctuation">(</span>largeStr<span class="token punctuation">,</span> ca2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// concatenates ca2 onto largeStr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，<br> 而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。不<br> 幸的是，这样的代码到处都是，程序员根本没法照顾周全。这类代码充<br> 满了风险而且经常导致严重的安全泄漏。</li><li><mark>对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效</mark></li></ul><h3 id="_3-5-4节练习" tabindex="-1"><a class="header-anchor" href="#_3-5-4节练习" aria-hidden="true">#</a> 3.5.4节练习</h3><ul><li>练习3.37：下面的程序是何含义，程序的输出结果是什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> ca<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">&#39;h&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;e&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;o&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> ca<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>cp <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token operator">++</span>cp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

会将ca 字符数组中的元素打印出来。但是因为没有空字符的存在，程序不会退出循环
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.38：在本节中我们提到，将两个指针相加不但是非法的，而且也<br> 没什么意义。请问为什么两个指针相加没什么意义？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>将两个指针相减可以表示两个指针<span class="token punctuation">(</span>在同一数组中<span class="token punctuation">)</span>相距的距离，将指针加上一个整数也可以表示移动这个指针到某一位置。但是两个指针相加并没有逻辑上的意义，因此两个指针不能相加。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>练习3.39：编写一段程序，比较两个string对象。再编写一段程序，比较<br> 两个C风格字符串的内容。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// use string.</span>
    string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;Mooophy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">&quot;Pezy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;same string.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">&gt;</span> s2<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Mooophy &gt; Pezy&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Mooophy &lt; Pezy&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;=========&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// use C-Style character strings.</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cs1 <span class="token operator">=</span> <span class="token string">&quot;Wangyue&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cs2 <span class="token operator">=</span> <span class="token string">&quot;Pezy&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>cs1<span class="token punctuation">,</span> cs2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;same string.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Wangyue &lt; Pezy&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Wangyue &gt; Pezy&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.40：编写一段程序，定义两个字符数组并用字符串字面值初始化<br> 它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用<br> strcpy和strcat把前两个数组的内容拷贝到第三个数组中。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>

<span class="token keyword">const</span> <span class="token keyword">char</span> cstr1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> cstr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;world!&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> size_t new_size <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cstr1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cstr2<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> cstr3<span class="token punctuation">[</span>new_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token function">strcpy</span><span class="token punctuation">(</span>cstr3<span class="token punctuation">,</span> cstr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcat</span><span class="token punctuation">(</span>cstr3<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcat</span><span class="token punctuation">(</span>cstr3<span class="token punctuation">,</span> cstr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> cstr3 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-5-5-与旧代码的接口" tabindex="-1"><a class="header-anchor" href="#_3-5-5-与旧代码的接口" aria-hidden="true">#</a> 3.5.5　与旧代码的接口</h3><ul><li><p>很多C++程序在标准库出现之前就已经写成了，它们肯定没用到<br> string和vector类型。而且，有一些C++程序实际上是与C语言或其他语<br> 言的接口程序，当然也无法使用C++标准库。因此，现代的C++程序不<br> 得不与那些充满了数组和/或C风格字符串的代码衔接，为了使这一工作<br> 简单易行，C++专门提供了一组功能。</p></li><li><p><mark>混用string对象和C风格字符串</mark></p></li><li><p>3.2.1节（第76页）介绍过允许使用字符串字面值来初始化string对象：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s holds Hello World</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符<br> 结束的字符数组来替代：</p></li><li><p>允许使用以空字符结束的字符数组来初始化string对象或为string对<br> 象赋值。</p></li><li><p>在string对象的加法运算中允许使用以空字符结束的字符数组作为<br> 其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋<br> 值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</p></li><li><p>上述性质反过来就不成立了：如果程序的某处需要一个C风格字符<br> 串，无法直接用string对象来代替它。例如，不能用string对象直接初始<br> 化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str<br> 的成员函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t initialize a char* from a string</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，<br> 函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数<br> 组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的<br> 类型是const char＊，从而确保我们不会改变字符数组的内容。</p></li><li><p>我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的<br> 操作改变了s的值就可能让之前返回的数组失去效用。</p></li><li><p><mark>如果执行完c_str（）函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份</mark></p></li></ul><br><ul><li><mark>使用数组初始化vector对象</mark></li><li>3.5.1节（第102页）介绍过不允许使用一个数组为另一个内置类型<br> 的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使<br> 用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的<br> 首元素地址和尾后地址就可以了：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> int_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化<br> 的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素<br> 的下一位置。此例中，使用标准库函数begin和end（参见3.5.3节，第106<br> 页）来分别计算int_arr的首指针和尾后指针。在最终的结果中，ivec将<br> 包含6个元素，它们的次序和值都与数组int_arr完全一样。</p></li><li><p>用于初始化vector对象的值也可能仅是数组的一部分：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// copies three elements: int_arr[1], int_arr[2], int_arr[3]</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">subVec</span><span class="token punctuation">(</span>int_arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> int_arr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这条初始化语句用3个元素创建了对象subVec，3个元素的值分别来<br> 自int_arr[1]、int_arr[2]和int_arr[3]。</p></li><li><p><mark>建议：尽量使用标准库类型而非数组</mark></p></li><li><p>使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操<br> 作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声<br> 明指针时的语法错误。</p></li><li><p>现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽<br> 量使用string，避免使用C风格的基于数组的字符串。</p></li></ul><h3 id="_3-5-5节练习" tabindex="-1"><a class="header-anchor" href="#_3-5-5节练习" aria-hidden="true">#</a> 3.5.5节练习</h3><ul><li>练习3.41：编写一段程序，用整型数组初始化一个vector对象。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>begin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>end<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习3.42：编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>begin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>end<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-6-多维数组" tabindex="-1"><a class="header-anchor" href="#_3-6-多维数组" aria-hidden="true">#</a> 3.6　多维数组</h2><ul><li>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是<br> 数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。</li><li>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一<br> 个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of size 3; each element is an array of ints of size 4</span>
<span class="token comment">// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// initialize all elements to 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如3.5.1节（第103页）所介绍的，按照由内而外的顺序阅读此类定<br> 义有助于更好地理解其真实含义。在第一条语句中，我们定义的名字是<br> ia，显然ia是一个含有3个元素的数组。接着观察右边发现，ia的元素也<br> 有自己的维度，所以ia的元素本身又都是含有4个元素的数组。再观察<br> 左边知道，真正存储的元素是整数。因此最后可以明确第一条语句的含<br> 义：它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数<br> 的数组。</p></li><li><p>使用同样的方式理解arr的定义。首先arr是一个大小为10的数组，<br> 它的每个元素都是大小为20的数组，这些数组的元素又都是含有30个整<br> 数的数组。实际上，定义数组时对下标运算符的数量并没有限制，因此<br> 只要愿意就可以定义这样一个数组：它的元素还是数组，下一级数组的<br> 元素还是数组，再下一级数组的元素还是数组，以此类推。</p></li><li><p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。<br> 多维数组的初始化</p></li><li><p>允许使用花括号括起来的一组值初始化多维数组，这点和普通的数<br> 组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起<br> 来:</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// three elements; each element is an array of size 4</span>
 <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// initializers for the row indexed by 0</span>
 <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// initializers for the row indexed by 1</span>
 <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span> <span class="token comment">// initializers for the row indexed by 2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其中内层嵌套着的花括号并非必需的，例如下面的初始化语句，形<br> 式上更为简洁，完成的功能和上面这段代码完全一样：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// equivalent initialization without the optional nested braces for each row</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>类似于一维数组，在初始化多维数组时也并非所有元素的值都必须<br> 包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过<br> 如下的语句即可：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// explicitly initialize only element 0 in each row</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其他未列出的元素执行默认值初始化，这个过程和一维数组（参见<br> 3.5.1节，第102页）一样。在这种情况下如果再省略掉内层的花括号，<br> 结果就大不一样了。下面的代码</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// explicitly initialize row 0; the remaining elements are value initialized</span>
<span class="token keyword">int</span> ix<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>含义发生了变化，它初始化的是第一行的4个元素，其他元素被初<br> 始化为0。</li></ul><br><ul><li><p><mark>多维数组的下标引用</mark></p></li><li><p>可以使用下标运算符来访问多维数组的元素，此时数组的每个维度<br> 对应一个下标运算符。</p></li><li><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式<br> 的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量<br> 比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// assigns the first element of arr to the last element in the last row of ia</span>
ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>row<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ia<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// binds row to the second four-element array in ia</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在第一个例子中，对于用到的两个数组来说，表达式提供的下标运<br> 算符数量都和它们各自的维度相同。在等号左侧，ia[2]得到数组ia的最<br> 后一行，此时返回的是表示ia最后一行的那个一维数组而非任何实际元<br> 素；对这个一维数组再取下标，得到编号为[3]的元素，也就是这一行的<br> 最后一个元素。</p></li><li><p>类似的，等号右侧的运算对象包含3个维度。首先通过索引0得到最<br> 外层的数组，它是一个大小为20的（多维）数组；接着获取这20个元素<br> 数组的第一个元素，得到一个大小为30的一维数组；最后再取出其中的<br> 第一个元素。</p></li><li><p>在第二个例子中，把row定义成一个含有4个整数的数组的引用，然<br> 后将其绑定到ia的第2行。</p></li><li><p>再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数<br> 组的元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> size_t rowCnt <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> colCnt <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span>rowCnt<span class="token punctuation">]</span><span class="token punctuation">[</span>colCnt<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 12 uninitialized elements</span>
<span class="token comment">// for each row</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> rowCnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// for each column within the row</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">!=</span> colCnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// assign the element&#39;s positional index as its value</span>
 ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> colCnt <span class="token operator">+</span> j<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>外层的for循环遍历ia的所有元素，注意这里的元素是一维数组；内<br> 层的for循环则遍历那些一维数组的整数元素。此例中，我们将元素的值<br> 设为该元素在整个数组中的序号。</li></ul><br><ul><li><mark>使用范围 for语句处理多维数组</mark></li><li>由于在C++11新标准中新增了范围for语句，所以前一个程序可以简<br> 化为如下形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>size_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>row <span class="token operator">:</span> ia<span class="token punctuation">)</span> <span class="token comment">// for every element in the outer array</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col <span class="token operator">:</span> row<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// for every element in the inner array</span>
 col <span class="token operator">=</span> cnt<span class="token punctuation">;</span> <span class="token comment">// give this element the next value</span>
 <span class="token operator">++</span>cnt<span class="token punctuation">;</span> <span class="token comment">// increment cnt</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这个循环赋给ia元素的值和之前那个循环是完全相同的，区别之处<br> 是通过使用范围for语句把管理数组索引的任务交给了系统来完成。因为<br> 要改变元素的值，所以得把控制变量row和col声明成引用类型（参见<br> 3.2.3节，第83页）。第一个for循环遍历ia的所有元素，这些元素是大小<br> 为4的数组，因此row的类型就应该是含有4个整数的数组的引用。第二<br> 个for循环遍历那些4元素数组中的某一个，因此col的类型是整数的引<br> 用。每次迭代把cnt的值赋给ia的当前元素，然后将cnt加1。</p></li><li><p>在上面的例子中，因为要改变数组元素的值，所以我们选用引用类<br> 型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。<br> 举一个例子，考虑如下的循环：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>row <span class="token operator">:</span> ia<span class="token punctuation">)</span> <span class="token comment">// for every element in the outer array</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> col <span class="token operator">:</span> row<span class="token punctuation">)</span> <span class="token comment">// for every element in the inner array</span>
 cout <span class="token operator">&lt;&lt;</span> col <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个循环中并没有任何写操作，可是我们还是将外层循环的控制变<br> 量声明成了引用类型，这是为了避免数组被自动转成指针（参见3.5.3<br> 节，第105页）。假设不用引用类型，则循环如下述形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> row <span class="token operator">:</span> ia<span class="token punctuation">)</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> col <span class="token operator">:</span> row<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的<br> 所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类<br> 型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类<br> 型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的<br> 类型就是int＊，显然内层的循环就不合法了，编译器将试图在一个int＊<br> 内遍历，这显然和程序的初衷相去甚远。</li><li><mark>要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</mark></li></ul><br><ul><li><p><mark>指针和多维数组</mark></p></li><li><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元<br> 素的指针。</p></li><li><p>定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。</p></li><li><p>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的<br> 指针实际上是指向第一个内层数组的指针：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of size 3; each element is an array of ints of size 4</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> ia<span class="token punctuation">;</span> <span class="token comment">// p points to an array of four ints</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>ia<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p now points to the last element in ia</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>根据3.5.1节（第103页）提出的策略，我们首先明确（＊p）意味着<br> p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数<br> 组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个<br> 整数的数组的指针。</p></li><li><p>在上述声明中，圆括号必不可少：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of pointers to int</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ip<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// pointer to an array of four ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>随着C++11新标准的提出，通过使用auto或者decltype（参见2.5.2<br> 节，第61页）就能尽可能地避免在数组前面加上一个指针类型了：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// print the value of each element in ia, with each inner array on its own line</span>
<span class="token comment">// p points to an array of four ints</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> ia<span class="token punctuation">;</span> p <span class="token operator">!=</span> ia <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// q points to the first element of an array of four ints; that is, q points to an</span>
<span class="token keyword">int</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> q <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token operator">*</span>p <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
 cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>外层的for循环首先声明一个指针p并令其指向ia的第一个内层数<br> 组，然后依次迭代直到ia的全部3行都处理完为止。其中递增运算++p负<br> 责将指针p移动到ia的下一行。</p></li><li><p>内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p<br> 当前所在行的第一个元素。＊p是一个含有4个整数的数组，像往常一<br> 样，数组名被自动地转换成指向该数组首元素的指针。内层for循环不断<br> 迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层for<br> 循环的终止条件，再一次解引用p得到指向内层数组首元素的指针，给<br> 它加上4就得到了终止条件。</p></li><li><p>当然，使用标准库函数begin和end（参见3.5.3节，第106页）也能实<br> 现同样的功能，而且看起来更简洁一些：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code> <span class="token comment">// p points to the first array in ia</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// q points to the first element in an inner array</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> q <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span> <span class="token comment">// prints the int value to which q</span>
points
 cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在这一版本的程序中，循环终止条件由end函数负责判断。虽然我<br> 们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指<br> 向整数的指针，但是使用auto关键字我们就不必再烦心这些类型到底是<br> 什么了。</li></ul><br><ul><li><mark>类型别名简化多维数组的指针</mark></li><li>读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工<br> 作，使用类型别名（参见2.5.1节，第60页）能让这项工作变得简单一点<br> 儿，例如：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">using</span> int_array <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// new style type alias declaration; see § 2.5.1 (p.68)</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> int_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// equivalent typedef declaration; § 2.5.1 (p. 67)</span>
<span class="token comment">// print the value of each element in ia, with each inner array on its own line</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int_array <span class="token operator">*</span>p <span class="token operator">=</span> ia<span class="token punctuation">;</span> p <span class="token operator">!=</span> ia <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token operator">*</span>p <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
 cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>程序将类型“4个整数组成的数组”命名为int_array，用类型名<br> int_array定义外层循环的控制变量让程序显得简洁明了</li></ul><h2 id="_3-6节练习" tabindex="-1"><a class="header-anchor" href="#_3-6节练习" aria-hidden="true">#</a> 3.6节练习</h2><ul><li><p>练习3.43：编写3个不同版本的程序，令其均能输出ia的元素。版本1使<br> 用范围for语句管理迭代过程；版本2和版本3都使用普通的for语句，其<br> 中版本2要求用下标运算符，版本3要求用指针。此外，在所有3个版本<br> 的程序中都要直接写出数据类型，而不能使用类型别名、auto关键字或<br> decltype关键字。</p></li><li><p>练习3.44：改写上一个练习中的程序，使用类型别名来代替循环控制变<br> 量的类型。</p></li><li><p>练习3.45：再一次改写程序，这次使用auto关键字。</p></li></ul><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><ul><li><p>string和vector是两种最重要的标准库类型。string对象是一个可变长<br> 的字符序列，vector对象是一组同类型对象的容器。</p></li><li><p>迭代器允许对容器中的对象进行间接访问，对于string对象和vector<br> 对象来说，可以通过迭代器访问元素或者在元素间移动。</p></li><li><p>数组和指向数组元素的指针在一个较低的层次上实现了与标准库类<br> 型string和vector类似的功能。一般来说，应该优先选用标准库提供的类<br> 型，之后再考虑C++语言内置的低层的替代品数组或指针。</p></li></ul><h2 id="术语表" tabindex="-1"><a class="header-anchor" href="#术语表" aria-hidden="true">#</a> 术语表</h2><ul><li><p>begin 是string和vector的成员，返回指向第一个元素的迭代器。也<br> 是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</p></li><li><p>缓冲区溢出（buffer overflow）一种严重的程序故障，主要的原因<br> 是试图通过一个越界的索引访问容器内容，容器类型包括string、vector<br> 和数组等。</p></li><li><p>C风格字符串（C-style string）以空字符结束的字符数组。字符串<br> 字面值是C风格字符串，C风格字符串容易出错。</p></li><li><p>类模板（class template）用于创建具体类类型的模板。要想使用类<br> 模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需<br> 要指定元素的类型：<code>vector&lt;int&gt;包含int类型的元素</code>。</p></li><li><p>编译器扩展（compiler extension）某个特定的编译器为C++语言额<br> 外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上。</p></li><li><p>容器（container） 是一种类型，其对象容纳了一组给定类型的对<br> 象。vector是一种容器类型。</p></li><li><p>拷贝初始化（copy initialization） 使用赋值号（=）的初始化形<br> 式。新创建的对象是初始值的一个副本。</p></li><li><p>difference_type由string和vector定义的一种带符号整数类型，表示<br> 两个迭代器之间的距离。</p></li><li><p>直接初始化（direct initialization）不使用赋值号（=）的初始化形<br> 式。</p></li><li><p>empty是string和vector的成员，返回一个布尔值。当对象的大小为0<br> 时返回真，否则返回假。</p></li><li><p>end是string和vector的成员，返回一个尾后迭代器。也是一个标准<br> 库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针</p></li><li><p>getline 在string头文件中定义的一个函数，以一个istream对象和一<br> 个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行<br> 符停止，然后将读入的数据存入string对象，最后返回istream对象。其<br> 中换行符读入但是不保留。</p></li><li><p>索引（index） 是下标运算符使用的值。表示要在string对象、<br> vector对象或者数组中访问的一个位置。</p></li><li><p>实例化（instantiation） 编译器生成一个指定的模板类或函数的过程。</p></li><li><p>迭代器（iterator） 是一种类型，用于访问容器中的元素或者在元<br> 素之间移动。</p></li><li><p>迭代器运算（iterator arithmetic） 是string或vector的迭代器的运<br> 算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相<br> 比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们<br> 之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下<br> 一位置。</p></li><li><p>以空字符结束的字符串（null-terminated string） 是一个字符串，<br> 它的最后一个字符后面还跟着一个空字符（&#39;\\0&#39;）。</p></li><li><p>尾后迭代器（off-the-end iterator） end函数返回的迭代器，指向一<br> 个并不存在的元素，该元素位于容器尾元素的下一位置。</p></li><li><p>指针运算（pointer arithmetic） 是指针类型支持的算术运算。指向<br> 数组的指针所支持的运算种类与迭代器运算一样。</p></li><li><p>prtdiff_t 是cstddef头文件中定义的一种与机器实现有关的带符号整<br> 数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。</p></li><li><p>push_back 是vector的成员，向vector对象的末尾添加元素。</p></li><li><p>范围for语句（range for） 一种控制语句，可以在值的一个特定集<br> 合内迭代。</p></li><li><p>size 是string和vector的成员，分别返回字符的数量或元素的数量。<br> 返回值的类型是size_type</p></li><li><p>size_t 是cstddef头文件中定义的一种与机器实现有关的无符号整数<br> 类型，它的空间足够大，能够表示任意数组的大小</p></li><li><p>size_type 是string和vector定义的类型的名字，能存放下任意string对<br> 象或vector对象的大小。在标准库中，size_type被定义为无符号类型。</p></li><li><p>string 是一种标准库类型，表示字符的序列。</p></li><li><p>using声明（using declaration） 令命名空间中的某个名字可被程序<br> 直接使用。</p></li><li><p>using 命名空间 ：： 名字；<br> 上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部<br> 分命名空间：：。</p></li><li><p>值初始化（value initialization） 是一种初始化过程。内置类型初<br> 始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造<br> 函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只<br> 说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编<br> 译器会生成一个值，而容器的元素被初始化为该值。</p></li><li><p>vector 是一种标准库类型，容纳某指定类型的一组元素。</p></li><li><p>++运算符（++ operator）是迭代器和指针定义的递增运算符。执<br> 行“加1”操作使得迭代器指向下一个元素。</p></li><li><p>[ ]运算符（[ ] operator）下标运算符。obj[j]得到容器对象obj中位<br> 置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引<br> 是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是<br> 整数，则<code>p[n]</code>与＊（p+n）等价。</p></li><li><p>-&gt;运算符（-&gt;operator）箭头运算符，该运算符综合了解引用操作<br> 和点操作。a-&gt;b等价于（＊a）.b。</p></li><li><p>&lt;&lt;运算符（&lt;&lt;operator）标准库类型string定义的输出运算符，负<br> 责输出string对象中的字符。</p></li><li><blockquote><blockquote><p>运算符（&gt;&gt;operator）标准库类型string定义的输入运算符，负<br> 责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对<br> 象，该运算对象应该是一个string对象。</p></blockquote></blockquote></li><li><p>！运算符（！ operator）逻辑非运算符，将它的运算对象的布尔值<br> 取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为<br> 假。</p></li><li><p>&amp;&amp;运算符（&amp;&amp;operator）逻辑与运算符，如果两个运算对象都是<br> 真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。</p></li><li><p>||运算符（|| operator）逻辑或运算符，任何一个运算对象是真，结<br> 果就为真。只有当左侧运算对象为假时才会检查右侧运算对象。</p></li></ul>`,352);function _(q,x){const a=c("router-link");return l(),i("div",null,[g,y,r(" more "),h,n("nav",w,[n("ul",null,[n("li",null,[t(a,{to:"#第3章-字符串、向量和数组"},{default:p(()=>[s("第3章　字符串、向量和数组")]),_:1})]),n("li",null,[t(a,{to:"#_3-1-命名空间的using声明"},{default:p(()=>[s("3.1　命名空间的using声明")]),_:1})]),n("li",null,[t(a,{to:"#_3-3-标准库类型vector"},{default:p(()=>[s("3.3　标准库类型vector")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_3-3-1-定义和初始化vector对象"},{default:p(()=>[s("3.3.1　定义和初始化vector对象")]),_:1})]),n("li",null,[t(a,{to:"#_3-3-2-向vector对象中添加元素"},{default:p(()=>[s("3.3.2　向vector对象中添加元素")]),_:1})]),n("li",null,[t(a,{to:"#_3-3-3-其他vector操作"},{default:p(()=>[s("3.3.3　其他vector操作")]),_:1})]),n("li",null,[t(a,{to:"#_3-3-3节练习"},{default:p(()=>[s("3.3.3节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_3-4-迭代器介绍"},{default:p(()=>[s("3.4　迭代器介绍")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_3-4-1-使用迭代器"},{default:p(()=>[s("3.4.1　使用迭代器")]),_:1})]),n("li",null,[t(a,{to:"#_3-4-1节练习"},{default:p(()=>[s("3.4.1节练习")]),_:1})]),n("li",null,[t(a,{to:"#_3-4-2-迭代器运算"},{default:p(()=>[s("3.4.2　迭代器运算")]),_:1})]),n("li",null,[t(a,{to:"#_3-4-2节练习"},{default:p(()=>[s("3.4.2节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_3-5-数组"},{default:p(()=>[s("3.5　数组")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_3-5-1-定义和初始化内置数组"},{default:p(()=>[s("3.5.1　定义和初始化内置数组")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-1节练习"},{default:p(()=>[s("3.5.1节练习")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-2-访问数组元素"},{default:p(()=>[s("3.5.2　访问数组元素")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-2节练习"},{default:p(()=>[s("3.5.2节练习")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-3-指针和数组"},{default:p(()=>[s("3.5.3　指针和数组")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-3节练习"},{default:p(()=>[s("3.5.3节练习")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-4-c风格字符串"},{default:p(()=>[s("3.5.4 C风格字符串")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-4节练习"},{default:p(()=>[s("3.5.4节练习")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-5-与旧代码的接口"},{default:p(()=>[s("3.5.5　与旧代码的接口")]),_:1})]),n("li",null,[t(a,{to:"#_3-5-5节练习"},{default:p(()=>[s("3.5.5节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_3-6-多维数组"},{default:p(()=>[s("3.6　多维数组")]),_:1})]),n("li",null,[t(a,{to:"#_3-6节练习"},{default:p(()=>[s("3.6节练习")]),_:1})]),n("li",null,[t(a,{to:"#小结"},{default:p(()=>[s("小结")]),_:1})]),n("li",null,[t(a,{to:"#术语表"},{default:p(()=>[s("术语表")]),_:1})])])]),f])}const S=o(b,[["render",_],["__file","D-第三章字符串和向量和数组.html.vue"]]);export{S as default};
