import{_ as u}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as d,c as r,d as k,a as n,e as o,w as a,b as s,f as l}from"./app-2a2d189a.js";const m={},v=n("h1",{id:"d-模板元编程与函数式编程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#d-模板元编程与函数式编程","aria-hidden":"true"},"#"),s(" D-模板元编程与函数式编程")],-1),b=n("p",null,"D-模板元编程与函数式编程",-1),g=n("div",{class:"hint-container info"},[n("p",{class:"hint-container-title"},"说明"),n("ul",null,[n("li",null,"主要是各种搜索找的学习；"),n("li",null,"现代C++中的模板和元编程。首先要了解模板的概念。")])],-1),w={class:"table-of-contents"},f=l(`<h2 id="简单介绍主要是基础" tabindex="-1"><a class="header-anchor" href="#简单介绍主要是基础" aria-hidden="true">#</a> 简单介绍主要是基础</h2><h2 id="一、模板函数-template" tabindex="-1"><a class="header-anchor" href="#一、模板函数-template" aria-hidden="true">#</a> 一、模板函数（template）</h2><ul><li><mark>为什么需要模板函数（template）</mark></li><li>为了弄明白模板的概念，首先应理解引入模板的原因。以往在面向对象的编程范式中，如需实现一个函数使其倍增一个数的值（即乘以2），就需要为不同的数据类型（例如int、float、double）分别定义重载函数。在实际调用时，编程语言会根据传入参数的数据类型自动选择对应的重载函数。</li><li>但是，这种方法有一个显著的缺点：当需要支持新的数据类型时（如突然需要让long类型的数乘以2），就必须重新编写一个相应的重载函数。这显然是一种时间上的浪费，并且会增加代码维护的难度。</li><li>因此，为了实现代码的复用并处理上述问题，引入了模板的概念。模板允许函数或类操作任意类型的数据，而无需为每种类型编写专门的代码。这极大地提高了程序的灵活性和复用性。在上述示例中，通过模板，可以创建一个单一的函数模板来处理所有数值类型的乘以2运算，而不是为每个类型编写重复的代码。</li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token keyword">float</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token keyword">double</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">3.14f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">2.718</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>模板函数的定义</mark></p></li><li><p>使用模板以后，可以观察到以下区别：首先，可以发现无论是<code>int</code>类型还是<code>float</code>类型，都能发现一定的规律。如果此处使用了泛型<code>T</code>，那么相关的位置也都将使用<code>T</code>。这时，在代码上方定义<code>template&lt;class T&gt;</code>即表明，<code>T</code>是一个占位符。它可以被替换成<code>int</code>、<code>float</code>或者<code>double</code>等类型，编译器会自动生成对应的函数实例。</p></li><li><p>这里的<code>class T</code>表示<code>T</code>是一个类型参数。一些教材可能会写作<code>template&lt;typename T&gt;</code>，其含义与<code>class T</code>相同，两者可以互换使用。个人偏好使用<code>class</code>关键字。</p></li><li><p>使用尖括号<code>&lt;&gt;</code>表示调用模板实例的操作。例如，如果函数模板被调用并传入<code>int</code>作为类型参数，它会实例化出一个以<code>int</code>类型操作的函数，从而与模板定义一致。</p></li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">twice</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">twice</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">twice</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">3.14f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">twice</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">2.718</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><mark>模板函数：自动推导参数类型</mark></li><li>那这样需要手动写 int&gt;，float&gt; 用起来还不如重载方便了？</li><li>别担心，C++ 规定：</li><li>当模板类型参数 T 作为函数参数时，则可以省略该模板参数。自动根据调用者的参数判断。</li><li>模板函数能够自动推导类型参数T，这意味着在调用时不必显式地指定类型。编译器会根据实参的类型自动确定模板参数。例如，当传入数值21，编译器会观察到T出现在模板参数列表中，并且实参是一个整数，于是它会自动推导出T是int类型，并相应地实例化函数模板。</li><li>这一特性被称为模板的自动类型推导。因此，当调用模板函数并传递整数47作为参数时，编译器也会自动推导出参数类型为int。</li><li>模板的这种自动类型推导让模板函数的使用变得和函数重载一样便捷。它减少了程序员需要编写的代码量，同时也降低了程序出错的可能性。</li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">twice</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">3.14f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">twice</span><span class="token punctuation">(</span><span class="token number">2.718</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>模板函数：特化的重载</mark></p></li><li><p>有时候，一个统一的实现（比如 t * 2）满足不了某些特殊情况。比如 std::string 就不能用乘法来重复，这时候我们需要用 t + t 来替代，怎么办呢？</p></li><li><p>没关系，只需添加一个 twice(std::string) 即可，他会自动和已有的模板 twice T&gt;(T) 之间相互重载。</p></li><li><p>在使用模板时，会遇到一种情形，当需要对类型<code>T</code>的值进行加倍时，大多数情况下可以直接乘以2。但存在特殊情况，譬如对于char类型，在C++中，char类型并不提供乘2操作，必须使用加法（例如<code>&#39;7&#39; + &#39;7&#39;</code>）来实现。</p></li><li><p>因此，希望对于大多数基础类型直接使用乘以2的操作，而对于char类型这个特例，使用加法操作。在这种场景下，可以通过重载和模板结合的方式实现。如果用char类型调用，编译器会选择适合char的重载版本，而不使用通用模板。</p></li><li><p>但是这样也有一个问题，那就是如果我用 twice(“hello”) 这样去调用，他不会自动隐式转换到 std::string 并调用那个特化函数，而是会去调用模板函数 twice&lt;char *&gt;(“hello”)，从而出错。可能的解决方案：SFINAE。</p></li><li><p>关于const表达式的问题，编译器不会自动将一个带const的表达式转换为char类型，而是将const表达式看作是类型<code>T</code>本身，这可能导致误调用模板函数，进而导致错误。</p></li><li><p>解决此类问题的一种方法是利用SFINAE（Substitution Failure Is Not An Error）原则。可以在模板中加入额外的使能（enable_if）条件，确保仅当<code>T</code>符合某些条件时才启用该模板函数。</p></li></ul>`,12),h={class:"hint-container details"},y=n("summary",null,"Click me to view the code!",-1),T=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[n("span",{class:"token macro property"},[n("span",{class:"token directive-hash"},"#"),n("span",{class:"token directive keyword"},"include"),s(),n("span",{class:"token string"},"<iostream>")]),s(`

`),n("span",{class:"token keyword"},"template"),s(),n("span",{class:"token operator"},"<"),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"T"),n("span",{class:"token operator"},">"),s(`
T `),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),s("T t"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" t "),n("span",{class:"token operator"},"*"),s(),n("span",{class:"token number"},"2"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

std`),n("span",{class:"token double-colon punctuation"},"::"),s("string "),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),s("std"),n("span",{class:"token double-colon punctuation"},"::"),s("string t"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" t "),n("span",{class:"token operator"},"+"),s(" t"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token keyword"},"int"),s(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"21"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"3.14f"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"2.718"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),s("std"),n("span",{class:"token double-colon punctuation"},"::"),n("span",{class:"token function"},"string"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"hello"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),_=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[n("span",{class:"token macro property"},[n("span",{class:"token directive-hash"},"#"),n("span",{class:"token directive keyword"},"include"),s(),n("span",{class:"token string"},"<iostream>")]),s(`

`),n("span",{class:"token keyword"},"template"),s(),n("span",{class:"token operator"},"<"),n("span",{class:"token keyword"},"class"),s(),n("span",{class:"token class-name"},"T"),n("span",{class:"token operator"},">"),s(`
T `),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),s("T t"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" t "),n("span",{class:"token operator"},"*"),s(),n("span",{class:"token number"},"2"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

std`),n("span",{class:"token double-colon punctuation"},"::"),s("string "),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),s("std"),n("span",{class:"token double-colon punctuation"},"::"),s("string t"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" t "),n("span",{class:"token operator"},"+"),s(" t"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token keyword"},"int"),s(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"21"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"3.14f"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"2.718"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
    std`),n("span",{class:"token double-colon punctuation"},"::"),s("cout "),n("span",{class:"token operator"},"<<"),s(),n("span",{class:"token function"},"twice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"hello"'),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"<<"),s(" std"),n("span",{class:"token double-colon punctuation"},"::"),s("endl"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),N=l(`<br><ul><li><p><mark>模板函数：默认参数类型</mark></p></li><li><p>但是如果模板类型参数 T 没有出现在函数的参数中，那么编译器就无法推断，就不得不手动指定了。</p></li><li><p>但是，可以通过 <code>template &lt;class T = int&gt;</code> 表示调用者没有指定时，T 默认为 int。</p></li><li><p>提及模板参数时，先前讨论了，如果类型<code>T</code>出现在函数参数列表中，编译器可以自动根据传入的实参类型推导出<code>T</code>。然而，当创建了一个名为<code>two</code>的模板函数，其目的是返回特定类型<code>T</code>的值2，但该函数本身不接受任何参数，此时直接调用<code>two()</code>会导致编译器无法推断出<code>T</code>的具体类型，因此用户必须手动指定类型。</p></li><li><p>在定义模板函数时，可以使用默认模板参数来简化此类问题。例如，在模板声明中使用<code>template&lt;typename T = int&gt;</code>，则<code>T</code>默认为<code>int</code>类型。这种做法相当于为模板参数提供了一个默认值。注意，此处的默认模板参数声明使用的是尖括号<code>&lt;&gt;</code>，而不是标准函数的默认参数所使用的圆括号<code>()</code>。</p></li><li><p>最后，需要确认，如果不提供<code>T</code>的类型，且没有默认模板参数，那么编译器在遇到没有参数的模板函数调用时将无法推断类型，需要用户显式指定。</p></li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>
T <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">two</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">two</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">two</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 等价于 two&lt;int&gt;()</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>模板参数：整数也可以作为参数</mark></p></li><li><p><code>template &lt;class T&gt;</code>可以声明类型 T 作为模板尖括号里的参数。除了类型，任意整数也可以作为模板参数：<code>template &lt;int N&gt;</code>来声明一个整数 N 作为模板参数。</p></li><li><p>不过模板参数只支持整数类型（包括 enum）。浮点类型、指针类型，不能声明为模板参数。自定义类型也不可以，比如：<code>template &lt;float F, glm::vec3 V&gt; </code> // 错误！</p></li><li><p>在讨论模板参数时，除了使用<code>class T</code>将<code>T</code>作为类型模板参数外，还可以使用非类型模板参数<code>template&lt;int N&gt;</code>，将<code>N</code>作为一个整型模板参数。这意味着<code>N</code>是一个整数类型，用于表示某些操作应重复执行的次数。</p></li><li><p>例如，实现了一个函数模板，可以将传入的参数重复打印<code>N</code>次。如果调用<code>print_n_times&lt;1&gt;(&quot;one&quot;)</code>，该函数会将字符串&quot;one&quot;打印<code>1</code>次。在模板中，传入的数字1、3、4将被用于确定重复打印的次数。</p></li><li><p>不过，使用整型模板参数有一个限制，即它只能接收整数类型的实参，无法接收浮点数或用户自定义类型，如<code>float</code>或一个自定义类<code>GLMVClass</code>。必须传入一个整数才可以。</p></li><li><blockquote><p>此外，有疑问为什么要将整数<code>N</code>作为模板参数而不是函数的普通参数。实际上，模板参数与函数参数在行为上存在差异，这些差异将在后续讨论。</p></blockquote></li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">show_times</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token generic-function"><span class="token function">show_times</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">show_times</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">show_times</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>模板参数：多个模板参数</mark></p></li><li><p>int N 和 class T 可以一起使用。你只需要指定其中一部分参数即可，会自动根据参数类型（T msg）、默认值（int N = 1），推断尖括号里没有指定的那些参数。</p></li><li><p>探讨了多模板参数及其默认值设置。在模板参数中，默认值的分配不必像函数参数那样仅限于最后几个参数。例如，可以将第一个模板参数设置为默认值<code>N=1</code>，而后续模板参数即使没有默认值也是可行的。</p></li><li><p>模板参数与函数参数的默认值存在不同之处。在模板参数的情况下，由于编译器可以从模板实例化的上下文中自动推断出一些模板参数的值，因此即便只提供部分模板参数，编译器仍能够正确处理。例如，若给定默认值<code>N=1</code>并且模板可以自动推断类型<code>T</code>，则即使调用时未指定<code>T</code>，也无须显式提供，编译器会自动推断。</p></li><li><p>如果调用模板时没有提供任何参数，并且模板参数设有默认值，编译器将使用这些默认值来实例化模板。(Syntax adjustments for a more formal and technical explanation):</p></li><li><p>当一个模板具有多个参数时，它们可以各自拥有默认值，并且不必遵从函数参数默认值设置中的“只有尾部参数可以设置默认值”的限制。编译器能够根据实例化模板时提供的参数推断出其他未指定的参数值。因此，若某个模板参数未被明确提供，编译器将采用其默认值进行推断。</p></li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">show_times</span><span class="token punctuation">(</span>T msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">show_times</span><span class="token punctuation">(</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">show_times</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">show_times</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token char">&#39;%&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>模板参数：参数部分特化</mark></p></li><li><p><code>func(T t) </code>完全让参数类型取决于调用者。</p></li><li><p><code>func(vector&lt;T&gt; t)</code> 这样则可以限定仅仅为 vector 类型的参数。这里用了 const &amp; 避免不必要的的拷贝。不过，这种部分特化也不支持隐式转换。</p></li><li><p>刚刚提到的是参数T在模板中的应用。其中一种应用场景是T作为另一个模板类的参数。这种情况下，编译器能够做到自动类型匹配，实现了部分特化的效果。例如，一个模板参数T代表一个包含任意类型元素的Vector，如<code>Vector&lt;T&gt;</code>。在这种情况下，<code>T</code>可以是任何类型，无论是<code>int</code>还是自定义类型，都能被接收并作为参数传递。</p></li><li><p>当然，这里需要记住提到的内容：如果T是拷贝代价较高的类型，使用<code>const T&amp;</code>可以避免不必要的拷贝操作。</p></li><li><p>在我们的实际应用中，存在一个功能——将<code>Vector</code>的所有元素求和。例如，如果<code>Vector</code>包含0到其大小(size)的所有整数，那么该功能就是将这些整数全部加起来并返回结果。根据我们给予的数值，可以看到这里的计算结果是10（4+3+2+1）。然后这是3.14+2.78，和约等于5.92。</p></li><li><p>然而，这个操作中可能出现问题的地方是括号的使用。因为直接在这个位置使用括号，可能会导致代码无法正常运行。</p></li></ul><details class="hint-container details"><summary>Click me to view the code!</summary><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">sum</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14f</span><span class="token punctuation">,</span> <span class="token number">2.718f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><br><ul><li><p><mark>为什么要支持整数作为模板参数：因为是编译期常量</mark></p></li><li><p>你可能会想，模板只需要支持 class T 不就行了？反正 int N 可以作为函数的参数传入，模板还不支持浮点。</p></li><li><p><code>template &lt;int N&gt; void func();</code>和<code>void func(int N);</code>一个是模板参数，一个是函数参数，有什么区别？有很大区别！</p></li><li><p>1- <code>template &lt;int N&gt; </code>传入的 N，是一个编译期常量，每个不同的 N，编译器都会单独生成一份代码，从而可以对他做单独的优化。</p></li><li><p>2-而 <code>func(int N)，</code>则变成运行期常量，编译器无法自动优化，只能运行时根据被调用参数 N 的不同。</p></li><li><p>3-比如 <code>show_times&lt;0&gt;()</code> 编译器就可以自动优化为一个空函数。因此模板元编程对高性能编程很重要。</p></li><li><p>4- 通常来说，模板的内部实现需要被暴露出来，除非使用特殊的手段，否则，<code>定义和实现</code>都必须放在头文件里。</p></li><li><p>5-但也正因如此，如果过度使用模板，会导致生成的二进制文件大小剧增，编译变得很慢等。boost 编译慢的原因找到了……因为他们用了大量的模板。</p></li><li><p>提及的问题是为何不将<code>int n</code>作为一个参数，而是采用模板传入的<code>n</code>。重要的一点在于：模板中传入的<code>n</code>是一个编译时常量，因此每个不同的<code>n</code>将导致生成单独的函数实例。这允许编译器进行优化，例如，当<code>n</code>为0时，编译器可以优化掉整个循环；当<code>n</code>等于1时，编译器知道循环次数为1，因此只保留一个循环迭代；对于<code>n</code>等于3，编译器可能将循环体复制三次；如果<code>n</code>较大，编译器可能不会采取这种展开（unroll）优化。</p></li><li><p>相对于模板参数，将<code>int n</code>作为运行时参数，编译器在编译时不知道<code>n</code>的具体值，只有在函数被调用时才会知道，这限制了编译器的优化潜力。</p></li><li><p>模板的缺点是可能导致大量的编译实例化，从而使得编译时间变长。此外，模板要求编译器在编译时需要看到其定义，不能仅有声明。例如，若<code>message</code>是自定义类型，则相应的<code>operator&lt;&lt;</code>需要在编译器能见度范围内，这导致模板函数通常定义在头文件中，而不支持声明和实现分离。因此，模板广泛应用可能会造成头文件变大，并导致编译过程变慢。</p></li><li><p>另外，模板函数即使不加<code>static</code>或<code>inline</code>，也能工作，但可能会导出符号。这些符号通常被标记为weak（弱符号），意味着如果多个文件定义了同一函数，链接器将只会选择一个。因此，保证函数定义一致性至关重要。</p></li><li><p>总之，如果想让模板函数内联，建议使用<code>static</code>修饰符。这种方式有助于控制符号的导出，避免潜在的链接冲突，并优化编译结果。</p></li></ul><br><ul><li><mark>模板的应用：编译期优化案例</mark></li><li></li></ul>`,16);function x(C,q){const p=c("router-link"),i=c("CodeTabs");return d(),r("div",null,[v,b,k(" more "),g,n("nav",w,[n("ul",null,[n("li",null,[o(p,{to:"#简单介绍主要是基础"},{default:a(()=>[s("简单介绍主要是基础")]),_:1})]),n("li",null,[o(p,{to:"#一、模板函数-template"},{default:a(()=>[s("一、模板函数（template）")]),_:1})])])]),f,n("details",h,[y,o(i,{id:"166",data:[{id:"std::string"},{id:"twice(“hello”)"}],"tab-id":"shell"},{title0:a(({value:t,isActive:e})=>[s("std::string")]),title1:a(({value:t,isActive:e})=>[s("twice(“hello”)")]),tab0:a(({value:t,isActive:e})=>[T]),tab1:a(({value:t,isActive:e})=>[_]),_:1},8,["data"])]),N])}const S=u(m,[["render",x],["__file","D-模板元编程与函数式编程.html.vue"]]);export{S as default};
