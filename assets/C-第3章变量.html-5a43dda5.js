import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c,d as p,a as l,e as h,w as s,b as e,f as o}from"./app-2a2d189a.js";const u={},d=l("h1",{id:"c-第3章变量",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#c-第3章变量","aria-hidden":"true"},"#"),e(" C-第3章变量")],-1),_=l("p",null,"C-第3章变量",-1),S=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),m={class:"table-of-contents"},b=o('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="c-第3章变量-1" tabindex="-1"><a class="header-anchor" href="#c-第3章变量-1" aria-hidden="true">#</a> C-第3章变量</h2><h2 id="一、shell-环境与变量" tabindex="-1"><a class="header-anchor" href="#一、shell-环境与变量" aria-hidden="true">#</a> 一、Shell 环境与变量</h2>',4),f=l("li",null,[l("p",null,"上节课使用 Shell 脚本写了一个简单的“Hello World”并输出，同时了解了执行脚本的三种不同方式。其中第三种比较特殊，即在脚本路径前直接加上“.”命令或“source”命令来执行。这种方式的特殊之处在于，前两种方式本质上都是打开一个子 Shell 去执行脚本，而这种方式不需要打开子 Shell ，直接在当前的 Shell 环境中执行脚本。")],-1),x={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},$=o("<li><p>看起来，开不开子 Shell 除了多一层嵌套，似乎没什么区别，实际上最大的区别在于环境变量的继承关系。比如在子 Shell 中设置的局部变量，在外部不可见；同样，在子 Shell 中定义的全局变量做了更改，回到外部 Shell 也相当于没变化。这主要涉及到 Linux Shell 编程中的环境变量概念，所以接下来第三章重点介绍什么是 Shell 编程中的变量。</p></li><li><p>简单来说，变量就是在当前 Shell 会话中临时想要保存的一些信息，本质上是在内存中临时保存的数据。比如开辟一块空间存一个数，当前是 20 ，将其命名为“a”，这就是一个变量，如果之后这个数变了，比如变成 21 ，“a”的值就变成 21 。所以变量可以认为是内存中存储的一块数据。对于 Linux 系统的 Bash Shell 也是如此，它具有使用变量来存储与当前 Shell 会话和工作环境相关信息的特性，因此变量也可称为环境变量（environment variable），这是基本定义。</p></li><li><p>在 Shell 中，变量整体可分为两大类：一类是系统直接定义好的所有变量，另一类是用户自定义的变量。从这个角度划分，一类是系统变量（system），另一类是用户可自定义和控制的变量，这是一种划分维度。</p></li><li><p>另外，Shell 中的环境变量还可分为全局环境变量和局部环境变量。这个名词一提出来，如果有编程基础，概念就很清晰。全局环境变量的可见范围很大，在 Linux 系统中，指对于当前的 Shell 会话（比如启动一个 Bash 进程，打开一个控制台终端对话框），如果在其中再启动 Bash 进程（即子进程，对应的是子 Shell ），如果设置的是全局变量，那么对于当前外部的 Bash 和内部的子 Shell 会话，层层嵌套的所有 Shell 会话都是可见的。与之对应，如果是局部变量，只针对当前的 Bash 环境有效，内部创建的子 Shell 不能访问外部 Shell 的局部变量。这可能与某些编程语言中的习惯不太一样，要先建立这个概念，即局部变量只对当前的 Bash Shell 有效，全局变量则子 Shell 也有效。</p></li><li><p><code>对于系统自定义的变量，大部分是全局变量，当然也有一些是局部变量，这两种划分方式有交叉环节。在启动系统开始 Bash 会话时，比如远程连接打开一个 Bash 控制台窗口，就设置了一些全局变量。系统的全局环境变量很多都很熟悉，之前可能也用过，比如“$HOME”是当前的主目录，“$PWD”是当前的工作目录，“$SHELL”是当前使用的 Shell 解析器，“$USER”是当前的用户，这些都是非常常用的系统环境变量。其特点是以“$”符开头，后面跟着大写字母的名称。如果想看具体的环境变量的值，很简单，使用“echo”时带上“$”符即可。可以看到当前的主目录在“/root”下。如果想查看当前所有的环境变量，有一个简单命令“env”，这里边显示非常多，如果想更清楚查看，可以“less”一下。可以看到上面有当前的 Shell 是“bash”，还有“SSH_CLIENT”（当前使用 SSH 进行远程登录的客户端）、当前的主题名、端口号，以及主机这边连接客户端的端口号和连接远程 SSH 服务开启的端口号等信息，后面还有“USER”等对应的信息、“HOME”、“LOGNAME”等都能看到，这就是全局的环境变量。除了这个命令，还有“printenv”，跟“env”基本一样，也可以直接打印出当前所有的系统全局变量，注意这里是全局变量。当然，如果想看单独的一个，比如“printenv $USER”，在“printenv”时不需要加上“$”符，想看哪个环境变量的名称直接写就行，这样一看当前用户就是“root”，名称该大写还是要大写，这是一些简单操作。</code></p></li><li><p><code>前面提到，如果“echo”时带上“$”符，就可以随时随地使用这个变量。“env”或“printenv”是打印当前环境变量信息的特殊命令，所以后面可以不加“$”符。一般情况下，把变量当值使用时都要加上“$”符。比如在当前工作目录“script”下，可以查看当前主目录的内容，能直接打印出来。对于提到的全局环境变量，也可以做一个校验，凭什么说它是全局的？全局的特点就是再打开一个子 Bash ，里边同样能获取到这些东西。比如进入子 Bash 后查看，是一样的，能看到，然后“exit”退出子 Bash 。</code></p></li><li><p>同样有全局环境变量，就有局部环境变量。如果是局部变量，只在当前定义的 Bash 中可见，打开子 Bash 就看不到。系统也定义了一些标准的局部变量，并非系统定义的变量都是全局的。如果想看到当前定义的所有变量，有一个命令“set”，这里能看到当前定义的所有变量，后面还有函数，如果内容太多，可以“less”。在“set”中能看到之前在“env”中看到的所有信息，包含所有全局变量，还有一些是“env”中没有的，那些就是局部变量。这里面不光有系统定义的全局变量和局部变量，后面会发现，即使用户自定义了变量，在“set”中也能看到，所有内容都能看到。这就是关于 Linux Shell 中环境变量的概念，以及系统预定义的全局变量和局部变量的概念。</p></li>",7),v=l("h2",{id:"二、shell-编程中的自定义变量",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#二、shell-编程中的自定义变量","aria-hidden":"true"},"#"),e(" 二、Shell 编程中的自定义变量")],-1),k=o("<li><p>已了解 Shell 编程中变量的基本概念，以及系统预定义变量中的全局环境变量和局部环境变量的查看方式。接下来探讨用户如何自定义变量。</p></li><li><p>自定义变量的方式极为简单。在一些静态类型的编程语言（如 C、Java ）中，定义变量时必须先指定类型，如定义整型“int a = 1”，或定义字符串“String s = &quot;a&quot;”。但对于当前的 Shell 脚本语言，其类型并非静态，类型系统较为简单，无需指定类型，直接给出变量名，加等号，随后紧跟变量值即可。需注意，等号前后不能有空格，这是 Shell 编程中定义变量的重要特点。</p></li><li><p>接下来在控制台尝试。先清除前面的内容，然后直接定义，比如“a = 2”，接着“echo”一下，能看到有变量“a”，其值为 2 。若想复杂些，比如先查看有无“my_var”（我的变量）这个变量，显然没有，但仍可“echo”，在某些编程语言中，若变量未声明直接使用会报错，而在此处，没有则为空。接着给“my_var”赋值，如“my_var = hello”，再“echo”“my_var”，就有了，其值为“hello”。根本无需关心变量类型，等号后赋值即可。赋值后还能更改，更改方式与初始定义相同，比如把“hello”改为大写的“H”，然后“echo”，毫无问题，可直接更改。</p></li><li><p>需注意，赋值时切勿在等号两边加空格，否则会提示未找到命令。因在 Shell 中，若如此书写，默认前面的是命令，在“/bin”或“/usr/bin”下找不到，自然报错。若连写，Shell 能将其解析为变量赋值表达式，从而得以正确解析。这便是变量声明和赋值的基本操作。</p></li><li><p>或许会想到，此过程是直接给变量赋一个字符串，若为一句话，比如要赋值为“hello world”，因中间有空格，直接敲会报错，找不到命令，此时需用引号引起来，再“echo”就能看到变成了“hello world”。用双引号或单引号均可，更改时也没问题。这便是使用自定义变量的过程，可声明、赋值和更改，整体使用非常简单。</p></li><li><p>但可能会想，定义的变量到底是全局变量还是局部变量？先思考，之前有“env”，“grep”“my_var”，找不到。还有“set”，其中能找到。当时说“set”包含当前所有系统预定义和用户定义的全局变量、局部变量等所有内容。但此变量看起来似为局部变量，仍需确认。因“env”中能看到的是系统定义的全局变量，用户定义的不在其中。接下来打开一个子 Shell “bash”确认。进入子 Shell 后，执行“ps -F”，基于子 Shell 创建新的进程，再“echo”当前的“my_var”，发现没有此变量，退出子 Shell 后，显然这是个局部变量。</p></li><li><p>有时可能希望在子 Shell 中也能获取此局部变量的值，即将其定义为全局变量。定义全局变量的方式稍有特殊，先声明一个局部变量并赋值，然后使用“export”将其提升为全局变量，有导出、输出之意，即将当前 Shell 中定义的局部变量导出为全局变量。“export”时直接加上变量名“my_var”，先将当前局部变量声明为全局变量。</p></li><li><p>先看外部的当前 Shell ，再敲“bash”进入子 Shell ，查看“ps -F”，父进程是外部初始登录的“bash”，现“ps -F”的父进程是此子 Shell ，继承关系清晰。在子 Shell 中“echo”“my_var”，能看到“hello world”，说明“my_var”已成为全局变量。</p></li><li><p>需多说明的是，既然已是全局变量，各处都应能访问，但在子 Shell 中更改其值，比如改为“hello Linux”，在子 Shell 中查看已更改，但退出子 Shell ，在外部查看，值仍是“hello world”，并未更改。即在外定义的全局变量，作用范围在当前 Shell 及嵌套的子 Shell 中都可见，但对其的更改只在当前更改的范围内有效，退出后则无效。当然，若在子 Shell 中有子 Shell ，在其中更改并声明为全局变量，在其中是生效的，但外部无用。</p></li><li><p>可能会想，在子 Shell 中更改后再做“export”声明为全局变量，外部是否能看到？尝试后发现还是不行。所以要注意，在子 Shell 中更改不会影响外部。若在外部的父 Shell 中声明“export”为全局变量，子 Shell 都能访问到。这便是 Linux 中父子 Shell 对于环境变量、局部变量和全局变量的相关影响。</p></li>",10),w={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},g=l("li",null,[l("p",null,[l("code",null,"现新增一个局部变量，比如叫“new”，先查看有无，没有则赋值“hello Linux”，做局部变量声明。然后在“hello.sh”中新增一行“echo $new”，想到若执行脚本会怎样？执行，用相对路径方式执行，前两行“hello world”正常输出，第一行是原本“echo”的字符串，第二行是全局变量，第三行是局部变量，所以无输出。若要输出“hello Linux”，一种方式是用“source”命令或“.”执行，另一种是在外部将“new”做“export”，注意“export”时只需给变量名，无需“$”，然后再用相对路径执行，就能输出，这便是对全局变量和局部变量的不同以及在父子 Shell 中使用不同方式执行脚本时对它们的具体影响的解释。")])],-1),L=o('<h2 id="三、用户自定义变量的相关特性" tabindex="-1"><a class="header-anchor" href="#三、用户自定义变量的相关特性" aria-hidden="true">#</a> 三、用户自定义变量的相关特性</h2><ul><li><p>对于用户自定义的变量，一般情况下，变量名称可以是小写，因为大写通常是系统预定义的，所以自定义时用小写即可。</p></li><li><p>另外需要注意一些特点。前面定义的变量通常可以随意更改其值，那这里边变量值的默认类型是什么呢？前面定义了一个“a”，其值为 2 ，假如把“a”的值变为“1 + 5”，然后“echo”一下“a”，会发现其值直接就是“1 + 5”，并非 6 。所以要注意，这里声明定义时，当前的值并非数值，相当于没有对应的类型定义，或者认为默认的定义全部都是字符串，都是按字符串类型处理，无法直接做数值计算。</p></li><li><p>可能会想到，如果真要做数值计算怎么办？可以先提一下，如果要做数值计算，需要用到 Shell 里的运算符表达式。比如加一个“$”符，再加两层括号“(( ))”，然后进行计算，再“echo”“a”就变成 6 了。或者也可以用一重中括号“[ ]”，比如“[ 5 + 9 ]”，这部分会在后面讲到运算符时再详细说明，目前了解即可。</p></li><li><p>还有一点，就是可以定义只读变量。通常变量之所以叫变量，是因为其内容可改，能不断赋值。而只读变量只能读不能写，不能更改，相当于常量。定义时使用“readonly”命令，比如定义“b = 5”，然后再给“b”赋值，比如“b = 10”，就会直接报错，提示“b”是只读变量。“echo”一下“b”的值，显然还是初始值，不能改。</p></li><li><p>另外一个小要点，在当前 Shell 环境中可以设置变量，每个变量都会在计算机内存中开辟一块空间存放。比如有“a”“b”，还有前面定义的“my_value”“new_value”等，所有这些都保存在内存中。如果定义的变量越来越多，可能会占满内存，有些定义后测试完不用了，想撤销是可以的。前面提到过“set”命令，“set”并非用于设置，而是能看到已设置好的所有变量。直接“set”，然后“less”一下，前面是系统定义的一些变量，直接“Shift + G”到最后，最后的是一些函数，再回退，回到开头往后翻页，可以看到“a = 14”“b = 5”“my_word”“new_word”等定义都能看到。当然，内容较多，如果不想“less”查找，也可以“grep”筛选。</p></li><li><p>接下来要撤销变量，非常简单，“unset”后面跟上要撤销的变量名称，比如撤销“a”，这样就撤销掉了。后面如果再“grep”“a”，可能不太容易找到，因为包含“a”字母的内容太多。还是回到当时找到的位置查看，现在就只有“b”没有“a”了。</p></li><li><p>需要注意的是，前面有个“b”是只读变量，能“unset”吗？不能，因为“b”相当于常量，直接“unset”会报错。</p></li><li><p>总结一下，变量名称可以由字母、数字、下划线组成，不能以数字开头。如果是系统的环境变量，建议大写，即使是自定义的全局环境变量，也可用大写，这比较通用。注意等号两侧不能有空格，在 Shell 中默认类型都是字符串类型，无法直接进行数值运算，如果设置的变量值中有空格，需要用双引号或单引号引起来。声明静态变量或只读变量时使用“readonly”定义，撤销变量使用“unset”，但不能“unset”只读变量。另外，将局部变量提升为全局变量，可使用“export”导出。这就是关于用户自定义变量的所有内容。</p></li></ul><h2 id="四、shell-脚本的执行与参数处理" tabindex="-1"><a class="header-anchor" href="#四、shell-脚本的执行与参数处理" aria-hidden="true">#</a> 四、Shell 脚本的执行与参数处理</h2>',3),y=l("li",null,[l("p",null,"已了解 Linux Shell 中自定义变量的用法，包括局部变量和全局变量的定义与使用。同时，也清楚了脚本的编写与三种不同的执行方法，以及它们之间的区别，并做了诸多测试。")],-1),B=l("li",null,[l("p",null,"在测试过程中会发现，使用“bash”执行、“source”命令或“.”命令执行，看起来都是将当前脚本文件作为参数传递给了 Linux Shell 中的一个指令来执行。而直接使用相对路径或绝对路径执行脚本，这两种方式本质上完全不同。")],-1),E={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},C={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},H={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},M=l("li",null,[l("p",null,"思考是否有更好的方法，既能不改变“bin”目录，又能将脚本像命令一样直接执行。想到之前执行的命令可在“bin”目录或“sbin”目录，也可能在其他可配置的路径，比如“/usr/local/bin”，而系统命令的查找路径可通过系统环境变量“PATH”配置。默认的“PATH”包含“/usr/local/sbin”、“/usr/local/bin”、“/usr/sbin”、“/usr/bin”、“/root/bin”等路径。比如直接执行“ls”命令，若在“bin”目录下，实际是存放在“/usr/bin”目录下。所以可将脚本放到“/root/bin”目录下直接执行，或者将“script”目录的绝对路径添加到“PATH”环境变量后面，用冒号分隔，之后也能直接执行。这便是关于环境变量的更改和直接执行命令的方式。")],-1),N=l("li",null,[l("p",null,"由此发现，对于脚本，本质上与系统命令差别不大。执行命令时，有时不跟参数，有时后跟参数。对于脚本，也不希望每次执行结果都相同，比如“hello”，可能要向不同的人打招呼，人名作为参数传给脚本。那么如何获取传入的参数，这就涉及到 Linux Shell 中另一大类特殊变量，主要用于处理脚本的输入参数并进行捕获和处理。")],-1),T=l("li",null,[l("p",null,[e("首先介绍“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n"),l("mtext",null,"”，这里的“"),l("mi",null,"n"),l("mtext",null,"”并非实际使用时直接写“")]),l("annotation",{encoding:"application/x-tex"},"n”，这里的“n”并非实际使用时直接写“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"，这里的"),l("span",{class:"mord"},"“"),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"并非实际使用时直接写"),l("span",{class:"mord"},"“")])])]),e("n”，而是要替换成 1 - 9 的数字。“$1”指的是当前脚本输入的第一个参数，“$2”则是第二个参数，若超过 9 个参数，用花括号括起来，防止与“$1”这类变量混淆。")])],-1),A={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},V=l("li",null,[l("p",null,[l("code",null,"为更清晰测试特殊变量的用法，新建一个名为“parameter.sh”的脚本。开头为“#! /bin/bash”，然后“echo”，先输出一个分割线，表明测试的是未知参数“$n”。注意，若用双引号，会被认为是变量，因当前无“n”变量，所以为空。为避免此情况，使用单引号，单引号内不会将“$”视为变量标识符，而是原样输出。")])],-1),O={href:"http://parameter.sh",target:"_blank",rel:"noopener noreferrer"},P=l("li",null,[l("p",null,"有同学可能觉得用绝对路径执行脚本，输出的名称太长太麻烦，只想获取脚本本身的名称，可使用“basename”命令，它能获取文件本身的名称，去掉路径。此命令可作为命令或系统提供的函数，在后面讲到函数部分时再统一介绍。这便是未知参数的用法。")],-1),j=l("li",null,[l("p",null,"除未知参数外，还有一些特殊变量。比如“$#”，指获取当前输入参数的个数，常用于循环或先做判断参数是否符合要求。比如脚本要求必须输入两个参数，若参数个数不对则报错。还可将其用于循环，以参数总数作为循环次数标准，获取每个参数进行处理。在当前脚本中测试，新增一行，“echo”“当前 parameter 的个数 numbers: $#”，保存后执行，不跟参数时个数为 0，输入“abc def”两个参数时个数为 2 ，直接显示当前参数的个数。")],-1),F=l("li",null,[l("p",null,[l("code",null,"除“$#”外，还有两个特殊变量“$*”和“$@”，功能类似，都是获取当前命令行提供的所有参数。区别在于“$*”把所有参数看成一个整体，输入“abc df”两个参数时，获取到的相当于“abc df”；“$@”获取到的相当于一个数组，即“abc”和“df”。在具体使用中有所不同，“$*”往往直接查看所有拿到的参数，“$@”可使用循环遍历每个参数。当前未讲到循环，所以目前看到的是所有参数的整体。在“parameter”脚本中打印输出“$*”和“$@”，保存执行，若不做循环遍历，会发现二者无区别。")])],-1),I=l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"?"),l("mtext",null,"”，它与前面的特殊变量完全不同，前面的特殊变量与脚本的输入参数有关，而“")]),l("annotation",{encoding:"application/x-tex"},"?”，它与前面的特殊变量完全不同，前面的特殊变量与脚本的输入参数有关，而“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mclose"},"?"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"，它与前面的特殊变量完全不同，前面的特殊变量与脚本的输入参数有关，而"),l("span",{class:"mord"},"“")])])],-1),R={href:"http://parameter.sh",target:"_blank",rel:"noopener noreferrer"};function U(q,D){const n=t("router-link"),a=t("ExternalLinkIcon");return i(),c("div",null,[d,_,p(" more "),S,l("nav",m,[l("ul",null,[l("li",null,[h(n,{to:"#概述框架"},{default:s(()=>[e("概述框架")]),_:1})]),l("li",null,[h(n,{to:"#c-第3章变量-1"},{default:s(()=>[e("C-第3章变量")]),_:1})]),l("li",null,[h(n,{to:"#一、shell-环境与变量"},{default:s(()=>[e("一、Shell 环境与变量")]),_:1})]),l("li",null,[h(n,{to:"#二、shell-编程中的自定义变量"},{default:s(()=>[e("二、Shell 编程中的自定义变量")]),_:1})]),l("li",null,[h(n,{to:"#三、用户自定义变量的相关特性"},{default:s(()=>[e("三、用户自定义变量的相关特性")]),_:1})]),l("li",null,[h(n,{to:"#四、shell-脚本的执行与参数处理"},{default:s(()=>[e("四、Shell 脚本的执行与参数处理")]),_:1})])])]),b,l("ul",null,[f,l("li",null,[l("p",null,[e("关于子 Shell 的内容，可以做一个简单测试。比如在当前 Shell 环境中，直接“ps -ef | grep 控制终端相关”，可能内容较多，直接“ps -ef | grep 当前用户和当前控制台相关”，会看到有一个“bash -bash”，这是登录进来后启动的 Bash Shell 进程。接下来，如果直接打开另一个“bash”（之前说过，如果“bash”后面加上脚本名称是执行，如果什么都不加，直接敲“bash”），再查看“ps -ef”，会发现多了一个“bash”进程，这个“bash”进程就是前面“bash 5283”的子进程，即子 Shell 环境。接下来进行的所有操作，比如执行“"),l("a",x,[e("hello.sh"),h(a)]),e("”脚本，都是在当前 Shell 中执行。如果在当前 Shell 中执行完后，直接“exit”退出，若在外部退出，就会断开远程连接，但仍是“root”登录状态。这是因为之前是在子 Shell 中，是嵌套的，之前“ps -ef”是在子 Shell 中执行的。“exit”退出后，外部还有一层。这体现了 Shell 的特点，即可以层层嵌套，都是一层壳。退出后再查看“ps -ef”，就没有子 Shell 了。可以理解为，如果使用“source”或“.”命令，就是不在子 Shell 中执行，直接在当前 Shell 中执行；如果使用前两种方案执行，就是打开子 Shell 执行，这是最大的不同。")])]),$]),v,l("ul",null,[k,l("li",null,[l("p",null,[e("前面的内容较简单，在当前 Shell 中用“bash”命令打开子 Shell ，通过“ps”命令查看父子继承关系，确定所在 Shell ，较为混乱。若要测试更清晰，应使用脚本。前面说了许多，关键是解释脚本中对全局变量和局部变量的引用和使用是否有效。接下来进入之前的“"),l("a",w,[e("hello.sh"),h(a)]),e("”脚本。之前直接“echo”了“hello world”，接下来“echo $my_var”，保存。然后以不同方式调用，首先用“source”方式，肯定没问题，两个“hello world”都能输出。若用相对路径或绝对路径方式执行，能否看到？没问题，因“my_var”已是全局变量，所以执行脚本时打开的子 Shell 也能访问到，所以能输出对应结果。")])]),g]),L,l("ul",null,[y,B,l("li",null,[l("p",null,[e("切换到“script”目录下，直接敲“"),l("a",E,[e("hello.sh"),h(a)]),e("”运行，会提示未找到命令，因为系统中原本没有这个命令。若将“"),l("a",C,[e("hello.sh"),h(a)]),e("”复制到“bin”目录下，就可以直接执行，后面显示的两个空行是因为之前“echo”的两个局部变量已被“unset”撤销。")])]),l("li",null,[l("p",null,[e("这种方式虽可行，但“bin”目录通常存放系统生成的命令，一般不建议直接更改。所以还是删除“"),l("a",H,[e("hello.sh"),h(a)]),e("”，若想运行，只能带上路径，或使用“source”、“.”命令，或“bash”命令执行。")])]),M,N,T,l("li",null,[l("p",null,[e("通过控制台进行测试，更改“"),l("a",A,[e("hello.sh"),h(a)]),e("”，删除之前“unset”的两行变量，然后“echo”“hello$1”。此“$1”是当前的位置参数变量，调用脚本时可在后面跟上参数，输入“helloSH”回车无内容，输入“hello 小明”则输出“hello 小明”，输入“hello 小亮”则输出“hello 小亮”，这便是脚本参数的用法。")])]),V,l("li",null,[l("p",null,[e("接着“echo”，先输出“$0”，并添加描述“script name”，然后是第一个输入参数“parameter $1”，接着是第二个参数“parameter $2”。保存退出后，为脚本添加“x”执行权限，执行脚本并加上参数，如第一个参数“abc”，第二个参数“def”，可看到脚本名称“"),l("a",O,[e("parameter.sh"),h(a)]),e("”（若用绝对路径执行，会输出完整路径），以及第一个参数“abc”和第二个参数“def”。")])]),P,j,F,l("li",null,[l("p",null,[e("最后介绍“"),I,e("?”表示整个脚本的返回值，即最后一次执行命令的返回状态。常见情况为 0 表示脚本正常执行结束，若不正确则为其他数值，一般报错为 1 。比如之前执行过一次脚本，“echo $?”会看到返回值为 0 ，若运行“"),l("a",R,[e("parameter.sh"),h(a)]),e("”未找到命令，返回值为 127 ，表示没有对应的命令，这是一种不正常返回报错的形式。这便是关于 Linux Shell 中特殊变量的简单介绍。")])])])])}const J=r(u,[["render",U],["__file","C-第3章变量.html.vue"]]);export{J as default};
