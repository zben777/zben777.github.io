import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as r,c as i,d as h,a,e as l,w as o,b as s,f as m}from"./app-2a2d189a.js";const d={},p=a("h1",{id:"d-第4章运算符",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#d-第4章运算符","aria-hidden":"true"},"#"),s(" D-第4章运算符")],-1),u=a("p",null,"D-第4章运算符",-1),_=a("div",{class:"hint-container info"},[a("p",{class:"hint-container-title"},"说明"),a("p",null,"主要是各种搜索找的学习；")],-1),x={class:"table-of-contents"},k=m('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="d-第4章运算符-1" tabindex="-1"><a class="header-anchor" href="#d-第4章运算符-1" aria-hidden="true">#</a> D-第4章运算符</h2>',3),f=a("li",null,[a("p",null,"接下来要介绍的是 Linux Shell 中的运算符。已知将 Shell 当作一门编程语言来学习，作为编程语言，定义变量后必然要进行变量之间的计算，所以需清楚如何进行计算，这就涉及到运算符的使用。")],-1),w=a("li",null,[a("p",null,"前面发现，在 Linux Shell 中，比如定义一个变量“a”，若定义时直接赋值为“1+2”，且中间不能有任何空格，一旦有空格就会表示未找到命令，因为空格表示命令和后面参数之间的间隔。若不空格直接设置值为“1+2”，当前“a”的值并非计算得出的 3，而是“1+2”。所以，直接写“1+2”无法直接计算。由此可见，Shell 相较于其他编程语言，确实麻烦许多。其他编程语言若有解释器，特别是动态、解释型语言，直接输入这样的表达式就能计算出结果。由此可看出，Shell 较为底层，并非作为高级语言设计。")],-1),b=a("li",null,[a("p",null,"若想将两个数相加，如在 Shell 中，有专门用于计算各种数值表达式的命令，即“EXPR”，这是“expression（表达式）”的前四个字母。有了“EXPR”后，若直接输入“1+2”，会发现仍不行，还是被当作字符串。解决办法是在加号两边空一格，本质上是将“1”、“+”和“2”作为“EXPR”命令的三个参数传入。前面讲过参数，此时就能明白怎么回事。回车后，能得到 3，这才真正计算出对应结果。")],-1),g=a("li",null,[a("p",null,"当然，有加就有减，若输入“5 - 2”，没问题，能得到 3。但若输入“5 * 2”，会报语法错误。因为在 Linux 命令中，星号有特殊含义，常用于表示通配符，如在脚本中用“$*”表示当前所有参数。直接用其作乘号，定义冲突，所以报错。此时需做转义，写成“5 * 2”，就能得到 10。会发现这种方式太过麻烦，简单的加减乘除运算都如此繁琐。")],-1),E=a("li",null,[a("p",null,[s("为解决此问题，在 Linux Shell 中针对运算专门设计了更简化的运算符，即加上“"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mtext",null,"”，然后用中括号或双小括号将运算式括起来，就能直接进行计算。接下来，若按这种表示，可写成“")]),a("annotation",{encoding:"application/x-tex"},"”，然后用中括号或双小括号将运算式括起来，就能直接进行计算。接下来，若按这种表示，可写成“")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord"},"”"),a("span",{class:"mord cjk_fallback"},"，然后用中括号或双小括号将运算式括起来，就能直接进行计算。接下来，若按这种表示，可写成"),a("span",{class:"mord"},"“")])])]),s("[5 * 2]”，直接“echo”能得到 10。当然，中间的空格可有可无，只要放在“"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mo",{stretchy:"false"},"["),a("mo",{stretchy:"false"},"]"),a("mtext",null,"”或“")]),a("annotation",{encoding:"application/x-tex"},"[]”或“")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mopen"},"["),a("span",{class:"mclose"},"]"),a("span",{class:"mord"},"”"),a("span",{class:"mord cjk_fallback"},"或"),a("span",{class:"mord"},"“")])])]),s("(( ))”里，就能对计算表达式得出对应值。")])],-1),L=a("li",null,[a("p",null,[a("code",null,"平时并非直接“echo”，而是想将值赋给“a”。若要赋给“a”，直接“a = ”，后面加上这种写法即可。比如“6 + 8”，然后“echo $a”，其值变为 14。这种写法比“EXPR”简单。若之前用了“EXPR”方式，想再赋值给“a”，需注意，不能直接将其粘贴，中间有空格会被当作执行命令，加上引号会被当作字符串。要将其当作真正执行的命令并将值赋给“a”，需用到 Linux Shell 中的一种特殊用法——命令替换，即将执行的命令替换为其值再进行赋值给“a”。做法是“a = $(EXPR 5 * 2)”，再“echo $a”，就能看到值变为 10。或者不用“$”符，用反引号“"),s("”，"),a("code",null,"这样写也是对的，即“$a”。这两种方法都叫命令替换，即将命令执行结果替换后再操作和赋值。但这种用法确实麻烦，一般不用“EXPR”方式，最推荐的是“$[]”，虽比其他编程语言仍麻烦，但起码简单些，多数编程语言直接进行加减乘除计算即可，这是 Shell 不太方便之处，也是其特点，更显底层。")])],-1),M=a("li",null,[a("p",null,[s("此处有个具体案例，比如要计算“2 + 3”的和再乘以 4 的值，并将其赋给一个变量，比如“s”。或者直接定义“s”，最简单的方式是“$[(2 + 3) * 4]”，“echo "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"s"),a("mtext",null,"”，能看到值为"),a("mn",null,"20"),a("mtext",null,"，整体较简单，关键是加上“")]),a("annotation",{encoding:"application/x-tex"},"s”，能看到值为 20，整体较简单，关键是加上“")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"s"),a("span",{class:"mord"},"”"),a("span",{class:"mord cjk_fallback"},"，能看到值为"),a("span",{class:"mord"},"20"),a("span",{class:"mord cjk_fallback"},"，整体较简单，关键是加上"),a("span",{class:"mord"},"“")])])]),s("[]”。")])],-1),S={href:"http://add.sh",target:"_blank",rel:"noopener noreferrer"},$={href:"http://add.sh",target:"_blank",rel:"noopener noreferrer"},v=a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"2"),a("mo",{stretchy:"false"},"]"),a("mtext",null,"”，后面直接“"),a("mo",null,"=")]),a("annotation",{encoding:"application/x-tex"},"2]”，后面直接“=")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"2"),a("span",{class:"mclose"},"]"),a("span",{class:"mord"},"”"),a("span",{class:"mord cjk_fallback"},"，后面直接"),a("span",{class:"mord"},"“"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"=")])])],-1),y=a("li",null,[a("p",null,"由此可见，这样的脚本执行过程类似命令，也像编程语言中的函数，后面输入的两个参数如同函数的形参。本质上，都可理解为一组操作的提取和集合。在其他编程语言中定义函数或方法，也是一系列操作的集合，这里的操作同理。这就是关于 Linux Shell 中运算符的用法。")],-1);function D(P,R){const n=e("router-link"),t=e("ExternalLinkIcon");return r(),i("div",null,[p,u,h(" more "),_,a("nav",x,[a("ul",null,[a("li",null,[l(n,{to:"#概述框架"},{default:o(()=>[s("概述框架")]),_:1})]),a("li",null,[l(n,{to:"#d-第4章运算符-1"},{default:o(()=>[s("D-第4章运算符")]),_:1})])])]),k,a("ul",null,[f,w,b,g,E,L,M,a("li",null,[a("p",null,[s("同样，这在命令行做了测试，也可在脚本中尝试。比如定义一个做加法的脚本，叫“"),a("a",S,[s("add.sh"),l(t)]),s("”，执行时后面跟上第一个加数和第二个加数，返回两数之和。来看实现方式，进入“script”目录，“vi "),a("a",$,[s("add.sh"),l(t)]),s("”，首先写上“#!/bin/bash”，然后很简单，直接“echo”对应的结果，或者先定义一个叫“sum”的两数和变量，其值为“$[$1 + "),v,s("sum”，注意前面的“sum”是要输出的字符，后面的“$sum”是计算出来的结果变量。保存退出，修改执行权限，执行脚本，比如输入“25”和“89”，能看到和为 114，实现了两数相加的操作。")])]),y])])}const B=c(d,[["render",D],["__file","D-第4章运算符.html.vue"]]);export{B as default};
