import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as h,o as u,c as o,d as c,a as l,e as a,w as n,b as e,f as s}from"./app-2a2d189a.js";const r={},p=l("h1",{id:"f-第6章流程控制",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#f-第6章流程控制","aria-hidden":"true"},"#"),e(" F-第6章流程控制")],-1),f=l("p",null,"F-第6章流程控制",-1),d=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),m={class:"table-of-contents"},x=s('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="f-第6章流程控制-1" tabindex="-1"><a class="header-anchor" href="#f-第6章流程控制-1" aria-hidden="true">#</a> F-第6章流程控制</h2><h2 id="一、linux-shell-中的流程控制" tabindex="-1"><a class="header-anchor" href="#一、linux-shell-中的流程控制" aria-hidden="true">#</a> 一、Linux Shell 中的流程控制</h2>',4),_=l("ul",null,[l("li",null,[l("p",null,"上一节介绍了 Linux Shell 中的条件判断。会发现进行条件判断并非目的，目的是根据某一条件判断接下来的操作。接下来要介绍的是 Linux Shell 中的流程控制，这是编写程序的重点，掌握这部分流程控制，就能搭建起程序架构。")]),l("li",null,[l("p",null,"回忆编写程序时，代码的程序流程执行方式。程序结构主要有三大流程：一种是顺序，这无需设计，几乎所有编程语言默认都是从上到下按顺序依次执行。正常情况下，写一行语句再写下一句，按顺序写下操作步骤即可。像 Shell 这样的脚本语言更是如此，写一句解释一句执行一句，所以此情况不再赘述。")]),l("li",null,[l("p",null,"除顺序外，常用的还有分支和循环。首先看分支语句，简单来说可分为两大类：一种是先做条件判断，然后根据判断结果分成两岔，像树分两个树枝；另一种是不局限于两种情况，可分为 3 种、4 种、5 种等更多情况。接下来介绍分支流程判断的控制方式。")]),l("li",null,[l("p",null,"分支流程的核心是要有条件判断，这里用到了前面第五章介绍的条件判断语法规则。进行分支流程控制最简单的就是“if...else”，首先来讲其应用。")]),l("li",null,[l("p",null,"与大多数编程语言类似，很多编程语言都支持“if...else”。其语法规则为：“if”后跟上一个条件判断表达式（注意这里是前面讲过的中括号，相当于返回布尔类型判断值的表达式），若“if”后面的表达式为真（返回值为“true”），后面加分号，然后是“then”（注意必须写“then”，表示接下来要执行的操作），接着是要执行的操作代码，分支结束时加上“fi”。")]),l("li",null,[l("p",null,"会发现其较特殊，一般编程语言中，“if”后是用花括号括起条件分支语句的代码块，表示开始和结束，但在 Linux Shell 中，括号有单独用途，不能这样用，所以只好用更直观的语言表示，即后面加“fi”，相当于一个正向括号和一个反向括号括起中间内容。语法虽有些怪异，但可以理解。")]),l("li",null,[l("p",null,"这里注意，出现的分号表示在一行里可分开两步命令。在 Linux Shell 中，可在 Bash 控制台一行敲两个命令，有同学可能认为这是管道操作，其实不是。管道操作是前一部分结果通过管道传递给后面命令，而这里的操作完全不相干，用分号分开即可。比如，先“cd”到“/home/atguigu”目录，加分号，后面“ls -l”，执行会看到是“/home/atguigu”下的内容，且目录已切换。这相当于一行命令中有两个用分号分隔的操作，会先后执行，先“cd”再“ls -l”。所以这里的分号用法与上述类似，也可去掉分号，将“then”写在下一行，二者完全等价。")]),l("li",null,[l("p",null,"这是“if”判断，即单分支。单分支是指在某种条件下要做某个操作，另一种情况，比如判断为“yes”时走下面，若为“no”则跳过中间直接走下面，这就是单分支，可能会跳过中间步骤。")]),l("li",null,[l("p",null,"在控制台做简单测试，退回到根目录，工作目录关系不大，在一行用逗号分隔做测试。比如，“if”后跟条件判断，设一个变量“a”，比如为 25 ，假设是年龄，判断年龄是否符合要求。若“a”变量“gt”（greater than，大于）18 岁，比如大于 18 岁才能工作，否则是童工。若大于 18 岁，“then”后直接“echo”一个“OK”，后面加分号再写“fi”，会直接输出“OK”。若将值改为 15 岁，再判断，就不“OK”。这部分也可放在脚本里做逻辑输出。")]),l("li",null,[l("p",null,"回到“script”目录新建“if_test.sh”脚本，先写“#!/bin/bash”，然后做“if”判断。把需要的变量从外部输入，比如输入一个用户名，判断是否为“atguigu”。在脚本里，无需在一行用分号分隔，直接换行写。若满足条件，直接“echo”比如“welcome atguigu”，最后“fi”结束。这种写法简单，但实际项目应用中，可能会看到另一种写法。做字符串比较时，传入的可能为空，会报错。比如先退出看，给脚本打开执行权限，加“x”然后执行，会提示期待一元表达式。因为若什么都不给，就为空，直接在中括号里等于“atguigu”判断有问题。所以实际代码中往往做个小调整优化，把后面跟一个“x”，相当于字符串拼接，后面“atguigu”也跟一个“x”，这样在外部判断就不会报错。若输入“小明”，就不会输出欢迎信息，输入“atguigu”则会显示“welcome atguigu”。这是使用“if”做单分支条件判断处理的简单示例。")]),l("li",null,[l("p",null,"这里的条件可能只是简单的判断是否等于、是否大于，若有多个条件做组合判断也是可以的。前面介绍过多条件组合判断，用逻辑与（“&&”）或逻辑或（“||”）即可。前面提到相当于有些编程语言里的短路操作，因为“与”的关系，必须全部为真表达式才为真，所以若后面不跟条件直接跟操作，表示前面为真就执行后面操作，为假就短路不执行。若“或”，前面为假才执行后面判断，前面为真已有结果就不判断。这是短路与、短路或的原理，利用此可做类似三元运算符表达式的输出结果。")]),l("li",null,[l("p",null,[e("一般应用中，往往用“&&”连接两个中括号里的不同条件做逻辑与、逻辑或。比如“if”后加“&&”，后面再一个条件判断，比如前面是“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"a"),l("mo",null,">"),l("mn",null,"18"),l("mtext",null,"”，找工作可能还有年龄限制，比如“")]),l("annotation",{encoding:"application/x-tex"},"a > 18”，找工作可能还有年龄限制，比如“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),l("span",{class:"mord mathnormal"},"a"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},">"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord"},"18”"),l("span",{class:"mord cjk_fallback"},"，找工作可能还有年龄限制，比如"),l("span",{class:"mord"},"“")])])]),e("a < 35”，这是双重条件，后面“then”“echo okay”“fi”。若“a”先为 15 ，不满足；若为 25 ，满足；若为 36 ，不满足。很容易用逻辑与、逻辑或做各种条件组合放在“if”里做相应操作。")])]),l("li",null,[l("p",null,"关于逻辑与、逻辑或，看到的是连接两个中括号括起的条件表达式。若做短路与，后面可加具体操作直接“echo”。有时可能会想把“&&”直接放到同一个中括号里，“if”后一个括号一个判断，行不行？可以，但不能直接去掉中括号把两个表达式用“&&”连接，会报错。放在中括号里，要用特定逻辑表示。若表示逻辑与关系，用“-a”（因为逻辑与是“and”），若逻辑或用“-o”。现在给“-a”，回车，发现不报错。因为“a”为 36 ，所以不“echo OK”，若“a”为 20 ，则“echo OK”。这就是“if”做单条件判断、单分支判断时，条件可做各种组合。这就是单分支的具体使用，也就了解了“if”基本的使用规则。")])],-1),$=s('<h2 id="二、linux-shell-中的分支流程" tabindex="-1"><a class="header-anchor" href="#二、linux-shell-中的分支流程" aria-hidden="true">#</a> 二、Linux Shell 中的分支流程</h2><ul><li><p>前面介绍了流程控制里“if”单分支的处理逻辑。单分支的特点是只判断条件是否为真，若为真执行这段逻辑，为假则跳过。</p></li><li><p>在一般的流程控制中，可能不是跳过一段逻辑，而是判断条件是否为真，若为真或为假都有对应的处理逻辑，这就是标准的双分支，最后处理完会汇总到主流控制逻辑中。接下来要判断的是，除了“if”，剩下部分用什么语句处理，这就是“if else”。很多编程语言都有这样的语法，即“if...then...else...”，表示满足条件走左边，不满足走右边，是二元分割，是或否。</p></li><li><p>对于 Linux Shell ，同样有“if else”的用法。接下来在控制台做简单测试，不过这部分测试代码内容可能较多，不在控制台一行测试，进入脚本里看。</p></li><li><p>同样，之前输入了一个用户名，现在让脚本再多输入一个年龄。添加一行注释，在脚本里可直接打“#”做注释，这里换行主要是为方便展示，并非必须换行。输入第二个参数表示年龄，判断属于哪个年龄段，这是具体需求。</p></li><li><p>因为是第二个参数，所以是“$2”。首先判断是否小于 18 岁，若小于，“then”后“echo 它是一个未成年人”；若大于等于 18 岁，即“else”，直接“echo 这就是成年人”。“fi”结束。保存退出后执行，“if_test” 后加上用户名和年龄，比如 15 岁，输出“welcome atguigu 是一个未成年人”；若给 25 岁，输出“welcome 成年人”。无论条件判断真假，都有对应分支输出信息，这是典型的双分支“if else”，非常简单。若有其他编程语言基础，应该一看就懂。</p></li><li><p>除双分支外，“if else”还可处理多分支情况。双分支是判断条件真假，真走一边，假走另一边，而假的部分可能还会再分支。所以把语法结合起来，判断一个条件后可有 3 个、4 个、5 个甚至更多分支处理。</p></li><li><p>具体语法是“if”，若为真走这边；若为假“else”走这边，“else”后再一个“if”判断，又有一个条件进行下一步分支，相当于第二次分叉。多分支流程就是“if else if else if...”，最后兜底是“else”。</p></li><li><p>很多编程语言有“if else if”的写法，在 Linux Shell 里不是“if else if”，而是简写成“elif”。“elif”后也要跟中括号和条件判断表达式。因为是“if”，接下来执行要有“then”，跟当前分支，最后兜底“else”，下面写处理逻辑，以“fi”反写的“if”收尾。</p></li><li><p>接下来看这样的多分支在代码里如何实现，在之前部分做更改。上面是小于 18 岁为未成年，“else”即大于等于 18 岁都是成年人，接下来把成年人分支再细分。“elif”后跟判断条件，判断小于 35 岁，“then”“echo 当前就是真正的好劳动力啊青年人”。还可继续“elif”，继续判断，所有大于等于 35 岁的，再判断小于 60 岁，“then”认为是中年人，最后“else”，剩下大于等于 60 岁的是老年人，这是完整逻辑判断。</p></li><li><p>会发现当前的“if else”多分支，本质上有点像倾斜的二叉树，熟悉数据结构就会知道，这像带点倾斜的二叉树结构，每次分支都是二分叉，即树的左右子树都有两个分支。</p></li><li><p>做完上述更改，保存退出做测试，后面跟上“atguigu”，先给 15 岁，没问题，是未成年人；25 岁是青年人；36 岁是中年人；67 岁是老年人，不同分支有对应输出，这就是用“if else”进行多分支处理。</p></li></ul><h2 id="三、linux-shell-中的-case-语句" tabindex="-1"><a class="header-anchor" href="#三、linux-shell-中的-case-语句" aria-hidden="true">#</a> 三、Linux Shell 中的 case 语句</h2><ul><li><p>前面介绍了“if else”的流程控制，会发现“if else”本质上是双分支逻辑结构，每次都是分两岔，其多分支控制是将两岔无限嵌套，从而有了“elif”，通过不断分支实现多分支。</p></li><li><p>可能会想，何必如此麻烦，每次都用二叉树实现，能否直接进行判断，平铺出多个分支，形成一个多岔树结构。答案是可以的。熟悉 C 或 Java 语法就会知道，还有“case”语句可进行类似判断。</p></li><li><p>在 Linux Shell 中，“case”语句的基本语法主要用于处理多分支。其判断语法为：直接用“case”，很多编程语言可能前面有“switch”或其他关键字，然后具体情况前加“case 1”“case 2”等。在 Shell 中，直接是“case”，非常简单，“case”后跟“$变量名”，用于判断对应的变量，然后加“in”，表示当前的“case”在下面几种情况中。</p></li><li><p>下面看其写法，每种匹配对应的情形，每种情形首先是一个值，可加引号也可不加，后面跟一个右括号，注意必须以右括号结束，表示这是第一种匹配模式。若匹配上，执行这一段程序，执行完以两个分号结束，表示当前分支处理完毕。这类似于 Java 中“case”某种情况，处理后有一个“break”。</p></li><li><p>若不是第一个值，判断是否是第二个值，同样值后加右括号，下面是对应执行流程，结束时来一个双分号。后面还有其他分支可继续罗列，最后可以有一个<code>“* )”</code>，“*”在 Shell 中通常是通配符，表示所有情况，这是默认匹配模式，类似于 Java 中的“default”，即若上面所有模式都未匹配，就走这个分支。接下来是其处理情形，最后同样双分号结束。</p></li><li><p>注意整个“case”语句的结束是“ESAC”，其实就是“case”反过来，跟“if”最后的结束是“fi”一样，相当于一个正括号一个反括号，将这一段代码括在里面。这就是“case”语句的基本用法，整体非常简单，用于多分支处理。</p></li><li><p>还是在控制台创建一个脚本进行书写，写一个“case_test.sh”，先加“#!/bin/bash”，然后进行分支处理。直接输入一个参数，参数是一个整数，判断并输出对应的英文名称。直接“case $1 in”，若为 1 ，直接“echo one”，处理完毕双分号结束；若为 2 ，“echo two”，双分号结束；若为 3 ，“echo three”，同样双分号结束。剩下的不处理，来一个兜底的默认处理方式<code>“* )”</code>，此时“echo number 或者其他数字 other number”，最后“ESAC”。保存退出，加上执行权限，在当前目录执行。</p></li><li><p>输入 2 ，输出“two”；输入 1 ，输出“one”；输入 6 ，输出“number”。这是一个典型的多分支，非常简单，测试一下就知道用法，这就是“case”处理多分支的过程。</p></li></ul><h2 id="四、linux-shell-中的循环" tabindex="-1"><a class="header-anchor" href="#四、linux-shell-中的循环" aria-hidden="true">#</a> 四、Linux Shell 中的循环</h2>',5),S=l("ul",null,[l("li",null,[l("p",null,"前面介绍了“if else”和“case”语句，它们都是流程控制中的分支流程控制。我们知道，在程序代码中，除了顺序执行和分支，还有循环。循环流程控制简单来说，就是定义一段代码，然后让其不停重复执行。但循环不能无限进行，否则会成为死循环无法退出，所以一般循环都要有条件判断，以决定是否继续循环或退出执行后续内容。由此可见，条件判断是流程控制的核心，可用于分支和循环。")]),l("li",null,[l("p",null,"在 Linux Shell 中支持循环，最经典的循环方式是“for”循环。如果学过其他语言，对“for”循环应该不陌生，它是最常用的循环之一。在 Linux Shell 中，“for”有两种不同的使用语法。")]),l("li",null,[l("p",null,"首先看第一种语法，“for”后面直接跟着双小括号，里面是用分号分隔的三部分内容。首先是初始值，因为循环控制过程中需要有退出循环的控制条件，而在循环过程中，要有一个不断变化的东西来保证循环一段时间后能退出，这个不断变化的就是循环变量，所以循环变量要有初始值，还要不断变化。第一个是给循环变量赋初始值，然后是循环的控制条件，即一个条件判断，最后是变量的变化，比如一个数字不断加 1 ，若循环控制条件是小于 10 时不断循环，大于 10 时退出。这是经典的控制流程，包含初始值、控制条件和变量变化三段式表述。后面的语法加了“do”，因为这里没有括号，执行的部分用“do”和“done”包裹，注意这里不是把“for”反过来写“rof”，而是直接后面写“do”开始，“done”结束，中间是要执行的循环体。")]),l("li",null,[l("p",null,"可以做个实验测试一下，在控制台新建一个脚本，这是一个经典例子，比如做连加操作，从 1 开始整数不断加，一直加到 100 ，这是数学王子高斯小时候的经典算法，等差数列求和能直接算出。现在不一定要加到 100 ，把加到哪个数作为参数传进去，即传一个参数进来，就变成脚本里的“$1”，从 1 加到“$1”，最后输出总和。所以这个脚本叫“sum_to.sh”。同样先写“#!/bin/bash”，然后是标准的“for”循环。可以跟上对应的双括号，里面用空格隔开，出于习惯，这里面一般都用空格隔开，中括号必须空格，双小括号里面不空也行，但习惯还是空格。接下来是标准的循环，变量一般用“i”，如果是 Java 里可能是“int i = 0”来控制，在 Shell 里直接用就行，“i = 1”，比如从 1 开始加，不用从 0 开始，“i <= $1”，这就是想要的效果，当前传进来的参数小于等于这个参数就继续循环，最后要有变化，“i++”，C 和 Java 里都有自增运算符，相当于“i = i + 1”，不断加 1 。")]),l("li",null,[l("p",null,[e("后面是对应的循环体，循环体先写“do”，里面直接定义一个“sum”，不用在外面定义，直接“sum = ”就行。“sum”应该等于什么？有点麻烦，按照 C 或 Java 的语法，应该是“sum += ”加上当前的“i”，但现在没有直接的“+= ”表达式，必须写成“sum = sum + i”，但要注意，这里的“sum”，直接给变量赋值时，使用变量要写“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"m"),l("mtext",null,"”，“"),l("mi",null,"i"),l("mtext",null,"”也要写“")]),l("annotation",{encoding:"application/x-tex"},"sum”，“i”也要写“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord mathnormal"},"s"),l("span",{class:"mord mathnormal"},"u"),l("span",{class:"mord mathnormal"},"m"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"，"),l("span",{class:"mord"},"“"),l("span",{class:"mord mathnormal"},"i"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"也要写"),l("span",{class:"mord"},"“")])])]),e("i”，而且在 Shell 里加法不能直接计算，必须包裹在运算表达式里。所以最后的写法是"),l("code",null,"$(( $sum + $i ))"),e("，因为不加“$”和中括号，加号就相当于字符串连接。有了这个，然后写“done”，保存退出，打开当前脚本的执行权限就可以执行。“sum_to 100”测试，没有输出，因为最后没有“echo”输出结果，所以加一句“echo $sum”，保存再执行，得到 5050 ，这是熟悉的结果，从 1 加到 100 是 5050 ，加到 10 就是 55 。这种“for”循环很容易理解，跟 C 语言或 Java 里的写法类似。")])]),l("li",null,[l("p",null,"可能有人会疑惑，之前讲条件控制时，小于等于要用“-le”，为什么这里能用小于等于符号？这里使用了双小括号，在双小括号里可以直接用数学上的运算符号和表达式。记得之前讲运算符时提到，写运算符时可以用“$ + 中括号”，也可以用“$ + 双小括号”。在 Linux Shell 的语法里，如果用双小括号括起来，里面可以直接用数学上的运算式。可以在控制台再做具体测试，比如“a = 3”，然后“if (( $a > 2 )) ”，一行写“then echo OK”，“else echo not OK”，“fi”，直接输出“OK”，“a = 1”再测试，输出“not OK”，逻辑判断没问题。在“for”循环里可以这样写，但一般不在“if”里这么写，因为双小括号看起来比较难受，所以一般“if”后面用中括号写标准形式。“for”这里语法规定可以在双小括号里直接写熟悉的方式，这样语法看起来更容易接受。这里介绍的这种用法跟其他编程语言相似，但不是 Linux Shell 中最常见的“for”用法，更常见的是第二种语法。")]),l("li",null,[l("p",null,"第二种语法是“for”后面直接跟一个变量，然后是“in”，记得讲“case”时的用法，“case”一个变量，然后“in”后面是匹配模式，这里“for”是在后面的值里取出对应的变量，所以“for”循环变量的取值范围就是“in”后面的值，同样后面以“do”开始，“done”结束，执行一段循环代码。接下来在控制台做个测试，先做最简单的，后面直接跟不同的值，值 1 、值 2 、值 3 ，直接在里面取就行。这里直接写成一行，不用写脚本，“for”，比如循环变量叫“OS”表示操作系统，“in”，“Linux”，空格，“Windows”，空格，“Mac OS”，在这几个里选取，然后“do”，直接“echo $OS”，最后输出，相当于把这三个值做了遍历，每次都输出。整体用法很简单。")]),l("li",null,[l("p",null,"另外，在 Linux Shell 里有个内部运算符，表达式是花括号，这就是不能随便用花括号表示函数体或代码块的原因，花括号用法是表示一个序列。比如从 1 到 100 ，像前面从 1 加到 100 ，怎么表示 1 到 100 的序列？直接写“{1..100}”，表示从 1 到 100 的序列。所以知道了“in”后面可以直接跟不同的值，也可以跟一个生成的序列。接下来还是写之前从 1 加到 100 的程序，比如“i”，“in”当前生成的序列“{1..100}”，然后“;”，“do”，还是“sum = $(( $sum + $i ))”，“done”，别忘了“echo $sum”，输出 5050 。这种用法也行。通过这个例子可以看出，“for”“in”后面跟着的是一个序列，类似一个集合。熟悉其他编程语言会发现，这相当于 Java 里的增强“for”循环，Linux Shell 里也有增强“for”循环，这种方式用得更多。")]),l("li",null,[l("p",null,[l("code",null,"有了“for in”的做法，接下来详细说明“$*”和“$@”的区别。一定记得讲过的特殊变量，主要表示当前的输入参数。“$*”的主要特点是把当前命令行里输入的所有参数看成一个整体，“$@”可以把每个参数区别对待。之前直接打印，好像都一样，所有参数空格隔开输出，它们的区别在哪里？用“for”就能更清楚。接下来测试“$*”和“$@”的区别，新建一个测试脚本“parameter_test.sh”，先写“#!/bin/bash”，然后做个分割线，要写“$”符里面的话要用单引号，做个分割线，里面输入“$*”，看下一行继续输出，然后“for”，每个参数“para in $*”，然后“do”，直接“echo $para”，“done”。复制上面 5 行，把“$*”改成“$@”输出。在外面做测试，先打开执行权限，“parameter_test”，后面跟各种参数“a b c d e”，直接输出会发现“$*”和“$@”好像没区别，解释下，在这个脚本里对“$*”和“$@”所有参数遍历，如果不被引号引起来，两者没区别，都是把每个参数获取到单独打印。假如加上引号引起来，就能看到区别，保存，同样命令再执行一遍，上面“$*”输出只有一行，说明双引号引起来的“$*”只有一个元素，就是把所有参数当成一个整体“abcde”一行输出，下面“$@”把“a”“b”“c”“d”“e”不同参数作为独立数据输出，所以循环依次打印。这就是“$*”和“$@”的区别，如果觉得“$@”好用，在脚本里直接用就行，不用更多区分。这就是“for”循环的具体用法。")])])],-1),g=s('<h2 id="五、while-循环" tabindex="-1"><a class="header-anchor" href="#五、while-循环" aria-hidden="true">#</a> 五、While 循环</h2><ul><li><p>接下来，介绍另一个常用的循环流程控制方式，即所谓的“While 循环”。其实，“While 循环”也非常经典，绝大多数编程语言都提供了“While 循环”的语法。</p></li><li><p>“While 循环”与“for 循环”的区别在于：“for 循环”直接在“for”语句中列出循环变量、控制条件及循环变量的变化；而“While 循环”只有一个条件判断式，只进行条件判断以决定是否继续循环或退出循环，至于循环变量是什么以及如何变化，通通不管。所以，一般情况下，“While 循环”有一个特点，即需要在外部先定义循环变量并赋予初值，然后在循环体内部必须实现循环变量的改变。</p></li><li><p>接下来，还是通过一个简单的例子，即之前的从 1 加到 100 的例子，来看如何用“While 循环”实现这部分代码。不再重新创建脚本，直接在之前的“sum_to”脚本中追加。空一行，方便查看。</p></li><li><p>接下来要做的是，直接使用“While”，后面跟着条件判断式，用中括号。有些同学可能会问，用双小括号可以吗？也可以。但一般只有一个条件判断式时，还是像“if”一样，用中括号更方便、更简单。接下来要判断的是当前的某个循环变量，比如将循环变量命名为“a”，判断“$a”是否小于等于上限，上限即“$1”（输入的参数，即加到多少）。这里的“a”当前没有初值，所以必须在外部先给“a”定义一个初值，从 1 开始，即“a=1”。然后判断“a”是否小于等于输入的上限“$1”。接下来是循环体，以“do”开头，“done”结束。</p></li><li><p><code>定义一个“SUM2”（上面的叫“sum”，这里叫“SUM2”），逻辑相同，即“SUM2”应等于之前的“SUM2”加上当前的“$a”，所以循环体内写“$SUM2 += $a”。完成这步后，还需要改变“a”的值，因为之前“for 循环”是“i++”，这里是不是直接写“a++”就行呢？不行，这里无法识别这种语法，所以必须写成“a = a + 1”。前面给“a”赋值时直接写没问题，后面这是加法运算，要先写“$(( )”，然后只要引用到“a”的值，就得加“$”，所以表达式是“$(( $a + 1 ))”。写完后，最后“echo $SUM2”</code>。</p></li><li><p>做完测试，加到 100 ，没有问题，两个都输出 5050 。这就是使用“While 循环”实现累加的过程。</p></li><li><p>当然，可能有同学会发现，这种语法太反人类，如果每次都这么写，太痛苦。这是有原因的，因为 Linux Shell 本身不是为复杂编程设计的高级编程语言，它只是为了在命令行输入命令，控制底层 Linux 内核，进行操作系统的底层操作，所以语法特别底层。在这个过程中，如果要扩展高级语言特性，就会觉得别扭。</p></li><li><p>当然，会发现经典的 Linux Shell 语法太反人类，一开始上手很难受。所以，Linux 也在不断改进。现在很多 Shell 版本支持另一种写法，这里演示一下，将上面两行注释掉，用更人性化的写法实现这两行代码。只要加入“let”命令，这是现在 Shell 的内嵌命令。直接“let”，然后就可以写在其他编程语言中熟悉的语法，即“SUM2 += a”，“let a++”。需要注意的是，“+= ”前后不能有空格，否则会报错。保存后运行，同样没有问题。只是稍微了解一下这种写法，因为很多脚本可能还是老式的经典写法，一定要能看懂。当然，如果熟悉了“let”的写法，使用这种方式显然更轻松、更易理解。所以，这两种用法都应有所了解，这就是关于“While 循环”的具体使用。</p></li></ul>',2);function b(L,w){const i=h("router-link");return u(),o("div",null,[p,f,c(" more "),d,l("nav",m,[l("ul",null,[l("li",null,[a(i,{to:"#概述框架"},{default:n(()=>[e("概述框架")]),_:1})]),l("li",null,[a(i,{to:"#f-第6章流程控制-1"},{default:n(()=>[e("F-第6章流程控制")]),_:1})]),l("li",null,[a(i,{to:"#一、linux-shell-中的流程控制"},{default:n(()=>[e("一、Linux Shell 中的流程控制")]),_:1})]),l("li",null,[a(i,{to:"#二、linux-shell-中的分支流程"},{default:n(()=>[e("二、Linux Shell 中的分支流程")]),_:1})]),l("li",null,[a(i,{to:"#三、linux-shell-中的-case-语句"},{default:n(()=>[e("三、Linux Shell 中的 case 语句")]),_:1})]),l("li",null,[a(i,{to:"#四、linux-shell-中的循环"},{default:n(()=>[e("四、Linux Shell 中的循环")]),_:1})]),l("li",null,[a(i,{to:"#五、while-循环"},{default:n(()=>[e("五、While 循环")]),_:1})])])]),x,_,$,S,g])}const M=t(r,[["render",b],["__file","F-第6章流程控制.html.vue"]]);export{M as default};
