import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c,d as r,a as n,e as p,w as e,b as s,f as t}from"./app-2a2d189a.js";const u="/assets/table2-1-587b488c.png",d={},k=n("h1",{id:"c-第二章变量和基本类型",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#c-第二章变量和基本类型","aria-hidden":"true"},"#"),s(" C-第二章变量和基本类型")],-1),b=n("p",null,"C-第二章变量和基本类型",-1),m=t('<div class="hint-container info"><p class="hint-container-title">说明</p><p>主要是各种搜索找的学习；<br><strong>百度链接：</strong><br> :<br> :</p><p><strong>知乎链接：</strong><br> :<br> :</p><p><strong>B站链接：</strong><br> ：<br> ：</p><p><strong>博客链接：</strong><br> ：<br> ：</p><p><strong>GitHub链接：</strong><br> ：<br> ：</p></div>',1),v={class:"table-of-contents"},g=t('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="第2章-变量和基本类型-结束" tabindex="-1"><a class="header-anchor" href="#第2章-变量和基本类型-结束" aria-hidden="true">#</a> 第2章　变量和基本类型[结束]</h2><ul><li><p>数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据<br> 上执行的操作。(以及内存)</p></li><li><p>C++语言支持广泛的数据类型。它定义了几种基本内置类型（如字<br> 符、整型、浮点数等），同时也为程序员提供了自定义数据类型的机<br> 制。基于此，C++标准库定义了一些更加复杂的数据类型，比如可变长<br> 字符串和向量等。本章将主要讲述内置类型，并带领大家初步了解<br> C++语言是如何支持更复杂数据类型的。</p></li><li><p>数据类型决定了程序中数据和操作的意义。如下所示的语句是一个<br> 简单示例：<code>i = i + j;</code></p></li><li><p>其含义依赖于i和j的数据类型。如果i和j都是整型数，那么这条语句<br> 执行的就是最普通的加法运算。然而，如果i和j是Sales_item类型的数据<br> （参见1.5.1节，第17页），则上述语句把这两个对象的成分相加。</p></li></ul><h2 id="_2-1-基本内置类型" tabindex="-1"><a class="header-anchor" href="#_2-1-基本内置类型" aria-hidden="true">#</a> 2.1　基本内置类型</h2><ul><li>C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</li></ul><h3 id="_2-1-1-算术类型" tabindex="-1"><a class="header-anchor" href="#_2-1-1-算术类型" aria-hidden="true">#</a> 2.1.1　算术类型</h3><ul><li>算术类型分为两类：整型（integral type，包括字符和布尔类型在内）和浮点型。</li><li>算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。表2.1列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。</li><li>布尔类型（bool）的取值是真（true）或者假（false）。</li></ul><figure><img src="'+u+`" alt="table2-1" tabindex="0" loading="lazy"><figcaption>table2-1</figcaption></figure><br><ul><li><p>C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样。</p></li><li><p>其他字符类型用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。</p></li><li><p>除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。</p></li><li><p><mark>内置类型的机器实现</mark></p></li><li><p>计算机以比特序列存储数据，每个比特非0即1，例如：00011011011100010110010000111011 ...</p></li><li><p>大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称<br> 为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在<br> C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8<br> 比特构成，字则由32或64比特构成，也就是4或8字节。</p></li><li><p>大多数计算机将内存中的每个字节与一个数字（被称为“地址（address）”）关联<br> 起来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如<br> 下所示：其中，左侧是字节的地址，右侧是字节中8比特的具体内容。</p></li><li><p>我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们<br> 可能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址<br> 明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特<br> 数以及该如何解释这些比特的内容。</p></li><li><p>如果位置736424处的对象类型是float，并且该机器中float以32比特存储，那么我<br> 们就能知道这个对象的内容占满了整个字。这个float数的实际值依赖于该机器是如何<br> 存储浮点数的。或者如果位置736424处的对象类型是unsigned char，并且该机器使用<br> ISO-Latin-1字符集，则该位置处的字节表示一个分号。</p></li><li><p>浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个<br> 浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通<br> 常，float以1个字（32比特）来表示，double以2个字（64比特）来表<br> 示，long double以3或4个字（96或128比特）来表示。一般来说，类型<br> float和double分别有7和16个有效位；类型long double则常常被用于有特<br> 殊浮点需求的硬件，它的具体实现不同，精度也各不相同。</p></li></ul><br><ul><li><p><mark>带符号类型和无符号类型</mark></p></li><li><p>除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的<br> （signed）和无符号的（unsigned）两种。带符号类型可以表示正数、<br> 负数或0，无符号类型则仅能表示大于等于0的值。</p></li><li><p>类型int、short、long和long long都是带符号的，通过在这些类型名<br> 前添加unsigned就可以得到无符号类型，例如unsigned long。类型<br> unsigned int可以缩写为unsigned。</p></li><li><p>与其他整型不同，字符型被分为了三种：char、signed char和<br> unsigned char。特别需要注意的是：类型char和类型signed char并不一<br> 样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和<br> 无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪<br> 种由编译器决定。</p></li><li><p>无符号类型中所有比特都用来存储值，例如，8比特的unsigned char<br> 可以表示0至255区间内的值。</p></li><li><p>C++标准并没有规定带符号类型应如何表示，但是约定了在表示范<br> 围内正值和负值的量应该平衡。因此，8比特的signed char理论上应该可<br> 以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定<br> 为-128至127。</p></li></ul><br><ul><li><p><mark>建议：如何选择类型</mark></p></li><li><p>和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须<br> 满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员<br> 能够（也应该）对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的<br> 一些经验准则：</p></li><li><p>当明确知晓数值不可能为负时，选用无符号类型。</p></li><li><p>使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样<br> 的尺寸。如果你的数值超过了int的表示范围，选用long long。</p></li><li><p>在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。<br> 因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果<br> 使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定<br> 它的类型是signed char或者unsigned char。</p></li><li><p>执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单<br> 精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单<br> 精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时<br> 消耗也不容忽视。</p></li><li><p><mark>2.1.1节练习</mark></p></li><li><p>练习2.1：类型int、long、long long和short的区别是什么？无符号类型和<br> 带符号类型的区别是什么？float和double的区别是什么？</p></li><li><p>C++ 规定 short 和 int 至少16位，long 至少32位，long long 至少64位。 带符号类型能够表示正数、负数和 0 ，而无符号类型只能够表示 0 和正整数。浮点数的取值范围和精度不同，计算效率也有差异。</p></li><li><p>练习2.2：计算按揭贷款时，对于利率、本金和付款分别应选择何种数<br> 据类型？说明你的理由。</p></li><li><p>使用double。需要进行浮点计算。</p></li></ul><h3 id="_2-1-2-类型转换" tabindex="-1"><a class="header-anchor" href="#_2-1-2-类型转换" aria-hidden="true">#</a> 2.1.2　类型转换</h3><ul><li><p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运<br> 算被大多数类型支持，就是将对象从一种给定的类型转换（convert）为<br> 另一种相关类型。</p></li><li><p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型<br> 时，程序会自动进行类型转换，在4.11节（第141页）中我们将对类型<br> 转换做更详细的介绍。此处，有必要说明当给某种类型的对象强行赋了<br> 另一种类型的值时，到底会发生什么。</p></li><li><p>当我们像下面这样把一种算术类型的值赋给另外一种类型时：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// b is true</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// i has value 1</span>
i <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// i has value 3</span>
<span class="token keyword">double</span> pi <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// pi has value 3.0</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// assuming 8-bit chars, c has value 255 假设char 占8bit，c的数值为255</span>
<span class="token keyword">signed</span> <span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token comment">// 假设char 占8bit，c的数值是未定义的。</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><mark>类型所能表示的值的范围决定了转换的过程：</mark></p></li><li><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则<br> 结果为false，否则结果为true。</p></li><li><p>当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为<br> 0，初始值为true则结果为1。</p></li><li><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值<br> 将仅保留浮点数中小数点之前的部分。</p></li><li><p>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整<br> 数所占的空间超过了浮点类型的容量，精度可能有损失。</p></li><li><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始<br> 值对无符号类型表示数值总数取模后的余数。例如，8比特大小的<br> unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外<br> 的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8<br> 比特大小的unsigned char所得的结果是255。</p></li><li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定<br> 义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成<br> 垃圾数据。</p></li><li><p><mark>建议：避免无法预知和依赖于实现环境的行为</mark></p></li><li><p>无法预知的行为源于编译器无须（有时是不能）检测的错误。即使代码编译通过<br> 了，如果程序执行了一条未定义的表达式，仍有可能产生错误。</p></li><li><p>不幸的是，在某些情况和/或某些编译器下，含有无法预知行为的程序也能正确执<br> 行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通<br> 过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对<br> 另一组输入就一定有效。</p></li><li><p>程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确<br> 定不变的已知值，那么这样的程序就称作不可移植的（nonportable）。当程序移植到<br> 别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类<br> 错误可不是一件轻松愉快的工作。</p></li></ul><br><ul><li>当在程序的某处使用了一种算术类型的值而其实所需的是另一种类<br> 型的值时，编译器同样会执行上述的类型转换。例如，如果我们使用了<br> 一个非布尔值作为条件（参见1.4.1节，第10页），那么它会被自动地转<br> 换成布尔值，这一做法和把非布尔值赋给布尔变量时的操作完全一样：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果i的值为0，则条件的值为false；i的所有其他取值（非0）都将<br> 使条件为true。</p></li><li><p>以此类推，如果我们把一个布尔值用在算术表达式里，则它的取值<br> 非0即1，所以一般不宜在算术表达式里使用布尔值。</p></li><li><p><mark>含有无符号类型的表达式</mark></p></li><li><p>尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）<br> 写出这么做的代码。例如，当一个算术表达式中既有无符号数又有int值<br> 时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int<br> 直接赋给无符号变量一样：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">42</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出-84</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">+</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 如果 int 占 32位，输出 4294967264</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在第一个输出表达式里，两个（负）整数相加并得到了期望的结<br> 果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。<br> 把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这<br> 个负数加上无符号数的模。</p></li><li><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们<br> 都必须确保结果不能是一个负值：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> u1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> u2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span>u1 <span class="token operator">-</span> u2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">//正确，输出 32</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u2 <span class="token operator">-</span> u1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// ok: but the result will wrap around</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>无符号数不会小于0这一事实同样关系到循环的写法。例如，在<br> 1.4.1节的练习（第11页）中需要写一个循环，通过控制变量递减的方式<br> 把从10到0的数字降序输出。这个循环可能类似于下面的形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个<br> 循环。然而，这个不经意的改变却意味着死循环：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// WRONG: u can never be less than 0; the condition will always succeed</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> u <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>u<span class="token punctuation">)</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>来看看当u等于0时发生了什么，这次迭代输出0，然后继续执行for<br> 语句里的表达式。表达式--u从u当中减去1，得到的结果-1并不满足无符<br> 号数的要求，此时像所有表示范围之外的其他数字一样，-1被自动地转<br> 换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的<br> 结果将会是4294967295。</p></li><li><p>一种解决的办法是，用while语句来代替for语句，因为前者让我们<br> 能够在输出变量之前（而非之后）先减去1：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// start the loop one past the first element we want to print</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>u <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token operator">--</span>u<span class="token punctuation">;</span> <span class="token comment">// decrement first, so that the last iteration will print 0</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>改写后的循环先执行对循环控制变量减1的操作，这样最后一次迭<br> 代时，进入循环的u值为1。此时将其减1，则这次迭代输出的数就是0；<br> 下一次再检验循环条件时，u的值等于0而无法再进入循环。因为我们要<br> 先做减1的操作，所以初始化u的值应该比要输出的最大值大1。这里，u<br> 初始化为11，输出的最大数是10。</p></li><li><p><mark>提示：切勿混用带符号类型和无符号类型</mark></p></li><li><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现<br> 异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a＊b的式<br> 子中，如果a = -1，b = 1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是<br> int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结<br> 果是4294967295。</p></li><li><p><mark>2.1.2节练习</mark></p></li><li><p>练习2.3：读程序写结果。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> u2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u2 <span class="token operator">-</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">-</span> u2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> i2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i2 <span class="token operator">-</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">-</span> i2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">-</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u <span class="token operator">-</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token number">32</span>
<span class="token number">4294967264</span>
<span class="token number">32</span>
<span class="token operator">-</span><span class="token number">32</span>
<span class="token number">0</span>
<span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.4：编写程序检查你的估计是否正确，如果不正确，请仔细研读<br> 本节直到弄明白问题所在。</li></ul><h3 id="_2-1-3-字面值常量" tabindex="-1"><a class="header-anchor" href="#_2-1-3-字面值常量" aria-hidden="true">#</a> 2.1.3　字面值常量</h3><ul><li><p>一个形如42的值被称作字面值常量（literal），这样的值一望而<br> 知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定<br> 了它的数据类型。</p></li><li><p><mark>整型和浮点型字面值</mark></p></li><li><p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形<br> 式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。<br> 例如，我们能用下面的任意一种形式来表示数值20：<br><code>20 /* 十进制 */ 024 /* 八进制 */ 0x14 / * 十六进制 */</code></p></li><li><p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十<br> 进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也<br> 可能是无符号的。十进制字面值的类型是int、long和long long中尺寸最<br> 小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳<br> 下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、<br> unsigned int、long、unsigned long、long long和unsigned long long中的尺<br> 寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将<br> 产生错误。类型short没有对应的字面值。在表2.2（第37页）中，我们将以后缀代表相应的字面值类型。</p></li><li><p>尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进<br> 制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面<br> 值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而<br> 已。</p></li><li><p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指<br> 数部分用E或e标识：<br><code>3.14159 3.14159E0 0. 0e0 .001</code></p></li><li><p>默认的，浮点型字面值是一个double，我们可以使用表2.2（第37<br> 页）中的后缀来表示其他浮点型。</p></li></ul><br><ul><li><p><mark>字符和字符串字面值</mark></p></li><li><p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零<br> 个或多个字符则构成字符串型字面值。<br><code>&#39;a&#39; //字符字面值</code><br><code>&quot;Hello World！&quot; // 字符串字面值</code></p></li><li><p>字符串字面值的类型实际上是由常量字符构成的数组（array），该<br> 类型将在3.5.4节（第109页）介绍。编译器在每个字符串的结尾处添加<br> 一个空字符（′\\0′），因此，字符串字面值的实际长度要比它的内容多<br> 1。例如，字面值&#39;A&#39;表示的就是单独的字符A，而字符串&quot;A&quot;则代表了一<br> 个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符。</p></li><li><p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，<br> 则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里<br> 不太合适时，就可以采取分开书写的方式：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// multiline string literal</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a really, really long string literal &quot;</span>
 <span class="token string">&quot;that spans two lines&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>转义序列</mark></li><li>有两类字符程序员不能直接使用：一类是不可打印（nonprintable）<br> 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是<br> 在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。<br> 在这些情况下需要用到转义序列（escape sequence），转义序列均以反<br> 斜线作为开始，C++语言规定的转义序列包括：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>newline \\n horizontal tab \\t <span class="token function">alert</span> <span class="token punctuation">(</span>bell<span class="token punctuation">)</span> \\a
vertical tab \\v backspace \\b <span class="token keyword">double</span> quote \\&quot;
backslash \\\\ question mark \\<span class="token operator">?</span> single quote \\&#39;
carriage <span class="token keyword">return</span> \\r formfeed \\f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在程序中，上述转义序列被当作一个字符使用：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span> <span class="token comment">// prints a newline</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\tHi!\\n&quot;</span><span class="token punctuation">;</span> <span class="token comment">// prints a tab followd by &quot;Hi!&quot; and a newline</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们也可以使用泛化的转义序列，其形式是\\x后紧跟1个或多个十<br> 六进制数字，或者\\后紧跟1个、2个或3个八进制数字，其中数字部分表<br> 示的是字符对应的数值。假设使用的是Latin-1字符集，以下是一些示例：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>\\<span class="token number">7</span> <span class="token punctuation">(</span>bell<span class="token punctuation">)</span> \\<span class="token number">12</span> <span class="token punctuation">(</span>newline<span class="token punctuation">)</span> \\<span class="token number">40</span> <span class="token punctuation">(</span>blank<span class="token punctuation">)</span>
\\<span class="token number">0</span> <span class="token punctuation">(</span>null<span class="token punctuation">)</span> \\<span class="token number">115</span> <span class="token punctuation">(</span><span class="token char">&#39;M&#39;</span><span class="token punctuation">)</span> \\<span class="token function">x4d</span> <span class="token punctuation">(</span><span class="token char">&#39;M&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们可以像使用普通字符那样使用C++语言定义的转义序列：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hi \\x4dO\\115!\\n&quot;</span><span class="token punctuation">;</span> <span class="token comment">// prints Hi MOM! followed by a newline</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\115&#39;</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span> <span class="token comment">// prints M followed by a newline</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>注意，如果反斜线\\后面跟着的八进制数字超过3个，只有前3个数<br> 字与\\构成转义序列。例如，&quot;\\1234&quot;表示2个字符，即八进制数123对应<br> 的字符以及字符4。相反，\\x要用到后面跟着的所有数字，例<br> 如，&quot;\\x1234&quot;表示一个16位的字符，该字符由这4个十六进制数所对应的<br> 比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例<br> 子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个<br> 前缀作为开头的扩展字符集一起使用的。</p></li><li><p><mark>指定字面值的类型</mark></p></li><li><p>通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和<br> 字符型字面值的默认类型。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>L<span class="token char">&#39;a&#39;</span> <span class="token comment">// wide character literal, type is wchar_t</span>
u8<span class="token string">&quot;hi!&quot;</span> <span class="token comment">// utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)</span>
<span class="token number">42ULL</span> <span class="token comment">// unsigned integer literal, type is unsigned long long</span>
<span class="token number">1E-3F</span> <span class="token comment">// single-precision floating-point literal, type is float</span>
<span class="token number">3.14159L</span> <span class="token comment">// extended-precision floating-point literal, type is long double</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太<br> 容易混淆了。</p></li><li><p>对于一个整型字面值来说，我们能分别指定它是否带符号以及占用<br> 多少空间。如果后缀中有U，则该字面值属于无符号类型，也就是说，<br> 以U为后缀的十进制数、八进制数或十六进制数都将从unsigned int、<br> unsigned long和unsigned long long中选择能匹配的空间最小的一个作为<br> 其数据类型。如果后缀中有L，则字面值的类型至少是long；如果后缀<br> 中有LL，则字面值的类型将是long long和unsigned long long 中的一种。<br> 显然我们可以将U与L或LL合在一起使用。例如，以UL为后缀的字面值<br> 的数据类型将根据具体数值情况或者取unsigned long，或者取unsigned<br> long long。</p></li></ul><br><ul><li><p><mark>布尔字面值和指针字面值</mark></p></li><li><p>true和false是布尔类型的字面值：<code>bool test = true;</code></p></li><li><p>nullptr是指针字面值，2.3.2节（第47页）将有更多关于指针和指针<br> 字面值的介绍。</p></li></ul><h3 id="_2-1-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-1-3节练习" aria-hidden="true">#</a> 2.1.3节练习</h3><ul><li>练习2.5：指出下述字面值的数据类型并说明每一组内几种字面值的区别：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">,</span> L<span class="token char">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> L<span class="token string">&quot;a&quot;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10u</span><span class="token punctuation">,</span> <span class="token number">10L</span><span class="token punctuation">,</span> <span class="token number">10uL</span><span class="token punctuation">,</span> <span class="token number">012</span><span class="token punctuation">,</span> <span class="token number">0xC</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">,</span> <span class="token number">3.14L</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10u</span><span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">,</span> <span class="token number">10e-2</span>

<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> 字符字面值，宽字符字面值，字符串字面值，宽字符串字面值。
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> 十进制整型，十进制无符号整型，十进制长整型，十进制无符号长整型， 八进制整型，十六进制整型。
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">double</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">:</span> 十进制整型，十进制无符号整型，<span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.6：下面两组定义是否有区别，如果有，请叙述之：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> day <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">09</span><span class="token punctuation">,</span> day <span class="token operator">=</span> <span class="token number">07</span><span class="token punctuation">;</span>

第一行定义的是十进制的整型，第二行定义的是八进制的整型。但是month变量有误，八进制不能直接写<span class="token number">9</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.7：下述字面值表示何种含义？它们各自的数据类型是什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token string">&quot;Who goes with F\\145rgus?\\012&quot;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token number">3.14e1L</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">1024f</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token number">3.14L</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> Who goes with Fergus<span class="token operator">?</span><span class="token punctuation">(</span>换行<span class="token punctuation">)</span>，string 类型
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">long</span> <span class="token keyword">double</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> 无效，因为后缀\`f\`只能用于浮点字面量，而<span class="token number">1024</span>是整型。
<span class="token operator">-</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">long</span> <span class="token keyword">double</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.8：请利用转义序列编写一段程序，要求先输出2M，然后转到新<br> 一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到<br> 新一行。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\115\\012&quot;</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\t\\115\\012&quot;</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-变量" tabindex="-1"><a class="header-anchor" href="#_2-2-变量" aria-hidden="true">#</a> 2.2　变量</h2><ul><li>变量提供一个具名的、可供程序操作的存储空间。C++中的每个变<br> 量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方<br> 式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员<br> 来说，“变量（variable）”和“对象（object）”一般可以互换使用。</li></ul><h3 id="_2-2-1-变量定义" tabindex="-1"><a class="header-anchor" href="#_2-2-1-变量定义" aria-hidden="true">#</a> 2.2.1　变量定义</h3><ul><li>变量定义的基本形式是：首先是类型说明符（type specifier），随<br> 后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后<br> 以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还<br> 可以为一个或多个变量赋初值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token comment">// sum, value, and units_sold have type int</span>
 units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// sum and units_sold have initial value 0</span>
Sales_item item<span class="token punctuation">;</span> <span class="token comment">// item has type Sales_item (see § 1.5.1 (p. 20))</span>
<span class="token comment">// string is a library type, representing a variable-length sequence of characters</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">book</span><span class="token punctuation">(</span><span class="token string">&quot;0-201-78345-X&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// book initialized from string literal</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>book的定义用到了库类型std：：string，像iostream（参见1.2节，第<br> 6页）一样，string也是在命名空间std中定义的，我们将在第3章中对<br> string类型做更详细的介绍。眼下，只需了解string是一种表示可变长字<br> 符序列的数据类型就可以了。C++库提供了几种初始化string对象的方<br> 法，其中一种是把字面值拷贝给string对象（参见2.1.3节，第36页），<br> 因此在上例中，book被初始化为0-201-78345-X。</li></ul><br><ul><li><p><mark>术语：何为对象？</mark></p></li><li><p>C++程序员们在很多场合都会使用对象（object）这个名词。通常情况下，对象是<br> 指一块能存储数据并具有某种类型的内存空间。</p></li><li><p>一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象<br> 和未命名的对象区分开来，他们把命名了的对象叫做变量。还有一些人把对象和值区<br> 分开来，其中对象指能被程序修改的数据，而值（value）指只读的数据。</p></li><li><p>本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间。我<br> 们在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否<br> 只读。</p></li><li><p><mark>初始值</mark></p></li><li><p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化<br> （initialized）了。用于初始化变量的值可以是任意复杂的表达式。当一<br> 次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用<br> 了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义<br> 的其他变量。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ok: price is defined and initialized before it is used to initialize discount</span>
<span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">109.99</span><span class="token punctuation">,</span> discount <span class="token operator">=</span> price <span class="token operator">*</span> <span class="token number">0.16</span><span class="token punctuation">;</span>
<span class="token comment">// ok: call applyDiscount and use the return value to initialize salePrice</span>
<span class="token keyword">double</span> salePrice <span class="token operator">=</span> <span class="token function">applyDiscount</span><span class="token punctuation">(</span>price<span class="token punctuation">,</span> discount<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在C++语言中，初始化是一个异常复杂的问题，我们也将反复讨论<br> 这个问题。很多程序员对于用等号=来初始化变量的方式倍感困惑，这<br> 种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始<br> 化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几<br> 乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人<br> 们特别容易把二者混为一谈。需要强调的是，这个概念至关重要，我们<br> 也将在后面不止一次提及这一点。</p></li><li><p><mark>warning</mark></p></li><li><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义<br> 是把对象的当前值擦除，而以一个新值来替代。</p></li></ul><br><ul><li><mark>列表初始化</mark></li><li>C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂<br> 性的一个体现。例如，要想定义一个名为units_sold的int变量并初始化为<br> 0，以下的4条语句都可以做到这一点：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> units_sold<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">units_sold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应<br> 用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。<br> 出于3.3.1节（第88页）将要介绍的原因，这种初始化的形式被称为列表<br> 初始化（list initialization）。现在，无论是初始化对象还是某些时候为<br> 对象赋新值，都可以使用这样一组由花括号括起来的初始值了。</p></li><li><p>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果<br> 我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">double</span> ld <span class="token operator">=</span> <span class="token number">3.1415926536</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">{</span>ld<span class="token punctuation">}</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>ld<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: narrowing conversion required</span>
<span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span>ld<span class="token punctuation">)</span><span class="token punctuation">,</span> d <span class="token operator">=</span> ld<span class="token punctuation">;</span> <span class="token comment">// ok: but value will be truncated</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>使用long double的值初始化int变量时可能丢失数据，所以编译器拒<br> 绝了a和b的初始化请求。其中，至少ld的小数部分会丢失掉，而且int也<br> 可能存不下ld的整数部分。</p></li><li><p>刚刚所介绍的看起来无关紧要，毕竟我们不会故意用long double的<br> 值去初始化int变量。然而，像第16章介绍的一样，这种初始化有可能在<br> 不经意间发生。我们将在3.2.1节（第76页）和3.3.1节（第88页）对列表<br> 初始化做更多介绍。</p></li></ul><br><ul><li><p><mark>默认初始化</mark></p></li><li><p>如果定义变量时没有指定初值，则变量被默认初始化（default<br> initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类<br> 型决定，同时定义变量的位置也会对此有影响。</p></li><li><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决<br> 定。定义于任何函数体之外的变量被初始化为0。然而如6.1.1节（第185<br> 页）所示，一种例外情况是，定义在函数体内部的内置类型变量将不被<br> 初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义<br> 的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值将<br> 引发错误。</p></li><li><p>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化<br> 就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初<br> 始值到底是什么</p></li><li><p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一<br> 个合适的默认值。例如，以刚刚所见为例，string类规定如果没有指定<br> 初值则生成一个空串：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string empty<span class="token punctuation">;</span> <span class="token comment">// empty implicitly initialized to the empty string</span>
Sales_item item<span class="token punctuation">;</span> <span class="token comment">// default-initialized Sales_item object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>一些类要求每个对象都显式初始化，此时如果创建了一个该类的对<br> 象而未对其做明确的初始化操作，将引发错误。</p></li><li><p><mark>Note</mark></p></li><li><p>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如<br> 果没有显式地初始化，则其值由类确定。</p></li></ul><h3 id="_2-2-1节练习" tabindex="-1"><a class="header-anchor" href="#_2-2-1节练习" aria-hidden="true">#</a> 2.2.1节练习</h3><ul><li>练习2.9：解释下列定义的含义。对于非法的定义，请说明错在何处并<br> 将其改正。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> <span class="token keyword">int</span> input_value<span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">double</span> salary <span class="token operator">=</span> wage <span class="token operator">=</span> <span class="token number">9999.99</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>


<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> 应该先定义再使用。

<span class="token keyword">int</span> input_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> input_value<span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> 用列表初始化内置类型的变量时，如果存在丢失信息的风险，则编译器将报错。

<span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3.14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> 在这里wage是未定义的，应该在此之前将其定义。

<span class="token keyword">double</span> wage<span class="token punctuation">;</span>
<span class="token keyword">double</span> salary <span class="token operator">=</span> wage <span class="token operator">=</span> <span class="token number">9999.99</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">:</span> 不报错，但是小数部分会被截断。

<span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.10：下列变量的初值分别是什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string global_str<span class="token punctuation">;</span>
<span class="token keyword">int</span> global_int<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> local_int<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string local_str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
解：

global_str和global_int是全局变量，所以初值分别为空字符串和<span class="token number">0</span>。 local_int是局部变量并且没有初始化，它的初值是未定义的。 local_str 是 string 类的对象，它的值由类确定，为空字符串。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>提示：未初始化变量引发运行时故障</mark></li><li>未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程<br> 行为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警<br> 告，但严格来说，编译器并未被要求检查此类错误。</li><li>使用未初始化的变量将带来无法预计的后果。有时我们足够幸运，一访问此类对<br> 象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被初始化的问<br> 题。另外一些时候，程序会一直执行完并产生错误的结果。更糟糕的情况是，程序结<br> 果时对时错、无法把握。而且，往无关的位置添加代码还会导致我们误以为程序对<br> 了，其实结果仍旧有错。</li><li>建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保<br> 初始化后程序安全，那么这么做不失为一种简单可靠的方法。</li></ul><h3 id="_2-2-2-变量声明和定义的关系" tabindex="-1"><a class="header-anchor" href="#_2-2-2-变量声明和定义的关系" aria-hidden="true">#</a> 2.2.2　变量声明和定义的关系</h3><ul><li><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式<br> 编译（separate compilation）机制，该机制允许将程序分割为若干个文<br> 件，每个文件可被独立编译。</p></li><li><p>如果将程序分为多个文件，则需要有在文件间共享代码的方法。例<br> 如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际<br> 的例子是std：：cout和std：：cin，它们定义于标准库，却能被我们写<br> 的程序使用。</p></li><li><p>为了支持分离式编译，C++语言将声明和定义区分开来。声明<br> （declaration）使得名字为程序所知，一个文件如果想使用别处定义的<br> 名字则必须包含对那个名字的声明。而定义（definition）负责创建与名<br> 字关联的实体。</p></li><li><p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但<br> 是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p></li><li><p>如果想声明一个变量而非定义它，就在变量名前添加关键字<br> extern，而且不要显式地初始化变量：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment">// declares but does not define i</span>
<span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token comment">// declares and defines j</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>任何包含了显式初始化的声明即成为定义。我们能给由extern关键<br> 字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。<br> extern语句如果包含初始值就不再是声明，而变成定义了：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.1416</span><span class="token punctuation">;</span> <span class="token comment">// definition</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，<br> 将引发错误。</p></li><li><p><mark>Note</mark></p></li><li><p>变量能且只能被定义一次，但是可以被多次声明。</p></li><li><p>声明和定义的区别看起来也许微不足道，但实际上却非常重要。如<br> 果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，<br> 变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的<br> 文件必须对其进行声明，却绝对不能重复定义。</p></li><li><p>关于C++语言对分离式编译的支持我们将在2.6.3节（第67页）和<br> 6.1.3节（第186页）中做更详细的介绍。</p></li></ul><h3 id="_2-2-2节练习" tabindex="-1"><a class="header-anchor" href="#_2-2-2节练习" aria-hidden="true">#</a> 2.2.2节练习</h3><ul><li>练习2.11：指出下面的语句是声明还是定义：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> ix <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> iy<span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">extern</span> <span class="token keyword">int</span> iz<span class="token punctuation">;</span>
解：

<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> 定义 <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> 定义 <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> 声明
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><mark>关键概念：静态类型</mark></li><li>C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其<br> 中，检查类型的过程称为类型检查（type checking）。</li><li>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器<br> 负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器<br> 将报错并且不会生成可执行文件。</li><li>程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每<br> 一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。</li></ul><h3 id="_2-2-3-标识符" tabindex="-1"><a class="header-anchor" href="#_2-2-3-标识符" aria-hidden="true">#</a> 2.2.3　标识符</h3><ul><li>C++的标识符（identifier）由字母、数字和下画线组成，其中必须<br> 以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// defines four different int variables</span>
<span class="token keyword">int</span> somename<span class="token punctuation">,</span> someName<span class="token punctuation">,</span> SomeName<span class="token punctuation">,</span> SOMENAME<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如表2.3和表2.4所示，C++语言保留了一些名字供语言本身使用，<br> 这些名字不能被用作标识符。</p></li><li><p>同时，C++也为标准库保留了一些名字。用户自定义的标识符中不<br> 能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定<br> 义在函数体外的标识符不能以下画线开头。</p></li><li><p><mark>变量命名规范</mark></p></li><li><p>变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：<br> 标识符要能体现实际含义。<br> 变量名一般用小写字母，如index，不要使用Index或INDEX<br> 用户自定义的类名一般以大写字母开头，如Sales_item。<br> 如果标识符由多个单词组成，则单词间应有明显区分，<br> 如student_loan或studentLoan，不要使用studentloan。</p></li></ul><h3 id="_2-2-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-2-3节练习" aria-hidden="true">#</a> 2.2.3节练习</h3><ul><li>练习2.12：请指出下面的名字中哪些是非法的？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>请指出下面的名字中哪些是非法的？

<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token keyword">double</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> _<span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token keyword">catch</span><span class="token operator">-</span><span class="token number">22</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token number">1</span>_or_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token keyword">double</span> Double <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
解：

<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> 非法。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-4-名字的作用域" tabindex="-1"><a class="header-anchor" href="#_2-2-4-名字的作用域" aria-hidden="true">#</a> 2.2.4　名字的作用域</h3><ul><li><p>不论是在程序的什么位置，使用到的每个名字都会指向一个特定的<br> 实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同<br> 位置，也可能指向的是不同实体。</p></li><li><p>作用域（scope）是程序的一部分，在其中名字有其特定的含义。<br> C++语言中大多数作用域都以花括号分隔。</p></li><li><p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区<br> 域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p></li><li><p>一个典型的示例来自于1.4.2节（第11页）的程序：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// sum values from 1 through 10 inclusive</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> val <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>val<span class="token punctuation">)</span>
        sum <span class="token operator">+=</span> val<span class="token punctuation">;</span> <span class="token comment">// equivalent to sum = sum + val</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Sum of 1 to 10 inclusive is &quot;</span> <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段程序定义了3个名字：main、sum和val，同时使用了命名空间<br> 名字std，该空间提供了2个名字cout和cin供程序使用。</p></li><li><p>名字main定义于所有花括号之外，它和其他大多数定义在函数体之<br> 外的名字一样拥有全局作用域（global scope）。一旦声明之后，全局作<br> 用域内的名字在整个程序的范围内都可使用。名字sum定义于main函数<br> 所限定的作用域之内，从声明sum开始直到main函数结束为止都可以访<br> 问它，但是出了main函数所在的块就无法访问了，因此说变量sum拥有<br> 块作用域（block scope）。名字val定义于for语句内，在for语句之内可<br> 以访问val，但是在main函数的其他部分就不能访问它了。</p></li><li><p><mark>建议：当你第一次使用变量时再定义它</mark></p></li><li><p>一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做<br> 有助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地<br> 方很近时，我们也会赋给它一个比较合理的初始值。</p></li><li><p><mark>嵌套的作用域</mark></p></li><li><p>作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作<br> 用域（inner scope），包含着别的作用域的作用域称为外层作用域<br> （outer scope）。</p></li><li><p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访<br> 问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名<br> 字：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// Program for illustration purposes only: It is bad style for a function</span>
<span class="token comment">// to use a global variable and also define a local variable with the same name</span>
<span class="token keyword">int</span> reused <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// reused has global scope</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">int</span> unique <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// unique has block scope</span>
 <span class="token comment">// output #1: uses global reused; prints 42 0</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reused <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> unique <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">int</span> reused <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// new, local object named reused hides global reused</span>
 <span class="token comment">// output #2: uses local reused; prints 0 0</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reused <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> unique <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token comment">// output #3: explicitly requests the global reused; prints 42 0</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token double-colon punctuation">::</span>reused <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> unique <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>输出#1出现在局部变量reused定义之前，因此这条语句使用全局作<br> 用域中定义的名字reused，输出42 0。输出#2发生在局部变量reused定义<br> 之后，此时局部变量reused正在作用域内（in scope），因此第二条输出<br> 语句使用的是局部变量reused而非全局变量，输出0 0。输出#3使用作用<br> 域操作符（参见1.2节，第7页）来覆盖默认的作用域规则，因为全局作<br> 用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用<br> 域发出请求获取作用域操作符右侧名字对应的变量。结果是，第三条输<br> 出语句使用全局变量reused，输出42 0。</p></li><li><p><mark>warning</mark></p></li><li><p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p></li></ul><h3 id="_2-2-4节练习" tabindex="-1"><a class="header-anchor" href="#_2-2-4节练习" aria-hidden="true">#</a> 2.2.4节练习</h3><ul><li>练习2.13：下面程序中j的值是多少？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

j的值是<span class="token number">100</span>，局部变量i覆盖了全局变量i。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.14：下面的程序合法吗？如果合法，它将输出什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

合法。输出是 <span class="token number">100</span> <span class="token number">45</span> 。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-3-复合类型" tabindex="-1"><a class="header-anchor" href="#_2-3-复合类型" aria-hidden="true">#</a> 2.3　复合类型</h2><ul><li><p>复合类型（compound type）是指基于其他类型定义的类型。C++语<br> 言有几种复合类型，本章将介绍其中的两种：引用和指针。</p></li><li><p>与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很<br> 多。2.2节（第38页）提到，一条简单的声明语句由一个数据类型和紧<br> 随其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由<br> 一个基本数据类型（base type）和紧随其后的一个声明符（declarator）<br> 列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型<br> 有关的某种类型。</p></li><li><p>目前为止，我们所接触的声明语句中，声明符其实就是变量名，此<br> 时变量的类型也就是声明的基本数据类型。其实还可能有更复杂的声明<br> 符，它基于基本数据类型得到更复杂的类型，并把它指定给变量.</p></li></ul><h3 id="_2-3-1-引用" tabindex="-1"><a class="header-anchor" href="#_2-3-1-引用" aria-hidden="true">#</a> 2.3.1　引用</h3><ul><li><p>C++11中新增了一种引用：所谓的“右值引用（rvalue reference）”，我们将在<br> 13.6.1节（第471页）做更详细的介绍。这种引用主要用于内置类。严格来说，当我们<br> 使用术语“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。</p></li><li><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers<br> to）另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中<br> d是声明的变量名：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal <span class="token operator">=</span> ival<span class="token punctuation">;</span> <span class="token comment">// refVal refers to (is another name for) ival</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal2<span class="token punctuation">;</span> <span class="token comment">// error: a reference must be initialized</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义<br> 引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始<br> 值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在<br> 一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</li></ul><br><ul><li><p><mark>引用即别名</mark></p></li><li><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></li><li><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>refVal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// assigns 2 to the object to which refVal refers, i.e., to ival</span>
<span class="token keyword">int</span> ii <span class="token operator">=</span> refVal<span class="token punctuation">;</span> <span class="token comment">// same as ii = ival</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的<br> 值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始<br> 值，实际上是以与引用绑定的对象作为初始值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ok: refVal3 is bound to the object to which refVal is bound, i.e., to ival</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal3 <span class="token operator">=</span> refVal<span class="token punctuation">;</span>
<span class="token comment">// initializes i from the value in the object to which refVal is bound</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> refVal<span class="token punctuation">;</span> <span class="token comment">// ok: initializes i to the same value as ival</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为引用本身不是一个对象，所以不能定义引用的引用。</li></ul><br><ul><li><mark>引用的定义</mark></li><li>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符<br> 号&amp;开头：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> i2 <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">;</span> <span class="token comment">// i and i2 are both ints</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">,</span> r2 <span class="token operator">=</span> i2<span class="token punctuation">;</span> <span class="token comment">// r is a reference bound to i; r2 is an int</span>
<span class="token keyword">int</span> i3 <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ri <span class="token operator">=</span> i3<span class="token punctuation">;</span> <span class="token comment">// i3 is an int; ri is a reference bound to i3</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> i3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> i2<span class="token punctuation">;</span> <span class="token comment">// both r3 and r4 are references</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>除了2.4.1节（第55页）和15.2.3节（第534页）将要介绍的两种例外<br> 情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引<br> 用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在<br> 一起，相关原因将在2.4.1节详述：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal4 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// error: initializer must be an object</span>
<span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal5 <span class="token operator">=</span> dval<span class="token punctuation">;</span> <span class="token comment">// error: initializer must be an int object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-1节练习" tabindex="-1"><a class="header-anchor" href="#_2-3-1节练习" aria-hidden="true">#</a> 2.3.1节练习</h3><p>练习2.15：下面的哪个定义是不合法的？为什么？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1.01</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rval1 <span class="token operator">=</span> <span class="token number">1.01</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rval2 <span class="token operator">=</span> ival<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rval3<span class="token punctuation">;</span>

解：

<span class="token punctuation">(</span>b<span class="token punctuation">)</span>和<span class="token punctuation">(</span>d<span class="token punctuation">)</span>不合法，<span class="token punctuation">(</span>b<span class="token punctuation">)</span>引用必须绑定在对象上，<span class="token punctuation">(</span>d<span class="token punctuation">)</span>引用必须初始化。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.16：考查下面的所有赋值然后回答：哪些赋值是不合法的？为什<br> 么？哪些赋值是合法的？它们执行了什么样的操作？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span> 
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> d<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> r2 <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> r2 <span class="token operator">=</span> r1<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> i <span class="token operator">=</span> r2<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> r1 <span class="token operator">=</span> d<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> 合法。给 d 赋值为 <span class="token number">3.14159</span>。
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> 合法。会执行自动转换（<span class="token keyword">int</span><span class="token operator">-&gt;</span><span class="token keyword">double</span>）。
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> 合法。会发生小数截取。
<span class="token operator">-</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">:</span> 合法。会发生小数截取。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.17：执行下面的代码段将输出什么结果？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ri <span class="token operator">=</span> i<span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> ri <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> ri <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
输出：<span class="token number">10</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-2-指针" tabindex="-1"><a class="header-anchor" href="#_2-3-2-指针" aria-hidden="true">#</a> 2.3.2　指针</h3><ul><li><p>指针（pointer）是“指向（point to）”另外一种类型的复合类型。与<br> 引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比<br> 又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷<br> 贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，<br> 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的<br> 指针如果没有被初始化，也将拥有一个不确定的值。</p></li><li><p>指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而被<br> 备受折磨。</p></li><li><p>定义指针类型的方法将声明符写成＊d的形式，其中d是变量名。如<br> 果在一条语句中定义了几个指针变量，每个变量前面都必须有符号＊：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ip1<span class="token punctuation">,</span> <span class="token operator">*</span>ip2<span class="token punctuation">;</span> <span class="token comment">// both ip1 and ip2 are pointers to int</span>
<span class="token keyword">double</span> dp<span class="token punctuation">,</span> <span class="token operator">*</span>dp2<span class="token punctuation">;</span> <span class="token comment">// dp2 is a pointer to double; dp is a double</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>获取对象的地址</mark></li><li>指针存放某个对象的地址，要想获取该地址，需要使用取地址符<br> （操作符&amp;）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// p holds the address of ival; p is a pointer to ival</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名<br> 为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指<br> 向引用的指针。</p></li><li><p>除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外<br> 情况，其他所有指针的类型都要和它所指向的对象严格匹配：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">double</span> dval<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment">// ok: initializer is the address of a double</span>
<span class="token keyword">double</span> <span class="token operator">*</span>pd2 <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment">// ok: initializer is a pointer to double</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment">// error: types of pi and pd differ</span>
pi <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment">// error: assigning the address of a double to a pointer to int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为在声明语句中指针的类型实际上被用于指定它所指向对象的类<br> 型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对<br> 象的操作将发生错误。</li></ul><br><ul><li><p><mark>指针值</mark></p></li><li><p>指针的值（即地址）应属下列4种状态之一：<br> 1.指向一个对象。<br> 2.指向紧邻对象所占空间的下一个位置。<br> 3.空指针，意味着指针没有指向任何对象。<br> 4.无效指针，也就是上述情况之外的其他值。</p></li><li><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并<br> 不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。<br> 访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是<br> 否有效。</p></li><li><p>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。<br> 显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定<br> 的）对象的行为不被允许。如果这样做了，后果也无法预计。</p></li></ul><br><ul><li><mark>利用指针访问对象</mark></li><li>如果指针指向了一个对象，则允许使用解引用符（操作符＊）来访<br> 问该对象：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// p holds the address of ival; p is a pointer to ival</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// * yields the object to which p points; prints 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，<br> 实际上也就是给指针所指的对象赋值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// * yields the object; we assign a new value to ival through p</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// prints 0</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如上述程序所示，为＊p赋值实际上是为p所指的对象赋值。</p></li><li><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p></li></ul><br><ul><li><mark>关键概念：某些符号有多重含义</mark></li><li>像&amp;和＊这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出<br> 现，符号的上下文决定了符号的意义:</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// &amp; follows a type and is part of a declaration; r is a reference</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// * follows a type and is part of a declaration; p is a pointer</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// &amp; is used in an expression as the address-of operator</span>
<span class="token operator">*</span>p <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// * is used in an expression as the dereference operator</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// &amp; is part of the declaration; * is the dereference operator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在声明语句中，&amp;和＊用于组成复合类型；在表达式中，它们的角色又转变成运<br> 算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完<br> 全可以把它当作不同的符号来看待。</li></ul><br><ul><li><mark>空指针</mark></li><li>空指针（null pointer）不指向任何对象，在试图使用一个指针之前<br> 代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to int *p1 = 0;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// directly initializes p2 from the literal constant 0</span>
<span class="token comment">// must #include cstdlib</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to int *p3 = 0;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也<br> 是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面<br> 值，它可以被转换成（参见2.1.2节，第32页）任意其他的指针类型。另<br> 一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来<br> 生成空指针。</p></li><li><p>过去的程序还会用到一个名为NULL的预处理变量（preprocessor<br> variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。</p></li><li><p>2.6.3节（第68页）将稍微介绍一点关于预处理器的知识，现在只要<br> 知道预处理器是运行于编译过程之前的一段程序就可以了。预处理变量<br> 不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预<br> 处理变量而无须在前面加上std：：。</p></li><li><p>当用到一个预处理变量时，预处理器会自动地将它替换为实际值，<br> 因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在<br> 的C++程序最好使用nullptr，同时尽量避免使用NULL。</p></li><li><p>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0<br> 也不行。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pi <span class="token operator">=</span> zero<span class="token punctuation">;</span> <span class="token comment">// error: cannot assign an int to a pointer</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>建议：初始化所有指针</mark></p></li><li><p>使用未经初始化的指针是引发运行时错误的一大原因。</p></li><li><p>和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这<br> 一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p></li><li><p>在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间<br> 的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上<br> 的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又<br> 被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p></li><li><p>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定<br> 义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，<br> 这样程序就能检测并知道它没有指向任何具体的对象了。</p></li></ul><br><ul><li><p><mark>赋值和指针</mark></p></li><li><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节<br> 上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一<br> 旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引<br> 用都是访问它最初绑定的那个对象。</p></li><li><p>指针和它存放的地址之间就没有这种限制了。和其他任何变量（只<br> 要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向<br> 一个新的对象：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// pi is initialized but addresses no object</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// pi2 initialized to hold the address of i</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi3<span class="token punctuation">;</span> <span class="token comment">// if pi3 is defined inside a block, pi3 is uninitialized</span>
pi3 <span class="token operator">=</span> pi2<span class="token punctuation">;</span> <span class="token comment">// pi3 and pi2 address the same object, e.g., i</span>
pi2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// pi2 now addresses no object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了<br> 指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等<br> 号左侧的对象。当写出如下语句时，<br><code>pi = &amp;ival; // value in pi is changed; pi now points to ival</code></p></li><li><p>意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址<br> 值。相反的，如果写出如下语句，<br> 则＊pi（也就是指针pi指向的那个对象）发生改变。<br><code>*pi = 0; // value in ival is changed; pi is unchanged</code></p></li></ul><br><ul><li><mark>其他指针操作</mark></li><li>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算<br> 术值作为条件（参见2.1.2节，第32页）遵循的规则类似，如果指针的值<br> 是0，条件取false：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// pi is a valid, null pointer</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// pi2 is a valid pointer that holds the address of ival</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pi<span class="token punctuation">)</span> <span class="token comment">// pi has value 0, so condition evaluates as false</span>
 <span class="token comment">// ...</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pi2<span class="token punctuation">)</span> <span class="token comment">// pi2 points to ival, so it is not 0; the condition evaluates as true</span>
 <span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>任何非0指针对应的条件值都是true。</p></li><li><p>对于两个类型相同的合法指针，可以用相等操作符（==）或不相等<br> 操作符（！=）来比较它们，比较的结果是布尔类型。如果两个指针存<br> 放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的<br> 地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个<br> 对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针<br> 指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能<br> 出现这两个指针值相同的情况，即指针相等。</p></li><li><p>因为上述操作要用到指针的值，所以不论是作为条件出现还是参与<br> 比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都<br> 会引发不可预计的后果。</p></li><li><p>3.5.3节（第105页）将介绍更多关于指针的操作。</p></li></ul><br><ul><li><mark>void＊ 指针</mark></li><li>void＊是一种特殊的指针类型，可用于存放任意对象的地址。一个<br> void＊指针存放着一个地址，这一点和其他指针类似。不同的是，我们<br> 对该地址中到底是个什么类型的对象并不了解：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">double</span> obj <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">;</span>
<span class="token comment">// ok: void* can hold the address value of any data pointer type</span>
<span class="token keyword">void</span> <span class="token operator">*</span>pv <span class="token operator">=</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">;</span> <span class="token comment">// obj can be an object of any type</span>
pv <span class="token operator">=</span> pd<span class="token punctuation">;</span> <span class="token comment">// pv can hold a pointer to any type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>利用void＊指针能做的事儿比较有限：拿它和别的指针比较、作为<br> 函数的输入或输出，或者赋给另外一个void＊指针。不能直接操作void<br> ＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就<br> 无法确定能在这个对象上做哪些操作。</p></li><li><p>概括说来，以void＊的视角来看内存空间也就仅仅是内存空间，没<br> 办法访问内存空间中所存的对象，关于这点将在19.1.1节（第726页）有<br> 更详细的介绍，4.11.3节（第144页）将讲述获取void＊指针所存地址的<br> 方法。</p></li></ul><h3 id="_2-3-2节练习" tabindex="-1"><a class="header-anchor" href="#_2-3-2节练习" aria-hidden="true">#</a> 2.3.2节练习</h3><p>练习2.18：编写代码分别更改指针的值以及指针所指对象的值。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>

<span class="token comment">// change the value of a pointer.</span>
p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
<span class="token comment">// change the value to which the pointer points</span>
<span class="token operator">*</span>p2 <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.19：说明指针和引用的主要区别。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>引用是另一个对象的别名，而指针本身就是一个对象。
引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.20：请叙述下面这段代码的作用。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p1 <span class="token operator">*</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
让指针 pi 指向 i，然后将 i 的值重新赋值为 <span class="token number">42</span> <span class="token operator">*</span> <span class="token number">42</span> <span class="token punctuation">(</span><span class="token number">1764</span><span class="token punctuation">)</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.21：请解释下述定义。在这些定义中有非法的吗？如果有，为什么？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>\`<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\`

<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">double</span><span class="token operator">*</span> dp <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>

解：

<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> 非法。不能将一个指向 \`<span class="token keyword">double</span>\` 的指针指向 \`<span class="token keyword">int</span>\` 。
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> 非法。不能将 \`<span class="token keyword">int</span>\` 变量赋给指针。
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> 合法。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.22：假设p是一个int型指针，请说明下述代码的含义。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// ...</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// ...</span>

第一句判断 p 是不是一个空指针<span class="token punctuation">,</span> 
第二句判断 p 所指向的对象的值是不是为<span class="token number">0</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.23：给定指针p，你能知道它是否指向了一个合法的对象吗？如<br> 果能，叙述判断的思路；如果不能，也请说明原因。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>能，可以使用<span class="token keyword">try</span> <span class="token keyword">catch</span>的异常处理来分辨指针p是否指向一个合法的对象，但通过普通控制结构无法实现。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>练习2.24：在下面这段代码中为什么p合法而lp非法</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token operator">*</span>lp <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>

\`<span class="token keyword">void</span> <span class="token operator">*</span>\`是从C语言那里继承过来的，可以指向任何类型的对象。
而其他指针类型必须要与所指对象严格匹配。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-3-理解复合类型的声明" tabindex="-1"><a class="header-anchor" href="#_2-3-3-理解复合类型的声明" aria-hidden="true">#</a> 2.3.3　理解复合类型的声明</h3><ul><li>如前所述，变量的定义包括一个基本数据类型（base type）和一组<br> 声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明<br> 符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的<br> 变量：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// i is an int; p is a pointer to int; r is a reference to int</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明<br> 符的一部分罢了。</li></ul><br><ul><li><p><mark>定义多个变量</mark></p></li><li><p>经常有一种观点会误以为，在定义语句中，类型修饰符（＊或&amp;）<br> 作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之<br> 一是我们可以把空格写在类型修饰符和变量名中间：<br><code>int* p; // legal but might be misleading</code></p></li><li><p>我们说这种写法可能产生误导是因为int＊放在一起好像是这条语句<br> 中所有变量共同的类型一样。其实恰恰相反，基本数据类型是int而非int<br> ＊。＊仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生<br> 任何作用：<code>int* p1, p2; // p1 is a pointer to int; p2 is an int</code></p></li><li><p>涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量<br> 标识符写在一起：<code>int *p1, *p2; // both p1 and p2 are pointers to int</code></p></li><li><p>这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名<br> 写在一起，并且每条语句只定义一个变量：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">;</span> <span class="token comment">// p1 is a pointer to int</span>
<span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">;</span> <span class="token comment">// p2 is a pointer to int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这种形式着重强调本次声明定义了一种复合类型。</p></li><li><p>上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中<br> 的一种写法，不要总是变来变去。</p></li><li><p>本书采用第一种写法，将＊（或是&amp;）与变量名连在一起。</p></li></ul><br><ul><li><p><mark>指向指针的指针</mark></p></li><li><p>一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连<br> 写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存<br> 中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再<br> 存放到另一个指针当中。</p></li><li><p>通过＊的个数可以区分指针的级别。也就是说，＊＊表示指向指针<br> 的指针，＊＊＊表示指向指针的指针的指针，以此类推：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// pi points to an int</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ppi <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// ppi points to a pointer to an int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此处pi是指向int型数的指针，而ppi是指向int型指针的指针，下图描<br> 述了它们之间的关系。</p></li><li><p>解引用int型指针会得到一个int型的数，同样，解引用指向指针的指<br> 针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指<br> 针做两次解引用：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;The value of ival\\n&quot;</span>
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;direct value: &quot;</span> <span class="token operator">&lt;&lt;</span> ival <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\n&quot;</span>
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;indirect value: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pi <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\n&quot;</span>
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;doubly indirect value: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>ppi
 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>该程序使用三种不同的方式输出了变量ival的值：第一种直接输<br> 出；第二种通过int型指针pi输出；第三种两次解引用ppi，取得ival的值。</li></ul><br><ul><li><mark>指向指针的引用</mark></li><li>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是<br> 对象，所以存在对指针的引用：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// p is a pointer to int</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// r is a reference to the pointer p</span>
r <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span>
<span class="token operator">*</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// dereferencing r yields i, the object to which p points; changes i to 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定<br> 义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直<br> 接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型<br> 是什么，此例中的符号＊说明r引用的是一个指针。最后，声明的基本<br> 数据类型部分指出r引用的是一个int指针。</p></li><li><p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的<br> 真实含义。</p></li></ul><h3 id="_2-3-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-3-3节练习" aria-hidden="true">#</a> 2.3.3节练习</h3><p>练习2.25：说明下列变量的类型和值。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token operator">*</span> ip<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token operator">*</span> ip<span class="token punctuation">,</span> ip2<span class="token punctuation">;</span>

解：

<span class="token operator">-</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span> ip 是一个指向 <span class="token keyword">int</span> 的指针<span class="token punctuation">,</span> i 是一个 <span class="token keyword">int</span><span class="token punctuation">,</span> r 是 i 的引用。
<span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">:</span> i 是 <span class="token keyword">int</span> <span class="token punctuation">,</span> ip 是一个空指针。
<span class="token operator">-</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">:</span> ip 是一个指向 <span class="token keyword">int</span> 的指针<span class="token punctuation">,</span> ip2 是一个 <span class="token keyword">int</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-4-const限定符" tabindex="-1"><a class="header-anchor" href="#_2-4-const限定符" aria-hidden="true">#</a> 2.4 const限定符</h2><ul><li>有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定：</li><li>const int bufSize = 512; //输入缓冲区大小；</li><li>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误：bufSize = 512; //错误；试图向const对象写值。</li><li>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式：</li><li>const int i = get_size(); // //正确，运行时初始化；</li><li>const int j = 42; // 正确，编译时初始化；</li><li>const int k; // 错误；k是一个未经初始化的常量。</li></ul><br><ul><li><mark>初始化和const</mark></li><li>正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是只能在const类型的对象上执行不改变其内容的操作。例如，const int和普通的int一样都能参与算术运算，也都能转换成一个布尔值，等等。</li><li>在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：</li><li>int j = 42;</li><li>const int ci = i; //正确，i的数值被 拷贝给了 ci</li><li>int j = ci; // 正确，ci的数值被 拷贝给了 j</li><li>尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。</li></ul><br><ul><li><mark>默认状态下，const对象仅在文件内有效</mark></li><li>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： const int bufSize = 512; //输入缓冲区的大小；</li><li>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</li><li>为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</li><li>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。</li><li>解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：</li><li>extern const int bufSize = fcn(); //file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</li><li>extern const int bufSize; //与file_1.cc中定义的bufSize是同一个</li><li>如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。</li><li>file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。</li><li><mark>note::如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</mark></li></ul><br><ul><li><mark>2.4节练习</mark></li><li>下面哪些语句是合法的？如果不合法，请说明为什么？</li><li>const int buf; // 不合法, const 对象必须初始化</li><li>int cnt = 0; // 合法</li><li>const int sz = cnt; // 合法</li><li>++cnt; ++sz; // 不合法, const 对象不能被改变</li></ul><h3 id="_2-4-1-const的引用" tabindex="-1"><a class="header-anchor" href="#_2-4-1-const的引用" aria-hidden="true">#</a> 2.4.1 const的引用</h3><ul><li>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：</li><li>const int ci = 1024;</li><li>const int &amp;r1 = ci; //正确:引用及其对应的对象都是常量</li><li>r1 = 42; //错误: r1是对常量的引用</li><li>int &amp;r2 = ci; //错误: 试图让一个非常量引用指向一个常量对象</li><li>因为不允许直接为ci赋值，当然也就不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。</li></ul><br><ul><li><mark>术语：常量引用是对const的引用</mark></li><li>C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。</li><li>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这<br> 层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。</li></ul><br><ul><li><mark>初始化和对const的引用</mark></li><li>2.3.1节（第46页）提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：</li><li>int i = 42;</li><li>const int &amp;r1 = i; //允许将const int&amp;绑定到一个普通int对象上</li><li>const int &amp;r2 = 42; //正确:r1是一个常量引用</li><li>const int &amp;r3 = r1 * 2; //正确:r3是一个常量引用</li><li>int &amp;r4 = r1 * 2; //错误:r4是一个普通的非常量引用</li><li>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：</li><li>double dval = 3.14;</li><li>const int &amp;ri = dval;</li><li>此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：</li><li>const int temp = dval; //由双精度浮点数生成一个临时的整型常量</li><li>const int &amp;ri = temp; //让ri绑定这个临时量</li><li>在这种情况下，ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。</li><li>接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。</li></ul><br><ul><li><mark>对const的引用可能引用一个并非const的对象</mark></li><li>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：</li><li>int i = 42;</li><li>int &amp;r1 = i; //引用ri绑定对象i</li><li>const int &amp;r2 = i; //r2也绑定对象i，但是不允许通过r2修改i的值</li><li>r1 = 0; //r1并非常量，i的值修改为0</li><li>r2 = 0; //错误:r2是一个常量引用</li><li>r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改</li></ul><h3 id="_2-4-2-指针和const" tabindex="-1"><a class="header-anchor" href="#_2-4-2-指针和const" aria-hidden="true">#</a> 2.4.2　指针和const</h3><ul><li>与引用一样，也可以令指针指向常量或非常量。类似于常量引用<br> （参见2.4.1节，第54页），指向常量的指针（pointer to const）不能用<br> 于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量<br> 的指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// pi is const; its value may not be changed</span>
<span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// error: ptr is a plain pointer</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// ok: cptr may point to a double that is const</span>
<span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// error: cannot assign to *cptr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>2.3.2节（第47页）提到，指针的类型必须与其所指对象的类型一<br> 致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指<br> 向一个非常量对象：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// dval is a double; its value can be changed</span>
cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment">// ok: but can&#39;t change dval through cptr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是<br> 一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的<br> 值，而没有规定那个对象的值不能通过其他途径改变。</p></li><li><p>试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢<br> 了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</p></li></ul><br><ul><li><mark>const指针</mark></li><li>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针<br> 本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始<br> 化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变<br> 了。把＊放在const关键字之前用以说明指针是一个常量，这样的书写形<br> 式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> errNumb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> curErr <span class="token operator">=</span> <span class="token operator">&amp;</span>errNumb<span class="token punctuation">;</span> <span class="token comment">// curErr will always point to errNumb</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> pip <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// pip is a const pointer to a const object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如同2.3.3节（第52页）所讲的，要想弄清楚这些声明的含义最行之<br> 有效的办法是从右向左阅读。此例中，离curErr最近的符号是const，意<br> 味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确<br> 定。声明符中的下一个符号是＊，意思是curErr是一个常量指针。最<br> 后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对<br> 象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象<br> 是一个双精度浮点型常量。</p></li><li><p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的<br> 值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常<br> 量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址<br> 都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就<br> 完全可以用curErr去修改errNumb的值：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span>pip <span class="token operator">=</span> <span class="token number">2.72</span><span class="token punctuation">;</span> <span class="token comment">// error: pip is a pointer to const</span>
<span class="token comment">// if the object to which curErr points (i.e., errNumb) is nonzero</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>curErr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">errorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>curErr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ok: reset the value of the object to which curErr is bound</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-2节练习" tabindex="-1"><a class="header-anchor" href="#_2-4-2节练习" aria-hidden="true">#</a> 2.4.2节练习</h3><p>练习2.27：下面的哪些初始化是合法的？请说明原因。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 不合法, r 必须引用一个对象</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i2<span class="token punctuation">;</span>        <span class="token comment">// 合法，常量指针</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 合法</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>i2<span class="token punctuation">;</span>  <span class="token comment">// 合法</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i2<span class="token punctuation">;</span>        <span class="token comment">// 合法</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token keyword">const</span> r2<span class="token punctuation">;</span>        <span class="token comment">// 不合法, r2 是引用, 引用自带顶层 const, 第二个const写法多余但合法, 但引用需要初始化.</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> i2 <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment">// 合法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.28：说明下面的这些定义是什么意思，挑出其中不合法的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">const</span> cp<span class="token punctuation">;</span>       <span class="token comment">// 不合法, const 指针必须初始化</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">const</span> p2<span class="token punctuation">;</span>     <span class="token comment">// 不合法, const 指针必须初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ic<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> ic<span class="token punctuation">;</span>  <span class="token comment">// 不合法, const int 必须初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3<span class="token punctuation">;</span>    <span class="token comment">// 不合法, const 指针必须初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>           <span class="token comment">// 合法. 一个指针，指向 const int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.29：假设已有上一个练习中定义的那些变量，则下面的哪些语句<br> 是合法的？请说明原因。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>i <span class="token operator">=</span> ic<span class="token punctuation">;</span>     <span class="token comment">// 合法, 常量赋值给普通变量</span>
p1 <span class="token operator">=</span> p3<span class="token punctuation">;</span>    <span class="token comment">// 不合法, p3 是const指针不能赋值给普通指针</span>
p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>ic<span class="token punctuation">;</span>   <span class="token comment">// 不合法, 普通指针不能指向常量</span>
p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>ic<span class="token punctuation">;</span>   <span class="token comment">// 不合法, p3 是常量指针且指向常量, 故p3 不能被修改, 本句赋值语句正在修改</span>
p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token comment">// 不合法, p2是常量指针, 有顶层const, 不能被修改</span>
ic <span class="token operator">=</span> <span class="token operator">*</span>p3<span class="token punctuation">;</span>   <span class="token comment">// 不合法, 对 p3 取值后是一个 int 然后赋值给 ic, 但ic是常量不能被修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-3-顶层const" tabindex="-1"><a class="header-anchor" href="#_2-4-3-顶层const" aria-hidden="true">#</a> 2.4.3　顶层const</h3><ul><li><p>如前所述，指针本身是一个对象，它又可以指向另外一个对象。因<br> 此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互<br> 独立的问题。用名词顶层const（top-level const）表示指针本身是个常<br> 量，而用名词底层const（low-level const）表示指针所指的对象是一个<br> 常量。</p></li><li><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数<br> 据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等<br> 复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层<br> const也可以是底层const，这一点和其他类型相比区别明显：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// pi is const; its value may not be changed</span>
<span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// error: ptr is a plain pointer</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// ok: cptr may point to a double that is const</span>
<span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// error: cannot assign to *cptr</span>

<span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// dval is a double; its value can be changed</span>
cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment">// ok: but can&#39;t change dval through cptr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当执行对象的拷贝操作时，常量是顶层const还是底层const区别明<br> 显。其中，顶层const不受什么影响：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> dval<span class="token punctuation">;</span> <span class="token comment">// create a temporary const int from the double</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>ri <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token comment">// bind ri to that temporary</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对<br> 象是否是常量都没什么影响。</p></li><li><p>另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作<br> 时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的<br> 数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不<br> 行:</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// error: p3 has a low-level const but p doesn&#39;t</span>
p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// ok: p2 has the same low-level const qualification as p3</span>
p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// ok: we can convert int* to const int*</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t bind an ordinary int&amp; to a const int object</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// ok: can bind const int&amp; to plain int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶<br> 层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去<br> 初始化p，因为p指向的是一个普通的（非常量）整数。另一方面，p3的<br> 值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个<br> 常量指针（顶层const），仅就这次赋值而言不会有什么影响。</li></ul><h3 id="_2-4-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-4-3节练习" aria-hidden="true">#</a> 2.4.3节练习</h3><p>练习2.30：对于下面的这些语句，请说明对象被声明成了顶层const还是底层const？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">int</span> v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> v2<span class="token punctuation">;</span>


解：

v2 是顶层<span class="token keyword">const</span>，p2 是底层<span class="token keyword">const</span>，p3 既是顶层<span class="token keyword">const</span>又是底层<span class="token keyword">const</span>，r2 是底层<span class="token keyword">const</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.31：假设已有上一个练习中所做的那些声明，则下面的哪些语句<br> 是合法的？请说明顶层const和底层const在每个例子中有何体现。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>r1 <span class="token operator">=</span> v2<span class="token punctuation">;</span> <span class="token comment">// 合法, 顶层const在拷贝时不受影响</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">// 不合法, p2 是底层const，如果要拷贝必须要求 p1 也是底层const</span>
p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 合法, int* 可以转换成const int*</span>
p1 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// 不合法, p3 是一个底层const，p1 不是</span>
p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// 合法, p2 和 p3 都是底层const，拷贝时忽略掉顶层const</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-4-constexpr和常量表达式" tabindex="-1"><a class="header-anchor" href="#_2-4-4-constexpr和常量表达式" aria-hidden="true">#</a> 2.4.4 constexpr和常量表达式</h3><ul><li><p>常量表达式（const expression）是指值不会改变并且在编译过程就<br> 能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达<br> 式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几<br> 种情况下是要用到常量表达式的。</p></li><li><p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值<br> 共同决定，例如：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> max_files <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// max_files is a constant expression</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> max_files <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// limit is a constant expression</span>
<span class="token keyword">int</span> staff_size <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">// staff_size is not a constant expression</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sz is not a constant expression</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是<br> 一个普通int而非const int，所以它不属于常量表达式。另一方面，尽管<br> sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是<br> 常量表达式。</li></ul><br><ul><li><p><mark>constexpr变量</mark></p></li><li><p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是<br> 不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们<br> 认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初<br> 始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义<br> 和使用根本就是两回事儿。</p></li><li><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器<br> 来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是<br> 一个常量，而且必须用常量表达式初始化：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 20 is a constant expression</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> mf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// mf + 1 is a constant expression</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok only if size is a constexpr function</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.5.2<br> 节（第214页）将要介绍的，新标准允许定义一种特殊的constexpr函<br> 数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能<br> 用constexpr函数去初始化constexpr变量了。</p></li><li><p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p></li></ul><br><ul><li><p><mark>字面值类型</mark></p></li><li><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时<br> 用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易<br> 见、容易得到，就把它们称为“字面值类型”（literal type）。</p></li><li><p>到目前为止接触过的数据类型中，算术类型、引用和指针都属于字<br> 面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类<br> 型，也就不能被定义成constexpr。其他一些字面值类型将在7.5.6节（第<br> 267页）和19.3节（第736页）介绍。</p></li><li><p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格<br> 限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某<br> 个固定地址中的对象。</p></li><li><p>6.1.1节（第184页）将要提到，函数体内定义的变量一般来说并非<br> 存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，<br> 定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr<br> 指针。同样是在6.1.1节（第185页）中还将提到，允许函数定义一类有<br> 效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样<br> 也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr<br> 指针也能指向这样的变量。</p></li></ul><br><ul><li><mark>指针和constexpr</mark></li><li>必须明确一点，在constexpr声明中如果定义了一个指针，限定符<br> constexpr仅对指针有效，与指针所指的对象无关：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// p is a pointer to a const int</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// q is a const pointer to int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指<br> 针，其中的关键在于constexpr把它所定义的对象置为了顶层const（参见<br> 2.4.3节，第57页）。</p></li><li><p>与其他常量指针类似，constexpr指针既可以指向常量也可以指向一<br> 个非常量：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// np is a constant pointer to int that is null</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// type of i is const int</span>
<span class="token comment">// i and j must be defined outside any function</span>
<span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// p is a constant pointer to the const int i</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>j<span class="token punctuation">;</span> <span class="token comment">// p1 is a constant pointer to the int j</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-4节练习" tabindex="-1"><a class="header-anchor" href="#_2-4-4节练习" aria-hidden="true">#</a> 2.4.4节练习</h3><ul><li>练习2.32：下面的代码是否合法？如果非法，请设法将其修改正确。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> null <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> null<span class="token punctuation">;</span>

解：

非法，即使<span class="token keyword">int</span>的值恰好是<span class="token number">0</span>，也不能直接给指针赋值<span class="token keyword">int</span>变量。应改为

<span class="token keyword">int</span> null <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>null<span class="token punctuation">;</span>

而且应该注意到，null都是小写，并不是关键字或者预处理变量。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-5-处理类型" tabindex="-1"><a class="header-anchor" href="#_2-5-处理类型" aria-hidden="true">#</a> 2.5　处理类型</h2><ul><li>随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。一是一些类型难于“拼写”，它们的名字既难记又容易写错，还无法明确体现其真实目的和含义。二是有时候根本搞不清到底需要的类型是什么，程序员不得不回过头去从程序的上下文中寻求帮助。</li></ul><h3 id="_2-5-1-类型别名" tabindex="-1"><a class="header-anchor" href="#_2-5-1-类型别名" aria-hidden="true">#</a> 2.5.1　类型别名</h3><ul><li>类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。</li><li>有两种方法可用于定义类型别名。传统的方法是使用关键字typedef： <ul><li>typedef double wages; //wages是double的同义词</li><li>typedef wages base, <em>p; // base是double的同义词，p是double</em>的同义词</li></ul></li><li>其中，关键字typedef作为声明语句中的基本数据类型（参见2.3节，第45页）的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</li><li>新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：</li><li>using SI = Sales_item; // SI是 Sales_item 的同义词；</li><li>这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</li><li>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：</li><li>wages hourly, weekly; //等价于 double hourly,weekly;</li><li>SI item; //等价于 Sales_item item;</li></ul><br><ul><li><mark>指针、常量和类型别名</mark></li><li>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char＊的别名：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstring<span class="token punctuation">;</span>
<span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// cstr is a constant pointer to char</span>
<span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span> <span class="token comment">// ps is a pointer to a constant pointer to char</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>上述两条声明语句的基本数据类型都是const pstring，和过去一样，<br> const是对给定类型的修饰。pstring实际上是指向char的指针，因此，<br> const pstring就是指向char的常量指针，而非指向常量字符的指针。</p></li><li><p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把<br> 类型别名替换成它本来的样子，以理解该语句的含义：<br><code>const char *cstr = 0; // wrong interpretation of const pstring cstr</code></p></li><li><p>再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基<br> 本数据类型是指针。可是用char＊重写了声明语句后，数据类型就变成<br> 了char，＊成为了声明符的一部分。这样改写的结果是，const char成了<br> 基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char<br> 的常量指针，改写后的形式则声明了一个指向const char的指针。</p></li></ul><h3 id="_2-5-2-auto类型说明符" tabindex="-1"><a class="header-anchor" href="#_2-5-2-auto类型说明符" aria-hidden="true">#</a> 2.5.2 auto类型说明符</h3><ul><li>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时<br> 候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚<br> 至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明<br> 符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只<br> 对应一种特定类型的说明符（比如double）不同，auto让编译器通过初<br> 始值来推算变量的类型。显然，auto定义的变量必须有初始值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// the type of item is deduced from the type of the result of adding val1 and val2</span>
<span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span> <span class="token comment">// item initialized to the result of val1 + val2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此处编译器将根据val1和val2相加的结果来推断item的类型。如果<br> val1和val2是类Sales_item（参见1.5节，第17页）的对象，则item的类型<br> 就是Sales_item；如果这两个变量的类型是double，则item的类型就是<br> double，以此类推。</p></li><li><p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能<br> 有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必<br> 须一样：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// ok: i is int and p is a pointer to int</span>
<span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// error: inconsistent types for sz and pi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>复合类型、常量和auto</mark></p></li><li><p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，<br> 编译器会适当地改变结果类型使其更符合初始化规则。</p></li><li><p>首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别<br> 是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此<br> 时编译器以引用对象的类型作为auto的类型：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">auto</span> a <span class="token operator">=</span> r<span class="token punctuation">;</span> <span class="token comment">// a is an int (r is an alias for i, which has type int)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其次，auto一般会忽略掉顶层const（参见2.4.3节，第57页），同时<br> 底层const则会保留下来，比如当初始值是一个指向常量的指针时：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// b is an int (top-level const in ci is dropped)</span>
<span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span> <span class="token comment">// c is an int (cr is an alias for ci whose const is top-level)</span>
<span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// d is an int*(&amp; of an int object is int*)</span>
<span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment">// e is const int*(&amp; of a const object is low-level const)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：<br><code>const auto f = ci; // deduced type of ci is int; f has type const int</code></p></li><li><p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// g is a const int&amp; that is bound to ci</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// error: we can&#39;t bind a plain reference to a literal</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// ok: we can bind a const reference to a literal</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保<br> 留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不<br> 是顶层常量了。</p></li><li><p>要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声<br> 明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> k <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">&amp;</span>l <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// k is int; l is int&amp;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment">// m is a const int&amp;;p is a pointer to const int</span>
<span class="token comment">// error: type deduced from i is int; type deduced from &amp;ci is const int</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-2节练习" tabindex="-1"><a class="header-anchor" href="#_2-5-2节练习" aria-hidden="true">#</a> 2.5.2节练习</h3><ul><li>练习2.33：利用本节定义的变量，判断下列语句的运行结果。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> c <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
d <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> e <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> g <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.34：基于上一个练习中的变量和语句编写一段程序，输出赋值前<br> 后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示<br> 例直到你明白错在何处为止。</li><li>练习2.35：判断下列定义推断出的类型是什么，然后编写程序进行验证。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>k <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token keyword">auto</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> j2 <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k2 <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-3-decltype类型指示符" tabindex="-1"><a class="header-anchor" href="#_2-5-3-decltype类型指示符" aria-hidden="true">#</a> 2.5.3 decltype类型指示符</h3><ul><li><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的<br> 类型，但是不想用该表达式的值初始化变量。为了满足这一要求，<br> C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返<br> 回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类<br> 型，却不实际计算表达式的值：<br><code>decltype(f()) sum = x; // sum has whatever type f returns</code></p></li><li><p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型<br> 作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是<br> 假如f被调用的话将会返回的那个类型。</p></li><li><p>decltype处理顶层const和引用的方式与auto有些许不同。如果<br> decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括<br> 顶层const和引用在内）：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// x has type const int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// y has type const int&amp; and is bound to x</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span> <span class="token comment">// error: z is a reference and must be initialized</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为<br> 引用的z必须被初始化。</p></li><li><p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用<br> 在decltype处是一个例外。</p></li></ul><br><ul><li><mark>decltype和引用</mark></li><li>如果decltype使用的表达式不是一个变量，则decltype返回表达式结<br> 果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向<br> decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表<br> 达式的结果对象能作为一条赋值语句的左值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// decltype of an expression can be a reference type</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span> <span class="token comment">// ok: addition yields an int; b is an (uninitialized) int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c<span class="token punctuation">;</span> <span class="token comment">// error: c is int&amp; and must be initialized</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因为r是一个引用，因此decltype（r）的结果是引用类型。如果想让<br> 结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这<br> 个表达式的结果将是一个具体值而非一个引用。</p></li><li><p>另一方面，如果表达式的内容是解引用操作，则decltype将得到引<br> 用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对<br> 象，而且还能给这个对象赋值。因此，decltype（＊p）的结果类型就是<br> int&amp;，而非int。</p></li><li><p>decltype和auto的另一处重要区别是，decltype的结果类型与表达式<br> 形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式<br> 来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不<br> 同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该<br> 变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成<br> 是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以<br> 这样的decltype就会得到引用类型：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// decltype of a parenthesized variable is always a reference</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span> <span class="token comment">// error: d is int&amp; and must be initialized</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span> <span class="token comment">// ok: e is an (uninitialized) int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>切记：decltype（（variable））（注意是双层括号）的结果永远是引用，而<br> decltype（variable）结果只有当variable本身就是一个引用时才是引用。</li></ul><h3 id="_2-5-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-5-3节练习" aria-hidden="true">#</a> 2.5.3节练习</h3><ul><li>练习2.36：关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token operator">++</span>c<span class="token punctuation">;</span>
<span class="token operator">++</span>d<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值<br> 的类型。也就是说，如果i是int，则表达式i=x的类型是int&amp;。根据这一<br> 特点，请指出下面的代码中每一个变量的类型和值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a <span class="token operator">=</span> b<span class="token punctuation">)</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习2.38：说明由decltype指定类型和由auto指定类型有何区别。请举出<br> 一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，<br> decltype指定的类型与auto指定的类型不一样。</li></ul><h2 id="_2-6-自定义数据结构" tabindex="-1"><a class="header-anchor" href="#_2-6-自定义数据结构" aria-hidden="true">#</a> 2.6　自定义数据结构</h2><ul><li><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来<br> 然后使用它们的策略和方法。举一个例子，我们的Sales_item类把书本<br> 的ISBN编号、售出量及销售收入等数据组织在了一起，并且提供诸如<br> isbn函数、&gt;&gt;、&lt;&lt;、+、+=等运算在内的一系列操作，Sales_item类就是<br> 一个数据结构。</p></li><li><p>C++语言允许用户以类的形式自定义数据类型，而库类型string、<br> istream、ostream等也都是以类的形式定义的，就像第1章的Sales_item类<br> 型一样。C++语言对类的支持甚多，事实上本书的第Ⅲ部分和第Ⅳ部分<br> 都将大篇幅地介绍与类有关的知识。尽管Sales_item类非常简单，但是<br> 要想给出它的完整定义可在第14章介绍自定义运算符之后。</p></li></ul><h3 id="_2-6-1-定义sales-data类型" tabindex="-1"><a class="header-anchor" href="#_2-6-1-定义sales-data类型" aria-hidden="true">#</a> 2.6.1　定义Sales_data类型</h3><ul><li><p>尽管我们还写不出完整的Sales_item类，但是可以尝试着把那些数<br> 据元素组织到一起形成一个简单点儿的类。初步的想法是用户能直接访<br> 问其中的数据元素，也能实现一些基本的操作。</p></li><li><p>既然我们筹划的这个数据结构不带有任何运算功能，不妨把它命名<br> 为Sales_data以示与Sales_item的区别。Sales_data初步定义如下：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Sales_data</span> <span class="token punctuation">{</span>
 std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分<br> 可以为空）。类体由花括号包围形成了一个新的作用域（参见2.2.4节，<br> 第43页）。类内部定义的名字必须唯一，但是可以与类外部定义的名字<br> 重复。</p></li><li><p>类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后<br> 面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Sales_data</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> accum<span class="token punctuation">,</span> trans<span class="token punctuation">,</span> <span class="token operator">*</span>salesptr<span class="token punctuation">;</span>
<span class="token comment">// equivalent, but better way to define these objects</span>
<span class="token keyword">struct</span> <span class="token class-name">Sales_data</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Sales_data accum<span class="token punctuation">,</span> trans<span class="token punctuation">,</span> <span class="token operator">*</span>salesptr<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>分号表示声明符（通常为空）的结束。一般来说，最好不要把对象<br> 的定义和类的定义放在一起。这么做无异于把两种不同实体的定义混在<br> 了一条语句里，一会儿定义类，一会儿又定义变量，显然这是一种不被<br> 建议的行为。</p></li><li><p><mark>很多新手程序员经常忘了在类定义的最后加上分号。</mark></p></li></ul><br><ul><li><p><mark>类数据成员</mark></p></li><li><p>类体定义类的成员，我们的类只有数据成员（data member）。类<br> 的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成<br> 员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。</p></li><li><p>定义数据成员的方法和定义普通变量一样：首先说明一个基本类<br> 型，随后紧跟一个或多个声明符。我们的类有3个数据成员：一个名为<br> bookNo的string成员、一个名为units_sold的unsigned成员和一个名为<br> revenue的double成员。每个Sales_data的对象都将包括这3个数据成员。</p></li><li><p>C++11新标准规定，可以为数据成员提供一个类内初始值（in-class<br> initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初<br> 始值的成员将被默认初始化（参见2.2.1节，第40页）。因此当定义<br> Sales_data的对象时，units_sold和revenue都将初始化为0，bookNo将初<br> 始化为空字符串。</p></li><li><p>对类内初始值的限制与之前（参见2.2.1节，第39页）介绍的类似：<br> 或者放在花括号里，或者放在等号右边，记住不能使用圆括号。</p></li><li><p>7.2节（第240页）将要介绍，用户可以使用C++语言提供的另外一<br> 个关键字class来定义自己的数据结构，到时也将说明现在我们使用struct<br> 的原因。在第7章学习与class有关的知识之前，建议读者继续使用struct<br> 定义自己的数据类型。</p></li></ul><h3 id="_2-6-1节练习" tabindex="-1"><a class="header-anchor" href="#_2-6-1节练习" aria-hidden="true">#</a> 2.6.1节练习</h3><p>练习2.39：编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的<br> 分号会发生什么情况？记录下相关信息，以后可能会有用。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token comment">/* empty */</span> <span class="token punctuation">}</span> <span class="token comment">// Note: no semicolon</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
提示应输入分号。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习2.40：根据自己的理解写出Sales_data类，最好与书中的例子有所区别</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Sale_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string bookName<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-2-使用sales-data类" tabindex="-1"><a class="header-anchor" href="#_2-6-2-使用sales-data类" aria-hidden="true">#</a> 2.6.2　使用Sales_data类</h3><ul><li><p>和Sales_item类不同的是，我们自定义的Sales_data类没有提供任何<br> 操作，Sales_data类的使用者如果想执行什么操作就必须自己动手实<br> 现。例如，我们将参照1.5.2节（第20页）的例子写一段程序实现求两次<br> 交易相加结果的功能。程序的输入是下面这两条交易记录：<br> 0-201-78345-X 3 20.00<br> 0-201-78345-X 2 25.00<br> 每笔交易记录着图书的ISBN编号、售出数量和售出单价。</p></li><li><p><mark>添加两个Sales_data对象</mark></p></li><li><p>因为Sales_data类没有提供任何操作，所以我们必须自己编码实现<br> 输入、输出和相加的功能。假设已知Sales_data类定义于Sales_data.h文<br> 件内，2.6.3节（第 页）将详细介绍定义头文件的方法。</p></li><li><p>因为程序比较长，所以接下来分成几部分介绍。总的来说，程序的<br> 结构如下:</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;Sales_data.h&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 Sales_data data1<span class="token punctuation">,</span> data2<span class="token punctuation">;</span>
 <span class="token comment">// code to read into data1 and data2</span>
 <span class="token comment">// code to check whether data1 and data2 have the same ISBN</span>
 <span class="token comment">// and if so print the sum of data1 and data2</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>和原来的程序一样，先把所需的头文件包含进来并且定义变量用于<br> 接受输入。和Sales_item类不同的是，新程序还包含了string头文件，因<br> 为我们的代码中将用到string类型的成员变量bookNo。</li></ul><br><ul><li><mark>Sales_data对象读入数据</mark></li><li>第3章和第10章将详细介绍string类型的细节，在此之前，我们先了<br> 解一点儿关于string的知识以便定义和使用我们的ISBN成员。string类型<br> 其实就是字符的序列，它的操作有&gt;&gt;、&lt;&lt;和==等，功能分别是读入字<br> 符串、写出字符串和比较字符串。这样我们就能书写代码读入第一笔交<br> 易了：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// price per book, used to calculate total revenue</span>
<span class="token comment">// read the first transactions: ISBN, number of books sold, price per book</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> data1<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> data1<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price<span class="token punctuation">;</span>
<span class="token comment">// calculate total revenue from price and units_sold</span>
data1<span class="token punctuation">.</span>revenue <span class="token operator">=</span> data1<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>交易信息记录的是书售出的单价，而数据结构存储的是一次交易的<br> 销售收入，因此需要将单价读入到double变量price，然后再计算销售收<br> 入revenue。输入语句</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> data1<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> data1<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>使用点操作符（参见1.5.2节，第20页）读入对象data1的bookNo成<br> 员和units_sold成员。</p></li><li><p>最后一条语句把data1.units_sold和price的乘积赋值给data1的revenue成员。</p></li><li><p>接下来程序重复上述过程读入对象data2的数据：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// read the second transaction</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> data2<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> data2<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price<span class="token punctuation">;</span>
data2<span class="token punctuation">.</span>revenue <span class="token operator">=</span> data2<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>输出两个Sales_data对象的和</mark></li><li>剩下的工作就是检查两笔交易涉及的ISBN编号是否相同了。如果<br> 相同输出它们的和，否则输出一条报错信息：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>data1<span class="token punctuation">.</span>bookNo <span class="token operator">==</span> data2<span class="token punctuation">.</span>bookNo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">unsigned</span> totalCnt <span class="token operator">=</span> data1<span class="token punctuation">.</span>units_sold <span class="token operator">+</span> data2<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
 <span class="token keyword">double</span> totalRevenue <span class="token operator">=</span> data1<span class="token punctuation">.</span>revenue <span class="token operator">+</span> data2<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
 <span class="token comment">// print: ISBN, total sold, total revenue, average price per book</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> data1<span class="token punctuation">.</span>bookNo <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> totalCnt
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> totalRevenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>totalCnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> totalRevenue<span class="token operator">/</span>totalCnt <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">else</span>
 std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;(no sales)&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// indicate success</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// transactions weren&#39;t for the same ISBN</span>
 std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Data must refer to the same ISBN&quot;</span>
 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// indicate failure</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在第一个if语句中比较了data1和data2的bookNo成员是否相同。如果<br> 相同则执行第一个if语句花括号内的操作，首先计算units_sold的和并赋<br> 给变量totalCnt，然后计算revenue的和并赋给变量totalRevenue，输出这<br> 些值。接下来检查是否确实售出了书籍，如果是，计算并输出每本书的<br> 平均价格；如果售量为零，输出一条相应的信息。</li></ul><h3 id="_2-6-2节练习" tabindex="-1"><a class="header-anchor" href="#_2-6-2节练习" aria-hidden="true">#</a> 2.6.2节练习</h3><ul><li>练习2.41：使用你自己的Sales_data类重写1.5.1节（第20页）、1.5.2节<br> （第21页）和1.6节（第22页）的练习。眼下先把Sales_data类的定义和<br> main函数放在同一个文件里。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 1.5.1</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">Sale_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Sale_data book<span class="token punctuation">;</span>
    <span class="token keyword">double</span> price<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> book<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> book<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price<span class="token punctuation">;</span>
    book<span class="token punctuation">.</span>revenue <span class="token operator">=</span> book<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> book<span class="token punctuation">.</span>bookNo <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> book<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> book<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> price<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>



<span class="token comment">// 1.5.2</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">Sale_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Sale_data book1<span class="token punctuation">,</span> book2<span class="token punctuation">;</span>
    <span class="token keyword">double</span> price1<span class="token punctuation">,</span> price2<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> book1<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> book1<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price1<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> book2<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> book2<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> price2<span class="token punctuation">;</span>
    book1<span class="token punctuation">.</span>revenue <span class="token operator">=</span> book1<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price1<span class="token punctuation">;</span>
    book2<span class="token punctuation">.</span>revenue <span class="token operator">=</span> book2<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price2<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>book1<span class="token punctuation">.</span>bookNo <span class="token operator">==</span> book2<span class="token punctuation">.</span>bookNo<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> totalCnt <span class="token operator">=</span> book1<span class="token punctuation">.</span>units_sold <span class="token operator">+</span> book2<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
        <span class="token keyword">double</span> totalRevenue <span class="token operator">=</span> book1<span class="token punctuation">.</span>revenue <span class="token operator">+</span> book2<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> book1<span class="token punctuation">.</span>bookNo <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> totalCnt <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> totalRevenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>totalCnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> totalRevenue <span class="token operator">/</span> totalCnt <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;(no sales)&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Data must refer to same ISBN&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// indicate failure</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>



<span class="token comment">// 1.6</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">Sale_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Sale_data total<span class="token punctuation">;</span>
    <span class="token keyword">double</span> totalPrice<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> total<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> totalPrice<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        total<span class="token punctuation">.</span>revenue <span class="token operator">=</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> totalPrice<span class="token punctuation">;</span>

        Sale_data trans<span class="token punctuation">;</span>
        <span class="token keyword">double</span> transPrice<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> trans<span class="token punctuation">.</span>bookNo <span class="token operator">&gt;&gt;</span> trans<span class="token punctuation">.</span>units_sold <span class="token operator">&gt;&gt;</span> transPrice<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            trans<span class="token punctuation">.</span>revenue <span class="token operator">=</span> trans<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> transPrice<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">.</span>bookNo <span class="token operator">==</span> trans<span class="token punctuation">.</span>bookNo<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                total<span class="token punctuation">.</span>units_sold <span class="token operator">+=</span> trans<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
                total<span class="token punctuation">.</span>revenue <span class="token operator">+=</span> trans<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>bookNo <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">.</span>units_sold <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>revenue <span class="token operator">/</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;(no sales)&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

                total<span class="token punctuation">.</span>bookNo <span class="token operator">=</span> trans<span class="token punctuation">.</span>bookNo<span class="token punctuation">;</span>
                total<span class="token punctuation">.</span>units_sold <span class="token operator">=</span> trans<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
                total<span class="token punctuation">.</span>revenue <span class="token operator">=</span> trans<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>bookNo <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">.</span>units_sold <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total<span class="token punctuation">.</span>revenue <span class="token operator">/</span> total<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;(no sales)&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;No data?!&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// indicate failure</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-3-编写自己的头文件" tabindex="-1"><a class="header-anchor" href="#_2-6-3-编写自己的头文件" aria-hidden="true">#</a> 2.6.3　编写自己的头文件</h3><ul><li><p>尽管如19.7节（第754页）所讲可以在函数体内定义类，但是这样<br> 的类毕竟受到了一些限制。所以，类一般都不定义在函数体内。当在函<br> 数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。<br> 而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。</p></li><li><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而<br> 且类所在头文件的名字应与类的名字一样。例如，库类型string在名为<br> string的头文件中定义。又如，我们应该把Sales_data类定义在名为<br> Sales_data.h的头文件中。(这个倒是感觉不是很必要)</p></li><li><p>头文件通常包含那些只能被定义一次的实体，如类、const和<br> constexpr变量（参见2.4节，第54页）等。头文件也经常用到其他头文件<br> 的功能。例如，我们的Sales_data类包含有一个string成员，所以<br> Sales_data.h必须包含string.h头文件。同时，使用Sales_data类的程序为<br> 了能操作bookNo成员需要再一次包含string.h头文件。这样，事实上使<br> 用Sales_data类的程序就先后两次包含了string.h头文件：一次是直接包<br> 含的，另有一次是随着包含Sales_data.h被隐式地包含进来的。有必要在<br> 书写头文件时做适当处理，使其遇到多次包含的情况也能安全和正常地<br> 工作。</p></li><li><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p></li></ul><br><ul><li><p><mark>预处理器概述</mark></p></li><li><p>确保头文件多次包含仍能安全工作的常用技术是预处理器<br> （preprocessor），它由C++语言从C语言继承而来。预处理器是在编译<br> 之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到<br> 了一项预处理功能#include，当预处理器看到#include标记时就会用指定<br> 的头文件的内容代替#include。</p></li><li><p>C++程序还会用到的一项预处理功能是头文件保护符（header<br> guard），头文件保护符依赖于预处理变量（参见2.3.2节，第48页）。<br> 预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定<br> 为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已<br> 经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定<br> 义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为<br> 止。(防止多次编译？)</p></li><li><p>使用这些功能就能有效地防止重复包含的发生：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">SALES_DATA_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SALES_DATA_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">Sales_data</span> <span class="token punctuation">{</span>
 std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺<br> 序执行后面的操作直至遇到#endif为止。此时，预处理变量<br> SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我<br> 们的程序中来。后面如果再一次包含Sales_data.h，则#ifndef的检查结果<br> 将为假，编译器将忽略#ifndef到#endif之间的部分。</p></li><li><p><mark>预处理变量无视C++语言中关于作用域的规则。</mark></p></li><li><p>整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法<br> 是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了<br> 避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p></li><li><p>头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头<br> 文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底<br> 需不需要。</p></li></ul><h3 id="_2-6-3节练习" tabindex="-1"><a class="header-anchor" href="#_2-6-3节练习" aria-hidden="true">#</a> 2.6.3节练习</h3><p>练习2.42：根据你自己的理解重写一个Sales_data.h头文件，并以此为基<br> 础重做2.6.2节（第67页）的练习。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><ul><li><p>类型是C++编程的基础。</p></li><li><p><mark>类型规定了其对象的存储要求(很多事情以存储的角度思考)和所能执行的操作</mark>。<br> C++语言提供了一套基础内置类型，如int和char等，这些类型与实现它们的机器硬件密<br> 切相关。类型分为非常量和常量，一个常量对象必须初始化，而且一旦<br> 初始化其值就不能再改变。此外，还可以定义复合类型，如指针和引用<br> 等。复合类型的定义以其他类型为基础。</p></li><li><p>C++语言允许用户以类的形式自定义类型。C++库通过类提供了一<br> 套高级抽象类型，如输入输出和string等。</p></li></ul><h2 id="术语表" tabindex="-1"><a class="header-anchor" href="#术语表" aria-hidden="true">#</a> 术语表</h2><ul><li><p>地址（address）是一个数字，根据它可以找到内存中的一个字节。</p></li><li><p>别名声明（alias declaration）为另外一种类型定义一个同义词：使<br> 用“名字=类型”的格式将名字作为该类型的同义词。</p></li><li><p>算术类型（arithmetic type） 布尔值、字符、整数、浮点数等内置类型。</p></li><li><p>数组（array）是一种数据结构，存放着一组未命名的对象，可以<br> 通过索引来访问这些对象。3.5节将详细介绍数组的知识。</p></li><li><p>auto 是一个类型说明符，通过变量的初始值来推断变量的类型。</p></li><li><p>基本类型（base type）是类型说明符，可用const修饰，在声明语句<br> 中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构<br> 建声明符。</p></li><li><p>绑定（bind）令某个名字与给定的实体关联在一起，使用该名字也<br> 就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。</p></li><li><p>字节（byte）内存中可寻址的最小单元，大多数机器的字节占8位。</p></li><li><p>类成员（class member）类的组成部分。</p></li><li><p>复合类型（compound type）是一种类型，它的定义以其他类型为基础。</p></li><li><p>const是一种类型修饰符，用于说明永不改变的对象。const对象一<br> 旦定义就无法再赋新值，所以必须初始化。</p></li><li><p>常量指针（const pointer）是一种指针，它的值永不改变。</p></li><li><p>常量引用（const reference）是一种习惯叫法，含义是指向常量的引用。</p></li><li><p>常量表达式（const expression）能在编译时计算并获取结果的表达式。</p></li><li><p>constexpr是一种函数，用于代表一条常量表达式。6.5.2节（第214<br> 页）将介绍constexpr函数。</p></li><li><p>转换（conversion）一种类型的值转变成另外一种类型值的过程。</p></li><li><p>C++语言支持内置类型之间的转换。</p></li><li><p>数据成员（data member）组成对象的数据元素，类的每个对象都<br> 有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。</p></li><li><p>声明（declaration）声称存在一个变量、函数或是别处定义的类<br> 型。名字必须在定义或声明之后才能使用。</p></li><li><p>声明符（declarator）是声明的一部分，包括被定义的名字和类型<br> 修饰符，其中类型修饰符可以有也可以没有。</p></li><li><p>decltype是一个类型说明符，从变量或表达式推断得到类型。</p></li><li><p>默认初始化（default initialization）当对象未被显式地赋予初始值<br> 时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局</p></li><li><p>作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。</p></li><li><p>定义（definition）为某一特定类型的变量申请存储空间，可以选择<br> 初始化该变量。名字必须在定义或声明之后才能使用。</p></li><li><p>转义序列（escape sequence）字符特别是那些不可打印字符的替代<br> 形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制<br> 数字，或者字母x加上1个十六进制数。</p></li><li><p>全局作用域（global scope）位于其他所有作用域之外的作用域。</p></li><li><p>头文件保护符（header guard）使用预处理变量以防止头文件被某<br> 个文件重复包含。</p></li><li><p>标识符（identifier）组成名字的字符序列，标识符对大小写敏感。</p></li><li><p>类内初始值（in-class initializer）在声明类的数据成员时同时提供<br> 的初始值，必须置于等号右侧或花括号内。</p></li><li><p>在作用域内（in scope）名字在当前作用域内可见。</p></li><li><p>被初始化（initialized）变量在定义的同时被赋予初始值，变量一<br> 般都应该被初始化。</p></li><li><p>内层作用域（inner scope）嵌套在其他作用域之内的作用域。</p></li><li><p>整型（integral type）参见算术类型。</p></li><li><p>列表初始化（list initialization）利用花括号把一个或多个初始值放<br> 在一起的初始化形式。</p></li><li><p>字面值（literal）是一个不能改变的值，如数字、字符、字符串<br> 等。单引号内的是字符字面值，双引号内的是字符串字面值。</p></li><li><p>局部作用域（local scope）是块作用域的习惯叫法。</p></li><li><p>底层const（low-level const）一个不属于顶层的const，类型如果由<br> 底层常量定义，则不能被忽略。</p></li><li><p>成员（member）类的组成部分。</p></li><li><p>不可打印字符（nonprintable character）不具有可见形式的字符，<br> 如控制符、退格、换行符等。</p></li><li><p>空指针（null pointer）值为0的指针，空指针合法但是不指向任何<br> 对象。</p></li><li><p>nullptr是表示空指针的字面值常量。</p></li><li><p>对象（object）是内存的一块区域，具有某种类型，变量是命名了<br> 的对象。</p></li><li><p>外层作用域（outer scope）嵌套着别的作用域的作用域。</p></li><li><p>指针（pointer）是一个对象，存放着某个对象的地址，或者某个对<br> 象存储区域之后的下一地址，或者0。</p></li><li><p>指向常量的指针（pointer to const）是一个指针，存放着某个常量<br> 对象的地址。指向常量的指针不能用来改变它所指对象的值。</p></li><li><p>预处理器（preprocessor）在C++编译过程中执行的一段程序。</p></li><li><p>预处理变量（preprocessor variable）由预处理器管理的变量。在<br> 程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实<br> 值。</p></li><li><p>引用（reference）是某个对象的别名。</p></li><li><p>对常量的引用（reference to const）是一个引用，不能用来改变它<br> 所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，<br> 或者表达式的结果。</p></li><li><p>作用域（scope）是程序的一部分，在其中某些名字有意义。</p></li><li><p>C++有几级作用域：</p></li><li><p>全局（global）——名字定义在所有其他作用域之外。</p></li><li><p>类（class）——名字定义在类内部。</p></li><li><p>命名空间（namespace）——名字定义在命名空间内部。</p></li><li><p>块（block）——名字定义在块内部。名字从声明位置开始直至声<br> 明语句所在的作用域末端为止都是可用的。</p></li><li><p>分离式编译（separate compilation）把程序分割为多个单独文件的<br> 能力。</p></li><li><p>带符号类型（signed）保存正数、负数或0的整型。</p></li><li><p>字符串（string）是一种库类型，表示可变长字符序列。</p></li><li><p>struct是一个关键字，用于定义类。</p></li><li><p>临时值（temporary）编译器在计算表达式结果时创建的无名对<br> 象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有<br> 该表达式的最大的表达式计算完成为止。</p></li><li><p>顶层const（top-level const）是一个const，规定某对象的值不能改<br> 变。</p></li><li><p>类型别名（type alias）是一个名字，是另外一个类型的同义词，通<br> 过关键字typedef或别名声明语句来定义。</p></li><li><p>类型检查（type checking）是一个过程，编译器检查程序使用某给<br> 定类型对象的方式与该类型的定义是否一致。</p></li><li><p>类型说明符（type specifier）类型的名字。</p></li><li><p>typedef为某类型定义一个别名。当关键字typedef作为声明的基本类<br> 型出现时，声明中定义的名字就是类型名。</p></li><li><p>未定义（undefined）即C++语言没有明确规定的情况。不论是否有<br> 意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可<br> 移植性问题。</p></li><li><p>未初始化（uninitialized）变量已定义但未被赋予初始值。一般来<br> 说，试图访问未初始化变量的值将引发未定义行为</p></li><li><p>无符号类型（unsigned）保存大于等于0的整型。</p></li><li><p>变量（variable）命名的对象或引用。C++语言要求变量要先声明<br> 后使用。</p></li><li><p>void＊ 可以指向任意非常量的指针类型，不能执行解引用操作。</p></li><li><p>void类型 是一种有特殊用处的类型，既无操作也无值。不能定义一<br> 个void类型的变量。</p></li><li><p>字（word）在指定机器上进行整数运算的自然单位。一般来说，</p></li><li><p>字的空间足够存放地址。32位机器上的字通常占据4个字节。</p></li><li><p>&amp;运算符（&amp;operator）取地址运算符。</p></li><li><p>＊运算符（＊ operator）解引用运算符。解引用一个指针将返回该<br> 指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。</p></li><li><p>#define是一条预处理指令，用于定义一个预处理变量。</p></li><li><p>#endif是一条预处理指令，用于结束一个#ifdef或#ifndef区域。</p></li><li><p>#ifdef是一条预处理指令，用于判断给定的变量是否已经定义。</p></li><li><p>#ifndef是一条预处理指令，用于判断给定的变量是否尚未定义。</p></li></ul>`,370);function h(y,w){const a=l("router-link");return i(),c("div",null,[k,b,r(" more "),m,n("nav",v,[n("ul",null,[n("li",null,[p(a,{to:"#第2章-变量和基本类型-结束"},{default:e(()=>[s("第2章　变量和基本类型[结束]")]),_:1})]),n("li",null,[p(a,{to:"#_2-1-基本内置类型"},{default:e(()=>[s("2.1　基本内置类型")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-1-1-算术类型"},{default:e(()=>[s("2.1.1　算术类型")]),_:1})]),n("li",null,[p(a,{to:"#_2-1-2-类型转换"},{default:e(()=>[s("2.1.2　类型转换")]),_:1})]),n("li",null,[p(a,{to:"#_2-1-3-字面值常量"},{default:e(()=>[s("2.1.3　字面值常量")]),_:1})]),n("li",null,[p(a,{to:"#_2-1-3节练习"},{default:e(()=>[s("2.1.3节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#_2-2-变量"},{default:e(()=>[s("2.2　变量")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-2-1-变量定义"},{default:e(()=>[s("2.2.1　变量定义")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-1节练习"},{default:e(()=>[s("2.2.1节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-2-变量声明和定义的关系"},{default:e(()=>[s("2.2.2　变量声明和定义的关系")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-2节练习"},{default:e(()=>[s("2.2.2节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-3-标识符"},{default:e(()=>[s("2.2.3　标识符")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-3节练习"},{default:e(()=>[s("2.2.3节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-4-名字的作用域"},{default:e(()=>[s("2.2.4　名字的作用域")]),_:1})]),n("li",null,[p(a,{to:"#_2-2-4节练习"},{default:e(()=>[s("2.2.4节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#_2-3-复合类型"},{default:e(()=>[s("2.3　复合类型")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-3-1-引用"},{default:e(()=>[s("2.3.1　引用")]),_:1})]),n("li",null,[p(a,{to:"#_2-3-1节练习"},{default:e(()=>[s("2.3.1节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-3-2-指针"},{default:e(()=>[s("2.3.2　指针")]),_:1})]),n("li",null,[p(a,{to:"#_2-3-2节练习"},{default:e(()=>[s("2.3.2节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-3-3-理解复合类型的声明"},{default:e(()=>[s("2.3.3　理解复合类型的声明")]),_:1})]),n("li",null,[p(a,{to:"#_2-3-3节练习"},{default:e(()=>[s("2.3.3节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#_2-4-const限定符"},{default:e(()=>[s("2.4 const限定符")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-4-1-const的引用"},{default:e(()=>[s("2.4.1 const的引用")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-2-指针和const"},{default:e(()=>[s("2.4.2　指针和const")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-2节练习"},{default:e(()=>[s("2.4.2节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-3-顶层const"},{default:e(()=>[s("2.4.3　顶层const")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-3节练习"},{default:e(()=>[s("2.4.3节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-4-constexpr和常量表达式"},{default:e(()=>[s("2.4.4 constexpr和常量表达式")]),_:1})]),n("li",null,[p(a,{to:"#_2-4-4节练习"},{default:e(()=>[s("2.4.4节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#_2-5-处理类型"},{default:e(()=>[s("2.5　处理类型")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-5-1-类型别名"},{default:e(()=>[s("2.5.1　类型别名")]),_:1})]),n("li",null,[p(a,{to:"#_2-5-2-auto类型说明符"},{default:e(()=>[s("2.5.2 auto类型说明符")]),_:1})]),n("li",null,[p(a,{to:"#_2-5-2节练习"},{default:e(()=>[s("2.5.2节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-5-3-decltype类型指示符"},{default:e(()=>[s("2.5.3 decltype类型指示符")]),_:1})]),n("li",null,[p(a,{to:"#_2-5-3节练习"},{default:e(()=>[s("2.5.3节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#_2-6-自定义数据结构"},{default:e(()=>[s("2.6　自定义数据结构")]),_:1}),n("ul",null,[n("li",null,[p(a,{to:"#_2-6-1-定义sales-data类型"},{default:e(()=>[s("2.6.1　定义Sales_data类型")]),_:1})]),n("li",null,[p(a,{to:"#_2-6-1节练习"},{default:e(()=>[s("2.6.1节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-6-2-使用sales-data类"},{default:e(()=>[s("2.6.2　使用Sales_data类")]),_:1})]),n("li",null,[p(a,{to:"#_2-6-2节练习"},{default:e(()=>[s("2.6.2节练习")]),_:1})]),n("li",null,[p(a,{to:"#_2-6-3-编写自己的头文件"},{default:e(()=>[s("2.6.3　编写自己的头文件")]),_:1})]),n("li",null,[p(a,{to:"#_2-6-3节练习"},{default:e(()=>[s("2.6.3节练习")]),_:1})])])]),n("li",null,[p(a,{to:"#小结"},{default:e(()=>[s("小结")]),_:1})]),n("li",null,[p(a,{to:"#术语表"},{default:e(()=>[s("术语表")]),_:1})])])]),g])}const x=o(d,[["render",h],["__file","C-第二章变量和基本类型.html.vue"]]);export{x as default};
