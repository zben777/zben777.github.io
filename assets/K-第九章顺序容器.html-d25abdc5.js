import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as l,c as i,d as u,a as n,e as t,w as p,b as s,f as e}from"./app-2a2d189a.js";const r="/assets/table9-1-4bc4710c.png",k="/assets/table9-2-c586e641.png",d="/assets/table9-3-5f3148b2.png",v="/assets/table9-4-20a0bd6a.png",b="/assets/table9-5-6f0252e5.png",m="/assets/table9-6-dc824081.png",g="/assets/table9-7-ec457587.png",f="/assets/figure9-1-ff29780e.png",h="/assets/table9-8-df780bfa.png",y="/assets/table9-9-c1f90b0c.png",w="/assets/table9-10-9fea5371.png",_="/assets/figure9-0-d8838283.png",q="/assets/table9-11-04d9d7fb.png",x="/assets/table9-12-ee05d6dc.png",z="/assets/table9-13-599bd697.png",S="/assets/table9-14-9adc818f.png",V="/assets/table9-15-f863eb87.png",C="/assets/table9-16-c1b3b01a.png",A="/assets/table9-17-d3486266.png",E="/assets/table9-18-18117478.png",j="/assets/table9-19-161e18ac.png",H={},B=n("h1",{id:"k-第九章顺序容器",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#k-第九章顺序容器","aria-hidden":"true"},"#"),s(" K-第九章顺序容器")],-1),M=n("p",null,"K-第九章顺序容器",-1),J=e('<div class="hint-container info"><p class="hint-container-title">说明</p><p>主要是各种搜索找的学习；<br><strong>百度链接：</strong><br> :<br> :</p><p><strong>知乎链接：</strong><br> :<br> :</p><p><strong>B站链接：</strong><br> ：<br> ：</p><p><strong>博客链接：</strong><br> ：<br> ：</p><p><strong>GitHub链接：</strong><br> ：<br> ：</p></div>',1),N={class:"table-of-contents"},W=e('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="第九章顺序容器" tabindex="-1"><a class="header-anchor" href="#第九章顺序容器" aria-hidden="true">#</a> 第九章顺序容器</h2><ul><li><p>本章是第3章内容的扩展，完成本章的学习后，对标准库顺序容器<br> 知识的掌握就完整了。元素在顺序容器中的顺序与其加入容器时的位置<br> 相对应。标准库还定义了几种关联容器，关联容器中元素的位置由元素<br> 相关联的关键字值决定。我们将在第11章中介绍关联容器特有的操作。<br> 【所以 标准库+顺序容器】</p></li><li><p>所有容器类都共享公共的接口，不同容器按不同方式对其进行扩<br> 展。这个公共接口使容器的学习更加容易——我们基于某种容器所学习<br> 的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。</p></li><li><p>一个容器就是一些特定类型对象的集合。顺序容器（sequential<br> container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序<br> 不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对<br> 的，我们将在第11章介绍的有序和无序关联容器，则根据关键字的值来<br> 存储元素。</p></li><li><p>标准库还提供了三种容器适配器，分别为容器操作定义了不同的接<br> 口，来与容器类型适配。我们将在本章末尾介绍适配器。</p></li><li><p>本章的内容基于3.2节、3.3节和3.4节中已经介绍的有关容器的知识，我们假定读<br> 者已经熟悉了这几节的内容。</p></li></ul><h2 id="_9-1-顺序容器概述" tabindex="-1"><a class="header-anchor" href="#_9-1-顺序容器概述" aria-hidden="true">#</a> 9.1　顺序容器概述</h2><ul><li>表9.1列出了标准库中的顺序容器，所有顺序容器都提供了快速顺<br> 序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：<br> · 向容器添加或从容器中删除元素的代价<br> · 非顺序访问容器中元素的代价</li></ul><figure><img src="'+r+`" alt="table9-1" tabindex="0" loading="lazy"><figcaption>table9-1</figcaption></figure><ul><li><p>除了固定大小的array外，其他容器都提供高效、灵活的内存管理。<br> 我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策<br> 略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，<br> 存储策略还会影响特定容器是否支持特定操作。</p></li><li><p>例如，string和vector将元素保存在连续的内存空间中。由于元素是<br> 连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两<br> 种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操<br> 作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而<br> 且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况<br> 下，每个元素都必须移动到新的存储空间中。</p></li><li><p>list和forward_list两个容器的设计目的是令容器任何位置的添加和删<br> 除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了<br> 访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array<br> 相比，这两个容器的额外内存开销也很大。</p></li><li><p>deque是一个更为复杂的数据结构。与string和vector类似，deque支<br> 持快速的随机访问。与string和vector一样，在deque的中间位置添加或删<br> 除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都<br> 是很快的，与list或forward_list添加删除元素的速度相当。</p></li><li><p>forward_list和array是新C++标准增加的类型。与内置数组相比，<br> array是一种更安全、更容易使用的数组类型。与内置数组类似，array对<br> 象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大<br> 小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据<br> 结构相当的性能。因此，forward_list没有size操作，因为保存或计算其<br> 大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一<br> 个快速的常量时间的操作。</p></li><li><p>新标准库的容器比旧版本快得多，原因我们将在13.6节（第470页）解释。新标准<br> 库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代<br> C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p></li></ul><br><ul><li><p><mark>确定使用哪种顺序容器</mark></p></li><li><p>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>以下是一些选择容器的基本原则：<br> · 除非你有很好的理由选择其他容器，否则应使用vector。<br> · 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。<br> · 如果程序要求随机访问元素，应使用vector或deque。<br> · 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。<br> · 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。<br> · 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<br> — 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将在10.2.3节介绍sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。<br> — 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。</p></li><li><p>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，<br> 那该怎么办？答案取决于在list或forward_list中访问元素与vector或deque<br> 中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作<br> （执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。<br> 在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</p></li><li><p>如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操<br> 作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或<br> list都很方便。</p></li></ul><h3 id="_9-1节练习" tabindex="-1"><a class="header-anchor" href="#_9-1节练习" aria-hidden="true">#</a> 9.1节练习</h3><ul><li>练习9.1：对于下面的程序任务，vector、deque和list哪种容器最为适<br> 合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。</li></ul><ul><li>(a) 读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到，关联容器更适合这个问题。</li><li>(b) 读取未知数量的单词，总是将单词插入到末尾。删除操作在头部进行。</li><li>(c) 从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。<br> 解：</li><li>(a) <code>list</code> ，因为需要频繁的插入操作。</li><li>(b) <code>deque</code> ，总是在头尾进行插入、删除操作。</li><li>(c) <code>vector</code> ，不需要进行插入删除操作。</li></ul><h2 id="_9-2-容器库概览" tabindex="-1"><a class="header-anchor" href="#_9-2-容器库概览" aria-hidden="true">#</a> 9.2　容器库概览</h2><ul><li><p>容器类型上的操作形成了一种层次：<br> · 某些操作是所有容器类型都提供的（参见表9.2，第295页）。<br> · 另外一些操作仅针对顺序容器（参见表9.3，第299页）、关联容器（参见表11.7，第388页）或无序容器（参见表11.8，第395页）。<br> · 还有一些操作只适用于一小部分容器。</p></li><li><p>在本节中，我们将介绍对所有容器都适用的操作。本章剩余部分将<br> 聚焦于仅适用于顺序容器的操作。关联容器特有的操作将在第11章介绍。</p></li><li><p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相<br> 同。即，deque定义在头文件deque中，list定义在头文件list中，以此类<br> 推。容器均定义为模板类（参见3.3节，第86页）。例如对vector，我们<br> 必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容<br> 器，我们还需要额外提供元素类型信息：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
list<span class="token operator">&lt;</span>Sales_data<span class="token operator">&gt;</span> <span class="token comment">// list that holds Sales_data objects</span>
deque<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token comment">// deque that holds doubles</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>对容器可以保存的元素类型的限制</mark></li><li>顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一<br> 个容器，其元素的类型是另一个容器。这种容器的定义与任何其他容器<br> 类型完全一样：在尖括号中指定元素类型（此种情况下，是另一种容器<br> 类型）：此处lines是一个vector，其元素类型是string的vector</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> lines<span class="token punctuation">;</span> <span class="token comment">// vector of vectors</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>较旧的编译器可能需要在两个尖括号之间键入空格，例如，<code>vector&lt;vector&lt;string&gt;&gt;。</code></li></ul><br><ul><li><p>虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素<br> 类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义<br> 容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。</p></li><li><p>例如，顺序容器构造函数的一个版本接受容器大小参数（参见3.3.1<br> 节，第88页），它使用了元素类型的默认构造函数。但某些类没有默认<br> 构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造<br> 这种容器时不能只传递给它一个元素数目参数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//假定noDefault是一个没有默认构造函数的类型</span>
vector<span class="token operator">&lt;</span>noDefault<span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确:提供了元素初始化器</span>
vector<span class="token operator">&lt;</span>noDefault<span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误:必须提供一个元素初始化器</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li>当后面介绍容器操作时，我们还会注意到每个容器操作对元素类型的其他限制。</li></ul><figure><img src="`+k+`" alt="table9-2" tabindex="0" loading="lazy"><figcaption>table9-2</figcaption></figure><h3 id="_9-2节练习" tabindex="-1"><a class="header-anchor" href="#_9-2节练习" aria-hidden="true">#</a> 9.2节练习</h3><ul><li>练习9.2：定义一个list对象，其元素类型是int的deque。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ll<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_9-2-1-迭代器" tabindex="-1"><a class="header-anchor" href="#_9-2-1-迭代器" aria-hidden="true">#</a> 9.2.1　迭代器</h3><ul><li><p>与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操<br> 作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同<br> 的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元<br> 素，而所有迭代器都是通过解引用运算符来实现这个操作的。类似的，<br> 标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一<br> 个元素。</p></li><li><p>表3.6（第96页）列出了容器迭代器支持的所有操作，其中有一个<br> 例外不符合公共接口特点——forward_list迭代器不支持递减运算符（--）。<br> 表3.7（第99页）列出了迭代器支持的算术运算，这些运算只能应<br> 用于string、vector、deque和array的迭代器。我们不能将它们用于其他<br> 任何容器类型的迭代器。</p></li></ul><br><ul><li><p><mark>迭代器范围</mark></p></li><li><p>迭代器范围的概念是标准库的基础。</p></li><li><p>一个迭代器范围（iterator range）由一对迭代器表示，两个迭代器<br> 分别指向同一个容器中的元素或者是尾元素之后的位置（one past the<br> last element）。这两个迭代器通常被称为begin和end，或者是first和<br> last（可能有些误导），它们标记了容器中元素的一个范围。</p></li><li><p>虽然第二个迭代器常常被称为last，但这种叫法有些误导，因为第<br> 二个迭代器从来都不会指向范围中的最后一个元素，而是指向尾元素之<br> 后的位置。迭代器范围中的元素包含first所表示的元素以及从first开始<br> 直至last（但不包含last）之间的所有元素。</p></li><li><p>这种元素范围被称为左闭合区间（left-inclusive interval），其标准<br> 数学描述为<code>[begin, end)</code></p></li><li><p>表示范围自begin开始，于end之前结束。迭代器begin和end必须指<br> 向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。</p></li></ul><br><ul><li><p><mark>对构成范围的迭代器的要求</mark></p></li><li><p>如果满足如下条件，两个迭代器begin和end构成一个迭代器范：<br> · 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且<br> · 我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。</p></li><li><p>编译器不会强制这些要求。确保程序符合这些约定是程序员的责任。</p></li></ul><br><ul><li><p><mark>使用左闭合范围蕴含的编程假定</mark></p></li><li><p>标准库使用左闭合范围是因为这种范围有三种方便的性质。假定begin和end构成一个合法的迭代器范围则<br> · 如果begin与end相等，则范围为空<br> · 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素<br> · 我们可以对begin递增若干次，使得begin==end</p></li><li><p>这些性质意味着我们可以像下面的代码一样用一个循环来处理一个<br> 元素范围，而这是安全的：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>begin <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token comment">// ok: range isn&#39;t empty so begin denotes an element</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span> <span class="token comment">// advance the iterator to get the next element</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>给定构成一个合法范围的迭代器begin和end，若begin==end，则范<br> 围为空。在此情况下，我们应该退出循环。如果范围不为空，begin指<br> 向此非空范围的一个元素。因此，在while循环体中，可以安全地解引<br> 用begin，因为begin必然指向一个元素。最后，由于每次循环对begin递<br> 增一次，我们确定循环最终会结束。</li></ul><h3 id="_9-2-1节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-1节练习" aria-hidden="true">#</a> 9.2.1节练习</h3><ul><li>练习9.3：构成迭代器范围的迭代器有何限制？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>两个迭代器 \`begin\` 和 \`end\`需满足以下条件：

<span class="token operator">*</span> 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
<span class="token operator">*</span> 我们可以通过反复递增\`begin\`来到达\`end\`。换句话说，\`end\` 不在\`begin\`之前。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.4：编写函数，接受一对指向<code>vector&lt;int&gt;</code>的迭代器和一个int值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">find</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator begin<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator end<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin<span class="token operator">++</span> <span class="token operator">!=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>begin <span class="token operator">==</span> i<span class="token punctuation">)</span> 
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.5：重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator <span class="token function">find</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator begin<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator end<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>begin <span class="token operator">==</span> i<span class="token punctuation">)</span> 
			<span class="token keyword">return</span> begin<span class="token punctuation">;</span>
		<span class="token operator">++</span>begin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
    <span class="token keyword">return</span> end<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.6：下面程序有何错误？你应该如何修改它？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst1<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter1 <span class="token operator">=</span> lst1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
					iter2 <span class="token operator">=</span> lst1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter1 <span class="token operator">&lt;</span> iter2<span class="token punctuation">)</span> <span class="token comment">/* ... */</span>
修改成如下：：：
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter1 <span class="token operator">!=</span> iter2<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-2-容器类型成员" tabindex="-1"><a class="header-anchor" href="#_9-2-2-容器类型成员" aria-hidden="true">#</a> 9.2.2　容器类型成员</h3><ul><li><p>每个容器都定义了多个类型，如表9.2所示（第295页）。我们已经<br> 使用过其中三种：size_type（参见3.2.2节，第79页）、iterator和<br> const_iterator（参见3.4.1节，第97页）。</p></li><li><p>除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简<br> 单地说，反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相<br> 比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行<br> ++操作，会得到上一个元素。我们将在10.4.3节（第363页）介绍更多关<br> 于反向迭代器的内容。</p></li><li><p>剩下的就是类型别名了，通过类型别名，我们可以在不了解容器中<br> 元素类型的情况下使用它。如果需要元素类型，可以使用容器的<br> value_type。如果需要元素类型的一个引用，可以使用reference或<br> const_reference。这些元素相关的类型别名在泛型编程中非常有用，我<br> 们将在16章中介绍相关内容。</p></li><li><p>为了使用这些类型，我们必须显式使用其类名：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// iter is the iterator type defined by list&lt;string&gt;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter<span class="token punctuation">;</span>
<span class="token comment">// count is the difference_type type defined by vector&lt;int&gt;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>difference_type count<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这些声明语句使用了作用域运算符（参见1.2节，第7页）来说明我<br> 们希望使用<code>list&lt;string&gt;类的iterator成员及vector&lt;int&gt;</code>类定义的<br> difference_type。</li></ul><h3 id="_9-2-2节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-2节练习" aria-hidden="true">#</a> 9.2.2节练习</h3><ul><li>练习9.7：为了索引int的vector中的元素，应该使用什么类型？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>练习9.8：为了读取string的list中的元素，应该使用什么类型？如果写入list，又该使用什么类型？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator <span class="token comment">// 读</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator <span class="token comment">// 写</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-3-begin和end成员" tabindex="-1"><a class="header-anchor" href="#_9-2-3-begin和end成员" aria-hidden="true">#</a> 9.2.3 begin和end成员</h3><ul><li><p>begin和end操作（参见3.4.1节，第95页）生成指向容器中第一个元<br> 素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个<br> 包含容器中所有元素的迭代器范围。</p></li><li><p>如表9.2（第295页）所示，begin和end有多个版本：带r的版本返回<br> 反向迭代器（我们将在10.4.3节（第363页）中介绍相关内容）；以c开<br> 头的版本则返回const迭代器：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// list&lt;string&gt;::iterator</span>
<span class="token keyword">auto</span> it2 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// list&lt;string&gt;::reverse_iterator</span>
<span class="token keyword">auto</span> it3 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// list&lt;string&gt;::const_iterator</span>
<span class="token keyword">auto</span> it4 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// list&lt;string&gt;::const_reverse_iterator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不以c开头的函数都是被重载过的。也就是说，实际上有两个名为<br> begin的成员。一个是const成员（参见7.1.2节，第231页），返回容器的<br> const_iterator类型。另一个是非常量成员，返回容器的iterator类型。<br> rbegin、end和rend的情况类似。当我们对一个非常量对象调用这些成员<br> 时，得到的是返回iterator的版本。只有在对一个const对象调用这些函数<br> 时，才会得到一个const版本。与const指针和引用类似，可以将一个普<br> 通的iterator转换为对应的const_iterator，但反之不行。</li></ul><br><ul><li>以c开头的版本是C++新标准引入的，用以支持auto（参见2.5.2节，<br> 第61页）与begin和end函数结合使用。过去，没有其他选择，只能显式<br> 声明希望使用哪种类型的迭代器：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// type is explicitly specified</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it5 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it6 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// iterator or const_iterator depending on a&#39;s type of a</span>
<span class="token keyword">auto</span> it7 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const_iterator only if a is const</span>
<span class="token keyword">auto</span> it8 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it8 is const_iterator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类<br> 型，与我们想要如何使用迭代器毫不相干。但以c开头的版本还是可以<br> 获得const_iterator的，而不管容器的类型是什么。</p></li><li><p>当不需要写访问时，应使用cbegin和cend。</p></li></ul><h3 id="_9-2-3节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-3节练习" aria-hidden="true">#</a> 9.2.3节练习</h3><ul><li>练习9.9：begin和cbegin两个函数有什么不同？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>\`begin\` 返回的是普通迭代器，\`cbegin\` 返回的是常量迭代器。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>练习9.10：下面4个对象分别是什么类型？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
<span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
<span class="token keyword">auto</span> it1 <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it2 <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it3 <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it4 <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

\`it1\` 是 \`vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator\`

\`it2\`，\`it3\` 和 \`it4\` 是 \`vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-4-容器定义和初始化" tabindex="-1"><a class="header-anchor" href="#_9-2-4-容器定义和初始化" aria-hidden="true">#</a> 9.2.4　容器定义和初始化</h3><ul><li>每个容器类型都定义了一个默认构造函数（参见7.1.4节，第236<br> 页）。除array之外，其他容器的默认构造函数都会创建一个指定类型的<br> 空容器，且都可以接受指定容器大小和元素初始值的参数。<br><img src="`+d+`" alt="table9-3" loading="lazy"></li></ul><br><ul><li><p><mark>将一个容器初始化为另一个容器的拷贝</mark></p></li><li><p>将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷<br> 贝整个容器，或者（array除外）拷贝由一个迭代器对指定的元素范围。</p></li><li><p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素<br> 类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求<br> 容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不<br> 同，只要能将要拷贝的元素转换（参见4.11节，第141页）为要初始化<br> 的容器的元素类型即可。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// each container has three elements, initialized from the given initializers</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> authors <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> articles <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">list2</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: types match</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">authList</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: container types don&#39;t match</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">words</span><span class="token punctuation">(</span>articles<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: element types must match</span>
<span class="token comment">// ok: converts const char* elements to string</span>
forward_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">words</span><span class="token punctuation">(</span>articles<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> articles<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都<br> 必须相同。</p></li><li><p>接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝<br> 的一个元素范围。与以往一样，两个迭代器分别标记想要拷贝的第一个<br> 元素和尾元素之后的位置。新容器的大小与范围中元素的数目相同。新<br> 容器中的每个元素都用范围中对应元素的值进行初始化。</p></li><li><p>由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝<br> 一个容器中的子序列。例如，假定迭代器it表示authors中的一个元素，<br> 我们可以编写如下代码</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// copies up to but not including the element denoted by it</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">authList</span><span class="token punctuation">(</span>authors<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>列表初始化</mark></li><li>在新标准中，我们可以对一个容器进行列表初始化（参见3.3.1节，第88页）</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// each container has three elements, initialized from the given initializers</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> authors <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Milton&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Shakespeare&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Austen&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> articles <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;an&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当这样做时，我们就显式地指定了容器中每个元素的值。对于除<br> array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将<br> 包含与初始值一样多的元素。</li></ul><br><ul><li><mark>与顺序容器大小相关的构造函数</mark></li><li>除了与关联容器相同的构造函数外，顺序容器（array除外）还提供<br> 另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。<br> 如果我们不提供元素初始值，则标准库会创建一个值初始化器（参见<br> 3.3.1节，第88页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten int elements, each initialized to -1</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;hi!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten strings; each element is &quot;hi!&quot;</span>
forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten elements, each initialized to 0</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten elements, each an empty string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果元素类型是内置类型或者是具有默认构造函数（参见9.2节，<br> 第294页）的类类型，可以只为构造函数提供一个容器大小参数。如果<br> 元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的<br> 元素初始值。</p></li><li><p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p></li></ul><br><ul><li><mark>标准库array具有固定大小</mark></li><li>与内置数组一样，标准库array的大小也是类型的一部分。当定义一<br> 个array时，除了指定元素类型，还要指定容器大小：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token operator">&gt;</span> <span class="token comment">// type is: array that holds 42 ints</span>
array<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> <span class="token comment">// type is: array that holds 10 strings</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>为了使用array类型，我们必须同时指定元素类型和大小：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type i<span class="token punctuation">;</span> <span class="token comment">// array type includes element type and size</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type j<span class="token punctuation">;</span> <span class="token comment">// error: array&lt;int&gt; is not a type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>由于大小是array类型的一部分，array不支持普通的容器构造函数。<br> 这些构造函数都会确定容器的大小，要么隐式地，要么显式地。而允许<br> 用户向一个array构造函数传递大小参数，最好情况下也是多余的，而且<br> 容易出错。</p></li><li><p>array大小固定的特性也影响了它所定义的构造函数的行为。与其他<br> 容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的<br> 元素。这些元素都被默认初始化（参见2.2.1节，第40页），就像一个内<br> 置数组（参见3.5.1节，第102页）中的元素那样。如果我们对array进行<br> 列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数<br> 目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余<br> 元素都会进行值初始化（参见3.3.1节，第88页）。在这两种情况下，如<br> 果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值<br> 初始化能够进行：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> ia1<span class="token punctuation">;</span> <span class="token comment">// ten default-initialized ints</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> ia2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// list initialization</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> ia3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ia3[0] is 42, remaining elements are 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值<br> 操作（参见3.5.1节，第102页），但array并无此限制：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> digs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cpy<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> digs<span class="token punctuation">;</span> <span class="token comment">// error: no copy or assignment for built-in arrays</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> digits <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> copy <span class="token operator">=</span> digits<span class="token punctuation">;</span> <span class="token comment">// ok: so long as array types match</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>与其他容器一样，array也要求初始值的类型必须与要创建的容器类<br> 型相同。此外，array还要求元素类型和大小也都一样，因为大小是array<br> 类型的一部分。</li></ul><h3 id="_9-2-4节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-4节练习" aria-hidden="true">#</a> 9.2.4节练习</h3><ul><li>练习9.11：对6种创建和初始化vector对象的方法，每一种都给出一个实<br> 例。解释每个vector包含什么值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>    <span class="token comment">// 0</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 10个0</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10个1</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3, 4, 5</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span>other_vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝 other_vec 的元素</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span>other_vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other_vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝 other_vec 的元素</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.12：对于接受一个容器创建其拷贝的构造函数，和接受两个迭代<br> 器创建拷贝的构造函数，解释它们的不同。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span> 接受一个容器创建其拷贝的构造函数，必须容器类型和元素类型都相同。
<span class="token operator">*</span> 接受两个迭代器创建拷贝的构造函数，只需要元素的类型能够相互转换，容器类型和元素类型可以不同。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.13：如何从一个<code>list&lt;int&gt;初始化一个vector&lt;double&gt;？从一个vector&lt;int&gt;又该如何创建？</code>编写代码验证你的答案。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ilst</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ivc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">dvc</span><span class="token punctuation">(</span>ilst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">dvc2</span><span class="token punctuation">(</span>ivc<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ivc<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-5-赋值和swap" tabindex="-1"><a class="header-anchor" href="#_9-2-5-赋值和swap" aria-hidden="true">#</a> 9.2.5　赋值和swap</h3><ul><li>表9.4中列出的与赋值相关的运算符可用于所有容器。赋值运算符<br> 将其左边容器中的全部元素替换为右边容器中元素的拷贝：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>c1 <span class="token operator">=</span> c2<span class="token punctuation">;</span> <span class="token comment">// replace the contents of c1 with a copy of the elements in c2</span>
c1 <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// after the assignment c1 has size 3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第一个赋值运算后，左边容器将与右边容器相等。如果两个容器原<br> 来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。第二<br> 个赋值运算后，c1的size变为3，即花括号列表中值的数目。</p></li><li><p>与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运<br> 算对象必须具有相同的类型：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// elements all have value 0</span>
a1 <span class="token operator">=</span> a2<span class="token punctuation">;</span> <span class="token comment">// replaces elements in a1</span>
a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: cannot assign to an array from a braced list</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>由于右边运算对象的大小可能与左边运算对象的大小不同，因此<br> array类型不支持assign，也不允许用花括号包围的值列表进行赋值。<br><img src="`+v+`" alt="table9-4" loading="lazy"></li></ul><br><ul><li><mark>使用assign（仅顺序容器）</mark></li><li>赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边<br> 运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还<br> 定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋<br> 值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素<br> （的拷贝）替换左边容器中的所有元素。例如，我们可以用assgin实现<br> 将一个vector中的一段char *值赋予一个list中的string：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> names<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> oldstyle<span class="token punctuation">;</span>
names <span class="token operator">=</span> oldstyle<span class="token punctuation">;</span> <span class="token comment">// error: container types don&#39;t match</span>
<span class="token comment">// ok: can convert from const char*to string</span>
names<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>oldstyle<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> oldstyle<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段代码中对assign的调用将names中的元素替换为迭代器指定的范<br> 围中的元素的拷贝。assign的参数决定了容器中将有多少个元素以及它<br> 们的值都是什么。</p></li><li><p>由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。</p></li><li><p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目<br> 且具有相同给定值的元素替换容器中原有的元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// equivalent to slist1.clear();</span>
<span class="token comment">// followed by slist1.insert(slist1.begin(), 10, &quot;Hiya!&quot;);</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">slist1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// one element, which is the empty string</span>
slist1<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;Hiya!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten elements; each one is Hiya !</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>使用swap</mark></li><li>swap操作交换两个相同类型容器的内容。调用swap之后，两个容器<br> 中的元素将会交换：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vector with ten elements</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">svec2</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vector with 24 elements</span>
<span class="token function">swap</span><span class="token punctuation">(</span>svec1<span class="token punctuation">,</span> svec2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>调用swap后，svec1将包含24个string元素，svec2将包含10个string。<br> 除array外，交换两个容器内容的操作保证会很快——元素本身并未交<br> 换，swap只是交换了两个容器的内部数据结构。</p></li><li><p>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数<br> 时间内完成。</p></li><li><p>元素不会被移动的事实意味着，除string外，指向容器的迭代器、<br> 引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指<br> 向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。<br> 例如，假定iter在swap之前指向<code>svec1[3]的string</code>，那么在swap之后它指向<br><code>svec2[3]</code>的元素。与其他容器不同，对一个string调用swap会导致迭代<br> 器、引用和指针失效。</p></li><li><p>与其他容器不同，swap两个array会真正交换它们的元素。因此，交<br> 换两个array所需的时间与array中元素的数目成正比。</p></li><li><p>因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的<br> 元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。</p></li><li><p>在新标准库中，容器既提供成员函数版本的swap，也提供非成员版<br> 本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本<br> 的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个<br> 好习惯。</p></li></ul><h3 id="_9-2-5节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-5节练习" aria-hidden="true">#</a> 9.2.5节练习</h3><p>练习9.14：编写程序，将一个list中的char *指针（指向C风格字符串）元<br> 素赋值给一个vector中的string。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> l<span class="token punctuation">{</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-6-容器大小操作" tabindex="-1"><a class="header-anchor" href="#_9-2-6-容器大小操作" aria-hidden="true">#</a> 9.2.6　容器大小操作</h3><ul><li>除了一个例外，每个容器类型都有三个与大小相关的操作。成员函<br> 数size（参见3.2.2节，第78页）返回容器中元素的数目；empty当size为0<br> 时返回布尔值true，否则返回false；max_size返回一个大于或等于该类<br> 型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，<br> 但不支持size，原因我们将在下一节解释。</li></ul><h3 id="_9-2-7-关系运算符" tabindex="-1"><a class="header-anchor" href="#_9-2-7-关系运算符" aria-hidden="true">#</a> 9.2.7　关系运算符</h3><ul><li><p>每个容器类型都支持相等运算符（==和！=）；除了无序关联容器<br> 外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符左右<br> 两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。<br> 即，我们只能将一个<code>vector&lt;int&gt;与另一个vector&lt;int&gt;</code>进行比较，而不能<br> 将一个<code>vector&lt;int&gt;与一个list&lt;int&gt;或一个vector&lt;double&gt;</code>进行比较。</p></li><li><p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方<br> 式与string的关系运算（参见3.2.2节，第79页）类似：<br> · 如果两个容器具有相同大小且所有元素都两两对应相等，则这两<br> 个容器相等；否则两个容器不等。<br> · 如果两个容器大小不同，但较小容器中每个元素都等于较大容器<br> 中的对应元素，则较小容器小于较大容器。<br> · 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结<br> 果取决于第一个不相等的元素的比较结果。</p></li><li><p>下面的例子展示了这些关系运算符是如何工作的：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1 <span class="token operator">&lt;</span> v2 <span class="token comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span>
v1 <span class="token operator">&lt;</span> v3 <span class="token comment">// false; all elements are equal, but v3 has fewer of them;</span>
v1 <span class="token operator">==</span> v4 <span class="token comment">// true; each element is equal and v1 and v4 have the same size()</span>
v1 <span class="token operator">==</span> v2 <span class="token comment">// false; v2 has fewer elements than v1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>容器的关系运算符使用元素的关系运算符完成比较</mark></p></li><li><p>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来<br> 比较两个容器。</p></li><li><p>容器的相等运算符实际上是使用元素的<code>==</code>运算符实现比较的，而其<br> 他关系运算符是使用元素的&lt;运算符。如果元素类型不支持所需运算<br> 符，那么保存这种元素的容器就不能使用相应的关系运算。例如，我们<br> 在第7章中定义的Sales_data类型并未定义<code>==和&lt;运算</code>。因此，就不能比<br> 较两个保存Sales_data元素的容器：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>Sales_data<span class="token operator">&gt;</span> storeA<span class="token punctuation">,</span> storeB<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>storeA <span class="token operator">&lt;</span> storeB<span class="token punctuation">)</span> <span class="token comment">// error: Sales_data has no less-than operator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-2-7节练习" tabindex="-1"><a class="header-anchor" href="#_9-2-7节练习" aria-hidden="true">#</a> 9.2.7节练习</h3><ul><li>练习9.15：编写程序，判定两个<code>vector&lt;int&gt;</code>是否相等。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec2<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec3<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>vec1 <span class="token operator">==</span> vec2 <span class="token operator">?</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>vec1 <span class="token operator">==</span> vec3 <span class="token operator">?</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.16：重写上一题的程序，<code>比较一个list&lt;int&gt;中的元素和一个vector&lt;int&gt;中的元素</code>。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>      li<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>    vec2<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>    vec3<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> li<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> vec2 <span class="token operator">?</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> li<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> vec3 <span class="token operator">?</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.17：假定c1和c2是两个容器，下面的比较操作有何限制（如果有的话）？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">&lt;</span> c2<span class="token punctuation">)</span>
解： 
<span class="token operator">*</span> \`c1\`和\`c2\`必须是相同类型的容器并且保存相同类型的元素
<span class="token operator">*</span> 元素类型要支持关系运算符



</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-3-顺序容器操作" tabindex="-1"><a class="header-anchor" href="#_9-3-顺序容器操作" aria-hidden="true">#</a> 9.3　顺序容器操作</h2><ul><li>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不<br> 同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍<br> 了所有容器都支持的操作（罗列于表9.2（第295页））。本章剩余部分<br> 将介绍顺序容器所特有的操作。</li></ul><h3 id="_9-3-1-向顺序容器添加元素" tabindex="-1"><a class="header-anchor" href="#_9-3-1-向顺序容器添加元素" aria-hidden="true">#</a> 9.3.1　向顺序容器添加元素</h3><ul><li><p>除array外，所有标准库容器都提供灵活的内存管理。在运行时可以<br> 动态添加或删除元素来改变容器大小。表9.5列出了向顺序容器（非<br> array）添加元素的操作。<br><img src="`+b+`" alt="table9-5" loading="lazy"></p></li><li><p>当我们使用这些操作时，必须记得不同容器使用不同的策略来分配<br> 元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外<br> 的任何位置，或是一个deque的首尾之外的任何位置添加元素，都需要<br> 移动元素。而且，向一个vector或string添加元素可能引起整个对象存储<br> 空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并<br> 将元素从旧的空间移动到新的空间中。</p></li></ul><br><ul><li><p><mark>使用push_back</mark></p></li><li><p>在3.3.2节（第90页）中，我们看到push_back将一个元素追加到一<br> 个vector的尾部。除array和forward_list之外，每个顺序容器（包括string<br> 类型）都支持push_back。</p></li><li><p>例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// read from standard input, putting each word onto the end of container</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
 container<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>对push_back的调用在container尾部创建了一个新的元素，将<br> container的size增大了1。该元素的值为word的一个拷贝。container的类<br> 型可以是list、vector或deque。</p></li><li><p>由于string是一个字符容器，我们也可以用push_back在string末尾添加字符：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">pluralize</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>word<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        word<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token char">&#39;s&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// same as word += &#39;s&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>关键概念：容器元素是拷贝</mark></li><li>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入<br> 到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引<br> 用参数（参见3.2.2节，第79页）一样，容器中的元素与提供值的对象之间没有任何关<br> 联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</li></ul><br><ul><li><mark>使用push_front</mark></li><li>除了push_back，list、forward_list和deque容器还支持名为push_front<br> 的类似操作。此操作将元素插入到容器头部：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ilist<span class="token punctuation">;</span>
<span class="token comment">// add elements to the start of ilist</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
    ilist<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的<br> 新的开始位置（new beginning）。即，当我们插入1时，它会被放置在0<br> 之前，2被放置在1之前，依此类推。因此，在循环中以这种方式将元素<br> 添加到容器中，最终会形成逆序。在循环执行完毕后，ilist保存序列3、<br> 2、1、0。</p></li><li><p>注意，deque像vector一样提供了随机访问元素的能力，但它提供了<br> vector所不支持的push_front。deque保证在容器首尾进行插入和删除元<br> 素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插<br> 入元素会很耗时。</p></li></ul><br><ul><li><p><mark>在容器中的特定位置添加元素</mark></p></li><li><p>push_back和push_front操作提供了一种方便地在顺序容器尾部或头<br> 部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许<br> 我们在容器中任意位置插入0个或多个元素。vector、deque、list和string<br> 都支持insert成员。forward_list提供了特殊版本的insert成员，我们将在<br> 9.3.4节（第312页）中介绍。</p></li><li><p>每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出<br> 了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容<br> 器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的<br> 元素的位置，而且在容器开始位置插入元素是很有用的功能，所以<br> insert函数将元素插入到迭代器所指定的位置之前。例如，下面的语句<br><code>slist.insert(iter, &quot;Hello!&quot;); // insert &quot;Hello!&quot; just before iter</code></p></li><li><p>将一个值为&quot;Hello&quot;的string插入到iter指向的元素之前的位置。</p></li><li><p>虽然某些容器不支持push_front操作，但它们对于insert操作并无类<br> 似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位<br> 置，而不必担心容器是否支持push_front：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> slist<span class="token punctuation">;</span>
<span class="token comment">// equivalent to calling slist.push_front(&quot;Hello!&quot;);</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// no push_front on vector but we can insert before begin()</span>
<span class="token comment">// warning: inserting anywhere but at the end of a vector might be slow</span>
svec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。</li></ul><br><ul><li><p><mark>插入范围内元素</mark></p></li><li><p>除了第一个迭代器参数之外，insert函数还可以接受更多的参数，<br> 这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它<br> 将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化：<br><code>svec.insert(svec.end(), 10, &quot;Anna&quot;);</code></p></li><li><p>这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为<br> string &quot;Anna&quot;。</p></li><li><p>接受一对迭代器或一个初始化列表的insert版本将给定范围中的元<br> 素插入到指定位置之前：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;quasi&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;simba&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;frollo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;scar&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// insert the last two elements of v at the beginning of slist</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;these&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;words&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;will&quot;</span><span class="token punctuation">,</span>
 <span class="token string">&quot;go&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;at&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;end&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// run-time error: iterators denoting the range to copy from</span>
<span class="token comment">// must not refer to the same container as the one we are changing</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> slist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。</p></li><li><p>在新标准下，接受元素个数或范围的insert版本返回指向第一个新<br> 加入元素的迭代器。（在旧版本的标准库中，这些操作返回void。）如<br> 果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p></li></ul><br><ul><li><mark>使用insert的返回值</mark></li><li>通过使用insert的返回值，可以在容器中一个特定位置反复插入元素：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> lst<span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
 iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// same as calling push_front</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>理解这个循环是如何工作的非常重要，特别是理解这个循环为什么等价于调用<br> push_front尤为重要。</p></li><li><p>在循环之前，我们将iter初始化为lst.begin（）。第一次调用insert会<br> 将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回<br> 的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，<br> 读取下一个单词。只要继续有单词读入，每步while循环就会将一个新<br> 元素插入到iter之前，并将iter改变为新加入元素的位置。此元素为（新<br> 的）首元素。因此，每步循环将一个新元素插入到list首元素之前的位置。</p></li></ul><br><ul><li><p><mark>使用emplace操作</mark></p></li><li><p>新标准引入了三个新成员——emplace_front、emplace和<br> emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应<br> push_front、insert和push_back，允许我们将元素放置在容器头部、一个<br> 指定位置之前或容器尾部。</p></li><li><p>当调用push或insert成员函数时，我们将元素类型的对象传递给它<br> 们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数<br> 时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参<br> 数在容器管理的内存空间中直接构造元素。例如，假定c保存<br> Sales_data（参见7.1.4节，第237页）元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// construct a Sales_data object at the end of c</span>
<span class="token comment">// uses the three-argument Sales_data constructor</span>
c<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// error: there is no version of push_back that takes three arguments</span>
c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ok: we create a temporary Sales_data object to pass to push_back</span>
c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>其中对emplace_back的调用和第二个push_back调用都会创建新的<br> Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直<br> 接创建对象。而调用push_back则会创建一个局部临时对象，并将其压<br> 入容器中。</p></li><li><p>emplace函数的参数根据元素类型而变化，参数必须与元素类型的<br> 构造函数相匹配：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// iter refers to an element in c, which holds Sales_data elements</span>
c<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// uses the Sales_data default constructor</span>
c<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token string">&quot;999-999999999&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// uses Sales_data(string)</span>
<span class="token comment">// uses the Sales_data constructor that takes an ISBN, a count, and a price</span>
c<span class="token punctuation">.</span><span class="token function">emplace_front</span><span class="token punctuation">(</span><span class="token string">&quot;978-0590353403&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">15.99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型<br> 的构造函数相匹配。</li></ul><h3 id="_9-3-1节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-1节练习" aria-hidden="true">#</a> 9.3.1节练习</h3><ul><li>练习9.18：编写程序，从标准输入读取string序列，存入一个deque中。<br> 编写一个循环，用迭代器打印deque中的元素。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>deque<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> input<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>string str<span class="token punctuation">;</span> cin <span class="token operator">&gt;&gt;</span> str<span class="token punctuation">;</span> input<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> input<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.19：重写上题的程序，用list替代deque。列出程序要做出哪些改变。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> input<span class="token punctuation">;</span> 
<span class="token comment">//改为</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> input<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.20：编写程序，从一个<code>list&lt;int&gt;</code>拷贝元素到两个deque中。值为偶<br> 数的所有元素都拷贝到一个deque中，而奇数值元素都拷贝到另一个deque中。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>deque<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>list<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> l<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> odd<span class="token punctuation">,</span> even<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> l<span class="token punctuation">)</span>
        <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x1</span> <span class="token operator">?</span> odd <span class="token operator">:</span> even<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> odd<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> even<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.21：如果我们将第308页中使用<code>insert</code>返回值将元素添加到<code>list</code>中的循环程序改写为将元素插入到<code>vector</code>中，分析循环将如何工作。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>一样的。如书上所说：

 第一次调用 \`insert\` 会将我们刚刚读入的 \`string\` 插入到 \`iter\` 所指向的元素之前的位置。\`insert\` 返回的迭代器恰好指向这个新元素。我们将此迭代器赋予 \`iter\` 并重复循环，读取下一个单词。只要继续有单词读入，每步 <span class="token keyword">while</span> 循环就会将一个新元素插入到 \`iter\` 之前，并将 \`iter\` 改变为新加入元素的尾置。此元素为（新的）首元素。因此，每步循环将一个元素插入到 \`list\` 首元素之前的位置。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.22：假定iv是一个int的vector，下面的程序存在什么错误？你将如何修改？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter <span class="token operator">=</span> iv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
					  mid <span class="token operator">=</span> iv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> iv<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> mid<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter <span class="token operator">==</span> some_val<span class="token punctuation">)</span>
		iv<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> some_val<span class="token punctuation">)</span><span class="token punctuation">;</span>



<span class="token operator">*</span> 循环不会结束
<span class="token operator">*</span> 迭代器可能会失效

要改为下面这样：


<span class="token keyword">while</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> mid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter <span class="token operator">==</span> some_val<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		iter <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> some_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>iter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token operator">++</span>iter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>



</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-2-访问元素" tabindex="-1"><a class="header-anchor" href="#_9-3-2-访问元素" aria-hidden="true">#</a> 9.3.2　访问元素</h3><ul><li><p>表9.6列出了我们可以用来在顺序容器中访问元素的操作。如果容<br> 器中没有元素，访问操作的结果是未定义的。</p></li><li><p>包括array在内的每个顺序容器都有一个front成员函数，而除<br> forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分<br> 别返回首元素和尾元素的引用：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// check that there are elements before dereferencing an iterator or calling front or back</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// val and val2 are copies of the value of the first element in c</span>
    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token operator">*</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> val2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// val3 and val4 are copies of the of the last element in c</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> val3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// can&#39;t decrement forward_list iterators</span>
    <span class="token keyword">auto</span> val4 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not supported by forward_list</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此程序用两种不同方式来获取c中的首元素和尾元素的引用。直接<br> 的方法是调用front和back。而间接的方法是通过解引用begin返回的迭代<br> 器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来<br> 获得尾元素的引用。</p></li><li><p>这个程序有两点值得注意：迭代器end指向的是容器尾元素之后的<br> （不存在的）元素。为了获取尾元素，必须首先递减此迭代器。另一个<br> 重要之处是，在调用front和back（或解引用begin和end返回的迭代器）<br> 之前，要确保c非空。如果容器为空，if中操作的行为将是未定义的。<br><img src="`+m+`" alt="table9-6" loading="lazy"></p></li></ul><br><ul><li><mark>访问成员函数返回的是引用</mark></li><li>在容器中访问元素的成员函数（即，front、back、下标和at）返回<br> 的都是引用。如果容器是一个const对象，则返回值是const的引用。如<br> 果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// assigns 42 to the first element in c</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>v <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get a reference to the last element</span>
    v <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">// changes the element in c</span>
    <span class="token keyword">auto</span> v2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// v2 is not a reference; it&#39;s a copy of c.back()</span>
    v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// no change to the element in c</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>与往常一样，如果我们使用auto变量来保存这些函数的返回值，并<br> 且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。</li></ul><br><ul><li><p><mark>下标操作和安全的随机访问</mark></p></li><li><p>提供快速随机访问的容器（string、vector、deque和array）也都提<br> 供下标运算符（参见3.3.3节，第91页）。就像我们已经看到的那样，下<br> 标运算符接受一个下标参数，返回容器中该位置的元素的引用。给定下<br> 标必须“在范围内”（即，大于等于0，且小于容器的大小）。保证下标<br> 有效是程序员的责任，下标运算符并不检查下标是否在合法范围内。使<br> 用越界的下标是一种严重的程序设计错误，而且编译器并不检查这种错误。</p></li><li><p>如果我们希望确保下标是合法的，可以使用at成员函数。at成员函<br> 数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常<br> （参见5.6节，第173页）：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span> <span class="token comment">// empty vector</span>
cout <span class="token operator">&lt;&lt;</span> svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// run-time error: there are no elements in svec!</span>
cout <span class="token operator">&lt;&lt;</span> svec<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throws an out_of_range exception</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-2节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-2节练习" aria-hidden="true">#</a> 9.3.2节练习</h3><ul><li>练习9.23：在本节第一个程序（第309页）中，若c.size（）为1，则val、val2、val3和val4的值会是什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>都会是同一个值（容器中仅有的那个）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>练习9.24：编写程序，分别使用at、下标运算符、front和begin提取一个vector中的第一个元素。在一个空vector上测试你的程序。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// terminating with uncaught exception of type std::out_of_range</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// Segmentation fault: 11</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Segmentation fault: 11</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Segmentation fault: 11</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-3-删除元素" tabindex="-1"><a class="header-anchor" href="#_9-3-3-删除元素" aria-hidden="true">#</a> 9.3.3　删除元素</h3><ul><li><p>与添加元素的多种方式类似，（非array）容器也有多种删除元素的<br> 方式。表9.7列出了这些成员函数。</p></li><li><p>删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它<br> （们）是存在的。<br><img src="`+g+`" alt="table9-7" loading="lazy"></p></li></ul><br><ul><li><p><mark>pop_front和pop_back成员函数</mark></p></li><li><p>pop_front和pop_back成员函数分别删除首元素和尾元素。与vector<br> 和string不支持push_front一样，这些类型也不支持pop_front。类似的，<br> forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空<br> 容器执行弹出操作。</p></li><li><p>这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹<br> 出操作之前保存它：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ilist<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">process</span><span class="token punctuation">(</span>ilist<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// do something with the current top of ilist</span>
    ilist<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// done; remove the first element</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>从容器内部删除一个元素</mark></p></li><li><p>成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭<br> 代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元<br> 素。两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭<br> 代器。即，若j是i之后的元素，那么erase（i）将返回指向j的迭代器。</p></li><li><p>例如，下面的循环删除一个list中的所有奇数元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// if the element is odd</span>
        it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// erase this element</span>
    <span class="token keyword">else</span>
        <span class="token operator">++</span>it<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>每个循环步中，首先检查当前元素是否是奇数。如果是，就删除该<br> 元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我<br> 们将it递增，从而在下一步循环检查下一个元素。</li></ul><br><ul><li><mark>删除多个元素</mark></li><li>接受一对迭代器的erase版本允许我们删除一个范围内的元素：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// delete the range of elements between two iterators</span>
<span class="token comment">// returns an iterator to the element just after the last removed element</span>
elem1 <span class="token operator">=</span> slist<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>elem1<span class="token punctuation">,</span> elem2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// after the call elem1 == elem2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除<br> 的最后一个元素之后的位置。</p></li><li><p>为了删除一个容器中的所有元素，我们既可以调用clear，也可以用<br> begin和end获得的迭代器作为参数调用erase：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>slist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// delete all the elements within the container</span>
slist<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> slist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-3节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-3节练习" aria-hidden="true">#</a> 9.3.3节练习</h3><ul><li>练习9.25：对于第312页中删除一个范围内的元素的程序，如果elem1与<br> elem2相等会发生什么？如果elem2是尾后迭代器，或者elem1和elem2皆<br> 为尾后迭代器，又会发生什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span> 如果 \`elem1\` 和 \`elem2\` 相等，那么不会发生任何操作。
<span class="token operator">*</span> \`如果elem2\` 是尾后迭代器，那么删除从 \`elem1\` 到最后的元素。
<span class="token operator">*</span> 如果两者皆为尾后迭代器，也什么都不会发生。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.26：使用下面代码定义的ia，将ia拷贝到一个vector和一个list中。<br> 使用单迭代器版本的erase从list中删除奇数元素，从vector中删除偶数元素。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

jie<span class="token operator">:</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">lst</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span>
		it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> 
		<span class="token operator">++</span>it<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token operator">++</span>it<span class="token punctuation">;</span>			

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-4-特殊的forward-list操作" tabindex="-1"><a class="header-anchor" href="#_9-3-4-特殊的forward-list操作" aria-hidden="true">#</a> 9.3.4　特殊的forward_list操作</h3><ul><li><p>为了理解forward_list为什么有特殊版本的添加和删除操作，考虑当<br> 我们从一个单向链表中删除一个元素时会发生什么。如图9.1所示，删<br> 除一个元素会改变序列中的链接。在此情况下，删除elem3会改变<br> elem2，elem2原来指向elem3，但删除elem3后，elem2指向了elem4。<br><img src="`+f+'" alt="figure9-1" loading="lazy"></p></li><li><p>当添加或删除一个元素时，删除或添加的元素之前的那个元素的后<br> 继会发生改变。为了添加或删除一个元素，我们需要访问其前驱，以便<br> 改变前驱的链接。但是，forward_list是单向链表。在一个单向链表中，<br> 没有简单的方法来获取一个元素的前驱。出于这个原因，在一个<br> forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来<br> 完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。</p></li><li><p>由于这些操作与其他容器上的操作的实现方式不同，forward_list并<br> 未定义insert、emplace和erase，而是定义了名为insert_after、<br> emplace_after和erase_after的操作（参见表9.8）。例如，在我们的例子<br> 中，为了删除elem3，应该用指向elem2的迭代器调用 erase_after。为了支<br> 持这些操作，forward_list也定义了before_begin，它返回一个首前（offthe-beginning）迭代器。<br> 这个迭代器允许我们在链表首元素之前并不存<br> 在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。<br><img src="'+h+`" alt="table9-8" loading="lazy"></p></li><li><p>当在forward_list中添加或删除元素时，我们必须关注两个迭代器<br> ——一个指向我们要处理的元素，另一个指向其前驱。例如，可以改写<br> 第312页中从list中删除奇数元素的循环程序，将其改为从forward_list中<br> 删除元素：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> flst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// denotes element &quot;off the start&quot; of flst</span>
<span class="token keyword">auto</span> curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// denotes the first element in flst</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> flst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// while there are still elements to process</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>curr <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// if the element is odd</span>
        curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// erase it and move curr</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span> <span class="token comment">// move the iterators to denote the next</span>
        <span class="token operator">++</span>curr<span class="token punctuation">;</span> <span class="token comment">// element and one before the next element</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此例中，curr表示我们要处理的元素，prev表示curr的前驱。调用<br> begin来初始化curr，这样第一步循环就会检查第一个元素是否是奇数。<br> 我们用before_begin来初始化prev，它返回指向curr之前不存在的元素的<br> 迭代器。</p></li><li><p>当找到奇数元素后，我们将prev传递给erase_after。此调用将prev之<br> 后的元素删除，即，删除curr指向的元素。然后我们将curr重置为<br> erase_after的返回值，使得curr指向序列中下一个元素，prev保持不变，<br> 仍指向（新）curr之前的元素。如果curr指向的元素不是奇数，在else中<br> 我们将两个迭代器都向前移动。</p></li></ul><h3 id="_9-3-4节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-4节练习" aria-hidden="true">#</a> 9.3.4节练习</h3><ul><li>练习9.27：编写程序，查找并删除<code>forward_list&lt;int&gt;</code>中的奇数元素。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;forward_list&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>forward_list<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>

<span class="token keyword">auto</span> <span class="token function">remove_odds</span><span class="token punctuation">(</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> flist<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> is_odd <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    flist<span class="token punctuation">.</span><span class="token function">remove_if</span><span class="token punctuation">(</span>is_odd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">remove_odds</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> data<span class="token punctuation">)</span> 
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.28：编写函数，接受一个<code>forward_list&lt;string&gt;</code>和两个string共三个<br> 参数。函数应在链表中查找第一个string，并将第二个string插入到紧接<br> 着第一个string之后的位置。若第一个string未在链表中，则将第二个<br> string插入到链表末尾。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">find_and_insert</span><span class="token punctuation">(</span>forward_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> flst<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> flst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>curr <span class="token operator">==</span> s1<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			flst<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
	    <span class="token operator">++</span>curr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    flst<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-5-改变容器大小" tabindex="-1"><a class="header-anchor" href="#_9-3-5-改变容器大小" aria-hidden="true">#</a> 9.3.5　改变容器大小</h3><ul><li>如表9.9所描述，我们可以用resize来增大或缩小容器，与往常一<br> 样，array不支持resize。如果当前大小大于所要求的大小，容器后部的<br> 元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ilist</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ten ints: each has value 42</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// adds five elements of value 0 to the back of ilist</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// adds ten elements of value -1 to the back of ilist</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// erases 20 elements from the back of ilist</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>resize操作接受一个可选的元素值参数，用来初始化添加到容器中<br> 的元素。如果调用者未提供此参数，新元素进行值初始化（参见3.3.1<br> 节，第88页）。如果容器保存的是类类型元素，且resize向容器添加新<br> 元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。<br><img src="`+y+`" alt="table9-9" loading="lazy"></li></ul><h3 id="_9-3-5节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-5节练习" aria-hidden="true">#</a> 9.3.5节练习</h3><ul><li>练习9.29：假定vec包含25个元素，那么vec.resize（100）会做什么？如<br> 果接下来调用vec.resize（10）会做什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>解：

<span class="token operator">*</span> 将<span class="token number">75</span>个值为<span class="token number">0</span>的元素添加到\`vec\`的末尾
<span class="token operator">*</span> 从\`vec\`的末尾删除<span class="token number">90</span>个元素
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.30：接受单个参数的resize版本对元素类型有什么限制（如果有的话）？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>元素类型必须提供一个默认构造函数。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_9-3-6-容器操作可能使迭代器失效" tabindex="-1"><a class="header-anchor" href="#_9-3-6-容器操作可能使迭代器失效" aria-hidden="true">#</a> 9.3.6　容器操作可能使迭代器失效</h3><ul><li><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元<br> 素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再<br> 表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计<br> 错误，很可能引起与使用未初始化指针一样的问题（参见2.3.2节，第49页）</p></li><li><p>在向容器添加元素后：</p><ul><li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li><li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li><li>对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。</li></ul></li><li><p>当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：</p><ul><li>对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。</li><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li><li>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li></ul></li><li><p><mark>使用失效的迭代器、指针或引用是严重的运行时错误。</mark></p></li></ul><br><ul><li><p><mark>建议：管理迭代器</mark></p></li><li><p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保<br> 持有效的程序片段是一个好的方法。</p></li><li><p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必<br> 须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string<br> 和deque尤为重要。</p></li></ul><br><ul><li><mark>编写改变容器的循环程序</mark></li><li>添加/删除vector、string或deque元素的循环程序必须考虑迭代器、<br> 引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代<br> 器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器<br> 很容易。这些操作都返回迭代器，我们可以用来更新：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// silly loop to remove even-valued elements and insert a duplicate of odd-valued elements</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call begin, not cbegin because we&#39;re changing vi</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// duplicate the current element</span>
        iter <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// advance past this element and the one inserted before it</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
        iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// remove even elements</span>
        <span class="token comment">// don&#39;t advance the iterator; iter denotes the element after the one we erased</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此程序删除vector中的偶数值元素，并复制每个奇数值元素。我们<br> 在调用insert和erase后都更新迭代器，因为两者都会使迭代器失效。</p></li><li><p>在调用erase后，不必递增迭代器，因为erase返回的迭代器已经指向<br> 序列中下一个元素。调用insert后，需要递增迭代器两次。记住，insert<br> 在给定位置之前插入新元素，然后返回指向新插入元素的迭代器。因<br> 此，在调用insert后，iter指向新插入元素，位于我们正在处理的元素之<br> 前。我们将迭代器递增两次，恰好越过了新添加的元素和正在处理的元<br> 素，指向下一个未处理的元素。</p></li></ul><br><ul><li><p><mark>不要保存end返回的迭代器</mark></p></li><li><p>当我们添加/删除vector或string的元素后，或在deque中首元素之外<br> 任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，<br> 添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存<br> end返回的迭代器，一直当作容器末尾使用。通常C++标准库的实现中<br> end（）操作都很快，部分就是因为这个原因。</p></li><li><p>例如，考虑这样一个循环，它处理容器中的每个元素，在其后添加<br> 一个新元素。我们希望循环能跳过新添加的元素，只处理原有元素。在<br> 每步循环之后，我们将定位迭代器，使其指向下一个原有元素。如果我<br> 们试图“优化”这个循环，在循环之前保存end（）返回的迭代器，一直<br> 用作容器末尾，就会导致一场灾难：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// disaster: the behavior of this loop is undefined</span>
<span class="token keyword">auto</span> begin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bad idea, saving the value of the end iterator</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do some processing</span>
    <span class="token comment">// insert the new value and reassign begin, which otherwise would be invalid</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span> <span class="token comment">// advance begin because we want to insert after this element</span>
    begin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// insert the new value</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span> <span class="token comment">// advance begin past the element we just added</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此代码的行为是未定义的。在很多标准库实现上，此代码会导致无<br> 限循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局<br> 部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保<br> 存在end中的迭代器失效了。这个迭代器不再指向v中任何元素，或是v<br> 中尾元素之后的位置。</p></li><li><p>如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器。</p></li><li><p>必须在每次插入操作后重新调用end（），而不能在循环开始前保存它返回的迭代器：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// safer: recalculate end on each trip whenever the loop adds/erases elements</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do some processing</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span> <span class="token comment">// advance begin because we want to insert after this element</span>
    begin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// insert the new value</span>
    <span class="token operator">++</span>begin<span class="token punctuation">;</span> <span class="token comment">// advance begin past the element we just added</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-3-6节练习" tabindex="-1"><a class="header-anchor" href="#_9-3-6节练习" aria-hidden="true">#</a> 9.3.6节练习</h3><ul><li>练习9.31：第316页中删除偶数值元素并复制奇数值元素的程序不能用<br> 于list或forward_list。为什么？修改程序，使之也能用于这些类型。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>解：

iter <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>


因为复合赋值语句只能用于\`string\`、\`vector\`、\`deque\`、\`array\`，所以要改为：


<span class="token operator">++</span>iter<span class="token punctuation">;</span>
<span class="token operator">++</span>iter<span class="token punctuation">;</span>


如果是\`forward_list\`的话，要增加一个首先迭代器\`prev\`：


<span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>
curr <span class="token operator">==</span> flst<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">++</span>curr<span class="token punctuation">;</span> <span class="token operator">++</span>curr<span class="token punctuation">;</span>
<span class="token operator">++</span>prev<span class="token punctuation">;</span> <span class="token operator">++</span>prev<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.32：在第316页的程序中，向下面语句这样调用insert是否合法？<br> 如果不合法，为什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

jie<span class="token operator">:</span>
不合法。因为参数的求值顺序是未指定的。


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.33：在本节最后一个例子中，如果不将insert的结果赋予begin，<br> 将会发生什么？编写程序，去掉此赋值语句，验证你的答案。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>\`begin\`将会失效。
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> data <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> cur <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur <span class="token operator">!=</span> data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>cur<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>cur <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span>
            cur <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token operator">*</span>cur<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>cur<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> data<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.34：假定vi是一个保存int的容器，其中有偶数值也有奇数值，分<br> 析下面循环的行为，然后编写程序验证你的分析是否正确。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
		iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>iter<span class="token punctuation">;</span>

循环永远不会结束。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-4-vector对象是如何增长的" tabindex="-1"><a class="header-anchor" href="#_9-4-vector对象是如何增长的" aria-hidden="true">#</a> 9.4 vector对象是如何增长的</h2><ul><li><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨<br> 着前一个元素存储。通常情况下，我们不必关心一个标准库类型是如何<br> 实现的，而只需关心它如何使用。然而，对于vector和string，其部分实<br> 现渗透到了接口中。</p></li><li><p>假定容器中元素是连续存储的，且容器的大小是可变的，考虑向<br> vector或string中添加元素会发生什么：如果没有空间容纳新元素，容器<br> 不可能简单地将它添加到内存中其他位置——因为元素必须连续存储。<br> 容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧<br> 位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们每<br> 添加一个新元素，vector就执行一次这样的内存分配和释放操作，性能<br> 会慢到不可接受。</p></li><li><p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分<br> 配次数的策略。当不得不获取新的内存空间时，vector和string的实现通<br> 常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备<br> 用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新<br> 分配容器的内存空间了。</p></li><li><p>这种分配策略比每次添加新元素时都重新分配容器内存空间的策略<br> 要高效得多。其实际性能也表现得足够好——虽然vector在每次重新分<br> 配内存空间时都要移动所有元素，但使用此策略后，其扩张操作通常比<br> list和deque还要快。</p></li></ul><br><ul><li><p><mark>管理容量的成员函数</mark></p></li><li><p>如表9.10所示，vector和string类型提供了一些成员函数，允许我们<br> 与它的实现中内存分配部分互动。capacity操作告诉我们容器在不扩张<br> 内存空间的情况下可以容纳多少个元素。reserve操作允许我们通知容器<br> 它应该准备保存多少个元素。<br><img src="`+w+`" alt="table9-10" loading="lazy"></p></li><li><p>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。</p></li><li><p>只有当需要的内存空间超过当前容量时，reserve调用才会改变<br> vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一<br> 样大的内存空间（可能更大）。</p></li><li><p>如果需求大小小于或等于当前容量，reserve什么也不做。特别是，<br> 当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用<br> reserve之后，capacity将会大于或等于传递给reserve的参数。</p></li><li><p>这样，调用reserve永远也不会减少容器占用的内存空间。类似的，<br> resize成员函数（参见9.3.5节，第314页）只改变容器中元素的数目，而<br> 不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。</p></li><li><p>在新标准库中，我们可以调用shrink_to_fit来要求deque、vector或<br> string退回不需要的内存空间。此函数指出我们不再需要任何多余的内<br> 存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用<br> shrink_to_fit也并不保证一定退回内存空间。</p></li></ul><br><ul><li><p><mark>capacity和size</mark></p></li><li><p>理解capacity和size的区别非常重要。容器的size是指它已经保存的<br> 元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可<br> 以保存多少元素。</p></li><li><p>下面的代码展示了size和capacity之间的相互作用:</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
<span class="token comment">// size should be zero; capacity is implementation defined</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token comment">// give ivec 24 elements</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>size_type ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">24</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// size should be 24; capacity will be &gt;= 24 and is implementation defined</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>


当在我们的系统上运行时，这段程序得到如下输出：
ivec<span class="token operator">:</span> size<span class="token operator">:</span> <span class="token number">0</span> capacity<span class="token operator">:</span> <span class="token number">0</span>
ivec<span class="token operator">:</span> size<span class="token operator">:</span> <span class="token number">24</span> capacity<span class="token operator">:</span> <span class="token number">32</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>我们知道一个空vector的size为0，显然在我们的标准库实现中一个<br> 空vector的capacity也为0。当向vector中添加元素时，我们知道size与添<br> 加的元素数目相等。而capacity至少与size一样大，具体会分配多少额外<br> 空间则视标准库具体实现而定。在我们的标准库实现中，每次添加1个<br> 元素，共添加24个元素，会使capacity变为32。</p></li><li><p>可以想象ivec的当前状态如下图所示：<br><img src="`+_+`" alt="figure9-0" loading="lazy"></p></li><li><p>现在可以预分配一些额外空间：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ivec<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sets capacity to at least 50; might be more</span>
<span class="token comment">// size should be 24; capacity will be &gt;= 50 and is implementation defined</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>程序的输出表明reserve严格按照我们需求的大小分配了新的空间：<code>ivec: size: 24 capacity: 50</code></p></li><li><p>接下来可以用光这些预留空间：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// add elements to use up the excess capacity</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// capacity should be unchanged and size and capacity are now equal</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>程序输出表明此时我们确实用光了预留空间，size和capacity相等：<br> ivec: size: 50 capacity: 50</p></li><li><p>由于我们只使用了预留空间，因此没有必要为vector分配新的空<br> 间。实际上，只要没有操作需求超出vector的容量，vector就不能重新分<br> 配内存空间。</p></li><li><p>如果我们现在再添加一个新元素，vector就不得不重新分配空间：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// add one more element</span>
<span class="token comment">// size should be 51; capacity will be &gt;= 51 and is implementation defined</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段程序的输出为<br> ivec: size: 51 capacity: 100</p></li><li><p>这表明vector的实现采用的策略似乎是在每次需要分配新内存空间时将当前容量翻倍。</p></li><li><p>可以调用shrink_to_fit来要求vector将超出当前大小的多余内存退回给系统：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>ivec<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ask for the memory to be returned</span>
<span class="token comment">// size should be unchanged; capacity is implementation defined</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ivec: size: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>调用shrink_to_fit只是一个请求，标准库并不保证退还内存。</p></li><li><p>每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只<br> 有当迫不得已时才可以分配新的内存空间。</p></li><li><p>只有在执行insert操作时size与capacity相等，或者调用resize或<br> reserve时给定的大小超过当前capacity，vector才可能重新分配内存空<br> 间。会分配多少超过给定容量的额外空间，取决于具体实现。</p></li><li><p>虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循一<br> 个原则：确保用push_back向vector添加元素的操作有高效率。从技术角<br> 度说，就是通过在一个初始为空的vector上调用n次push_back来创建一<br> 个n个元素的vector，所花费的时间不能超过n的常数倍。</p></li></ul><h3 id="_9-4节练习" tabindex="-1"><a class="header-anchor" href="#_9-4节练习" aria-hidden="true">#</a> 9.4节练习</h3><ul><li>练习9.35：解释一个vector的capacity和size有何区别。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span> \`capacity\`的值表明，在不重新分配内存空间的情况下，容器可以保存多少元素
<span class="token operator">*</span> 而\`size\`的值是指容器已经保存的元素的数量
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>练习9.36：一个容器的capacity可能小于它的size吗？<code>不可能。</code></p></li><li><p>练习9.37：为什么list或array没有capacity成员函数？<br><code>因为</code>list<code>是链表，而</code>array<code>不允许改变容器大小。</code></p></li><li><p>练习9.38：编写程序，探究在你的标准库实现中，vector是如何增长的。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;capacity: &quot;</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;  size: &quot;</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.39：解释下面程序片段做了什么：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> svec<span class="token punctuation">;</span>
svec<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> word<span class="token punctuation">)</span>
	svec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
svec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> svec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


定义一个\`vector\`，为它分配<span class="token number">1024</span>个元素的空间。然后通过一个循环从标准输入中读取字符串并添加到\`vector\`当中。循环结束后，改变\`vector\`的容器大小（元素数量）为原来的<span class="token number">1.5</span>倍，使用元素的默认初始化值填充。如果容器的大小超过<span class="token number">1024</span>，\`vector\`也会重新分配空间以容纳新增的元素。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.40：如果上一题中的程序读入了256个词，在resize之后容器的<br> capacity可能是多少？如果读入了512个、1000个或1048个词呢？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token operator">*</span> 如果读入了<span class="token number">256</span>个词，\`capacity\` 仍然是 <span class="token number">1024</span>
<span class="token operator">*</span> 如果读入了<span class="token number">512</span>个词，\`capacity\` 仍然是 <span class="token number">1024</span>
<span class="token operator">*</span> 如果读入了<span class="token number">1000</span>或<span class="token number">1048</span>个词，\`capacity\` 取决于具体实现。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-5-额外的string操作" tabindex="-1"><a class="header-anchor" href="#_9-5-额外的string操作" aria-hidden="true">#</a> 9.5　额外的string操作</h2><ul><li><p>除了顺序容器共同的操作之外，string类型还提供了一些额外的操<br> 作。这些操作中的大部分要么是提供string类和C风格字符数组之间的相<br> 互转换，要么是增加了允许我们用下标代替迭代器的版本。</p></li><li><p>标准库string类型定义了大量函数。幸运的是，这些函数使用了重<br> 复的模式。由于函数过多，本节初次阅读可能令人心烦，因此读者可能<br> 希望快速浏览本节。当你了解string支持哪些类型的操作后，就可以在<br> 需要使用一个特定操作时回过头来仔细阅读。</p></li></ul><h3 id="_9-5-1-构造string的其他方法" tabindex="-1"><a class="header-anchor" href="#_9-5-1-构造string的其他方法" aria-hidden="true">#</a> 9.5.1　构造string的其他方法</h3><ul><li><p>除了我们在3.2.1节（第76页）已经介绍过的构造函数，以及与其他<br> 顺序容器相同的构造函数（参见表9.3，第299页）外，string类型还支持<br> 另外三个构造函数，如表9.11所示。<br><img src="`+q+`" alt="table9-11" loading="lazy"></p></li><li><p>这些构造函数接受一个string或一个const char*参数，还接受（可选<br> 的）指定拷贝多少个字符的参数。当我们传递给它们的是一个string<br> 时，还可以给定一个下标来指出从哪里开始拷贝：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">&quot;Hello World!!!&quot;</span><span class="token punctuation">;</span> <span class="token comment">// null-terminated array</span>
<span class="token keyword">char</span> noNull<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">&#39;H&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;i&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// not null terminated</span>
string <span class="token function">s1</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy up to the null in cp; s1 == &quot;Hello World!!!&quot;</span>
string <span class="token function">s2</span><span class="token punctuation">(</span>noNull<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy two characters from no_null; s2 == &quot;Hi&quot;</span>
string <span class="token function">s3</span><span class="token punctuation">(</span>noNull<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined: noNull not null terminated</span>
string <span class="token function">s4</span><span class="token punctuation">(</span>cp <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// copy 5 characters starting at cp[6]; s4 == &quot;World&quot;</span>
string <span class="token function">s5</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy 5 characters starting at s1[6]; s5 == &quot;World&quot;</span>
string <span class="token function">s6</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy from s1 [6] to end of s1; s6 == &quot;World!!!&quot;</span>
string <span class="token function">s7</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, copies only to end of s1; s7 == &quot;World!!!&quot;</span>
string <span class="token function">s8</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throws an out_of_range exception</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>通常当我们从一个const char*创建string时，指针指向的数组必须以<br> 空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数<br> 一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组<br> 也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为<br> 是未定义的。</p></li><li><p>当从一个string拷贝字符时，我们可以提供一个可选的开始位置和<br> 一个计数值。开始位置必须小于或等于给定的string的大小。如果位置<br> 大于size，则构造函数抛出一个out_of_range异常（参见5.6节，第173<br> 页）。如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字<br> 符。不管我们要求拷贝多少个字符，标准库最多拷贝到string结尾，不会更多。</p></li></ul><br><ul><li><mark>substr操作</mark></li><li>substr操作（参见表9.12）返回一个string，它是原始string的一部分<br> 或全部的拷贝。可以传递给substr一个可选的开始位置和计数值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 = hello</span>
string s3 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s3 = world</span>
string s4 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s3 = world</span>
string s5 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throws an out_of_range exception</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果开始位置超过了string的大小，则substr函数抛出一个<br> out_of_range异常（参见5.6节，第173页）。如果开始位置加上计数值大<br> 于string的大小，则substr会调整计数值，只拷贝到string的末尾。<br><img src="`+x+`" alt="table9-12" loading="lazy"></li></ul><h3 id="_9-5-1节练习" tabindex="-1"><a class="header-anchor" href="#_9-5-1节练习" aria-hidden="true">#</a> 9.5.1节练习</h3><ul><li>练习9.41：编写程序，从一个<code>vector&lt;char&gt;初始化一个string</code>。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>    vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span> <span class="token char">&#39;h&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;e&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;o&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    string <span class="token function">str</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.42：假定你希望每次读取一个字符存入一个string中，而且知道最<br> 少需要读取100个字符，应该如何提高程序的性能？<br><code>使用 </code>reserve(100)<code> 函数预先分配100个元素的空间。</code></li></ul><h3 id="_9-5-2-改变string的其他方法" tabindex="-1"><a class="header-anchor" href="#_9-5-2-改变string的其他方法" aria-hidden="true">#</a> 9.5.2　改变string的其他方法</h3><ul><li><p>string类型支持顺序容器的赋值运算符以及assign、insert和erase操作<br> （参见9.2.5节，第302页；9.3.1节，第306页；9.3.3节，第311页）。除<br> 此之外，它还定义了额外的insert和erase版本。</p></li><li><p>除了接受迭代器的insert和erase版本外，string还提供了接受下标的<br> 版本。下标指出了开始删除的位置，或是insert到给定值之前的位置：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">&#39;!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// insert five exclamation points at the end of s</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// erase the last five characters from s</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>标准库string类型还提供了接受C风格字符数组的insert和assign版本。<br> 例如，我们可以将以空字符结尾的字符数组insert到或assign给一个string：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">&quot;Stately, plump Buck&quot;</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;Stately&quot;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cp <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;Stately, plump Buck&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此处我们首先通过调用assign替换s的内容。我们赋予s的是从cp指<br> 向的地址开始的7个字符。要求赋值的字符数必须小于或等于cp指向的<br> 数组中的字符数（不包括结尾的空字符）。</p></li><li><p>接下来在s上调用insert，我们的意图是将字符插入到<code>s[size（）]</code>处<br> （不存在的）元素之前的位置。在此例中，我们将cp开始的7个字符<br> （至多到结尾空字符之前）拷贝到s中。</p></li><li><p>我们也可以指定将来自其他string或子字符串的字符插入到当前<br> string中或赋予当前string：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string s <span class="token operator">=</span> <span class="token string">&quot;some string&quot;</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">&quot;some other string&quot;</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// insert a copy of s2 before position 0 in s</span>
<span class="token comment">// insert s2.size() characters from s2 starting at s2[0] before s[0]</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>append和replace函数</mark></li><li>string类定义了两个额外的成员函数：append和replace，这两个函数<br> 可以改变string的内容。表9.13描述了这两个函数的功能。append操作是<br> 在string末尾进行插入操作的一种简写形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;C++ Primer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// initialize s and s2 to &quot;C++ Primer&quot;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot; 4th Ed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;C++ Primer 4th Ed.&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot; 4th Ed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>replace操作是调用erase和insert的一种简写形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;C++ Primer Ed.&quot;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">&quot;5th&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;C++ Primer 5th Ed.&quot;</span>
<span class="token comment">// starting at position 11, erase three characters and then insert &quot;5th&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;5th&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent: s == s2</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>此例中调用replace时，插入的文本恰好与删除的文本一样长。这不<br> 是必须的，可以插入一个更长或更短的string：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;Fifth&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == &quot;C++ Primer Fifth Ed.&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>在此调用中，删除了3个字符，但在其位置插入了5个新字符。<br><img src="`+z+`" alt="table9-13" loading="lazy"></li></ul><br><ul><li><p><mark>改变string的多种重载函数</mark></p></li><li><p>表9.13列出的append、assign、insert和replace函数有多个重载版<br> 本。根据我们如何指定要添加的字符和string中被替换的部分，这些函<br> 数的参数有不同版本。幸运的是，这些函数有共同的接口。</p></li><li><p>assign和append函数无须指定要替换string中哪个部分：assign总是替<br> 换string中的所有内容，append总是将新字符追加到string末尾。</p></li><li><p>replace函数提供了两种指定删除元素范围的方式。可以通过一个位<br> 置和一个长度来指定范围，也可以通过一个迭代器范围来指定。insert<br> 函数允许我们用两种方式指定插入点：用一个下标或一个迭代器。在两<br> 种情况下，新元素都会插入到给定下标（或迭代器）之前的位置。</p></li><li><p>可以用好几种方式来指定要添加到string中的字符。新字符可以来<br> 自于另一个string，来自于一个字符指针（指向的字符数组），来自于<br> 一个花括号包围的字符列表，或者是一个字符和一个计数值。当字符来<br> 自于一个string或一个字符指针时，我们可以传递一个额外的参数来控<br> 制是拷贝部分还是全部字符。</p></li><li><p>并不是每个函数都支持所有形式的参数。例如，insert就不支持下<br> 标和初始化列表参数。类似的，如果我们希望用迭代器指定插入点，就<br> 不能用字符指针指定新字符的来源。</p></li></ul><h3 id="_9-5-2节练习" tabindex="-1"><a class="header-anchor" href="#_9-5-2节练习" aria-hidden="true">#</a> 9.5.2节练习</h3><ul><li>练习9.43：编写一个函数，接受三个string参数s、oldVal和newVal。使<br> 用迭代器及insert和erase函数将s中所有oldVal替换为newVal。测试你的<br> 程序，用它替换通用的简写形式，如，将&quot;tho&quot;替换为&quot;though&quot;，<br> 将&quot;thru&quot;替换为&quot;through&quot;。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstddef&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> 
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> 
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">auto</span> <span class="token function">replace_with</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> oldVal<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> newVal<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">==</span> string<span class="token punctuation">{</span> cur<span class="token punctuation">,</span> cur <span class="token operator">+</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
            cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> cur <span class="token operator">+</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newVal<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newVal<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            cur <span class="token operator">+=</span> newVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>  
            <span class="token operator">++</span>cur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string s<span class="token punctuation">{</span> <span class="token string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">replace_with</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;tho&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;though&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">replace_with</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;thru&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;through&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.44：重写上一题的函数，这次使用一个下标和replace。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> 
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">auto</span> <span class="token function">replace_with</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> oldVal<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> newVal<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> oldVal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> oldVal<span class="token punctuation">)</span>
            s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> oldVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span><span class="token punctuation">,</span>
            pos <span class="token operator">+=</span> newVal<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token operator">++</span>pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string str<span class="token punctuation">{</span> <span class="token string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">replace_with</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">&quot;tho&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;though&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">replace_with</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">&quot;thru&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;through&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.45：编写一个函数，接受一个表示名字的string参数和两个分别表<br> 示前缀（如&quot;Mr.&quot;或&quot;Ms.&quot;）和后缀（如&quot;Jr.&quot;或&quot;III&quot;）的字符串。使用迭<br> 代器及insert和append函数将前缀和后缀添加到给定的名字中，将生成的<br> 新string返回。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token comment">// Exercise 9.45</span>
<span class="token keyword">auto</span> <span class="token function">add_pre_and_suffix</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> string <span class="token keyword">const</span><span class="token operator">&amp;</span> su<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    name<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>su<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;Wang&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_pre_and_suffix</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;Mr.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;, Jr.&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.46：重写上一题的函数，这次使用位置和长度来管理string，并只使用insert。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">auto</span> <span class="token function">add_pre_and_suffix</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> su<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    name<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
    name<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> su<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;alan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_pre_and_suffix</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;Mr.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;,Jr.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-5-3-string搜索操作" tabindex="-1"><a class="header-anchor" href="#_9-5-3-string搜索操作" aria-hidden="true">#</a> 9.5.3 string搜索操作</h3><ul><li><p>string类提供了6个不同的搜索函数，每个函数都有4个重载版本。<br> 表9.14描述了这些搜索成员函数及其参数。每个搜索操作都返回一个<br> string：：size_type值，表示匹配发生位置的下标。如果搜索失败，则返<br> 回一个名为string：：npos的static成员（参见7.6节，第268页）。标准库<br> 将npos定义为一个const string：：size_type类型，并初始化为值-1。由于<br> npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可<br> 能大小（参见2.1.2节，第32页）。</p></li><li><p>string搜索函数返回string：：size_type值，该类型是一个unsigned类型。因此，用<br> 一个int或其他带符号类型来保存这些函数的返回值不是一个好主意（参见2.1.2节，第33页）。</p></li><li><p>find函数完成最简单的搜索。它查找参数指定的字符串，若找到，<br> 则返回第一个匹配位置的下标，否则返回npos：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;AnnaBelle&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> pos1 <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pos1 == 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段程序返回0，即子字符串&quot;Anna&quot;在&quot;AnnaBelle&quot;中第一次出现的下标。</p></li><li><p>搜索（以及其他string操作）是大小写敏感的。当在string中查找子字符串时，要注意大小写：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">lowercase</span><span class="token punctuation">(</span><span class="token string">&quot;annabelle&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pos1 <span class="token operator">=</span> lowercase<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Anna&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pos1 == npos</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段代码会将pos1置为npos，因为Anna与anna不匹配。</p></li><li><p>一个更复杂一些的问题是查找与给定字符串中任何一个字符匹配的<br> 位置。例如，下面代码定位name中的第一个数字：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token string">&quot;0123456789&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">&quot;r2d2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// returns 1, i.e., the index of the first digit in name</span>
<span class="token keyword">auto</span> pos <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果是要搜索第一个不在参数中的字符，我们应该调用<br> find_first_not_of。例如，为了搜索一个string中第一个非数字字符，可以这样做：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">dept</span><span class="token punctuation">(</span><span class="token string">&quot;03714p3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// returns 5, which is the index to the character &#39;p&#39;</span>
<span class="token keyword">auto</span> pos <span class="token operator">=</span> dept<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+S+`" alt="table9-14" tabindex="0" loading="lazy"><figcaption>table9-14</figcaption></figure><br><ul><li><mark>指定在哪里开始搜索</mark></li><li>我们可以传递给find操作一个可选的开始位置。这个可选的参数指<br> 出从哪个位置开始进行搜索。默认情况下，此位置被置为0。一种常见<br> 的程序设计模式是用这个可选参数在字符串中循环地搜索子字符串出现<br> 的所有位置：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string<span class="token double-colon punctuation">::</span>size_type pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// each iteration finds the next number in name</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;found number at index: &quot;</span> <span class="token operator">&lt;&lt;</span> pos <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; element is &quot;</span> <span class="token operator">&lt;&lt;</span> name<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>pos<span class="token punctuation">;</span> <span class="token comment">// move to the next character</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>while的循环条件将pos重置为从pos开始遇到的第一个数字的下标。<br> 只要find_first_of返回一个合法下标，我们就打印当前结果并递增pos。</p></li><li><p>如果我们忽略了递增pos，循环就永远也不会终止。为了搞清楚原<br> 因，考虑如果不做递增运算会发生什么。在第二步循环中，我们从pos<br> 指向的字符开始搜索。这个字符是一个数字，因此find_first_of会（重复<br> 地）返回pos！</p></li></ul><br><ul><li><mark>逆向搜索</mark></li><li>到现在为止，我们已经用过的find操作都是由左至右搜索。标准库<br> 还提供了类似的，但由右至左搜索的操作。rfind成员函数搜索最后一个<br> 匹配，即子字符串最靠右的出现位置：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">river</span><span class="token punctuation">(</span><span class="token string">&quot;Mississippi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> first_pos <span class="token operator">=</span> river<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;is&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 1</span>
<span class="token keyword">auto</span> last_pos <span class="token operator">=</span> river<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span><span class="token string">&quot;is&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>find返回下标1，表示第一个&quot;is&quot;的位置，而rfind返回下标4，表示最<br> 后一个&quot;is&quot;的位置。</p></li><li><p>类似的，find_last函数的功能与find_first函数相似，只是它们返回最后一个而不是第一个匹配：</p><ul><li>find_last_of搜索与给定string中任何一个字符匹配的最后一个字符。</li><li>find_last_not_of搜索最后一个不出现在给定string中的字符。每个操作都接受一个可选的第二参数，可用来指出从什么位置开始搜索。</li></ul></li></ul><h3 id="_9-5-3节练习" tabindex="-1"><a class="header-anchor" href="#_9-5-3节练习" aria-hidden="true">#</a> 9.5.3节练习</h3><ul><li>练习9.47：编写程序，首先查找string &quot;ab2c3d7R4E6&quot;中的每个数字字<br> 符，然后查找其中每个字母字符。编写两个版本的程序，第一个要使用<br> find_first_of，第二个要使用find_first_not_of。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	string <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token string">&quot;0123456789&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;ab2c3d7R4E6&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;numeric characters: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">;</span> <span class="token operator">++</span>pos<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\nalphabetic characters: &quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">;</span> <span class="token operator">++</span>pos<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>练习9.48：假定name和numbers的定义如325页所示，numbers.find（name）返回什么？<br> 返回 <code>string::npos</code></p></li><li><p>练习9.49：如果一个字母延伸到中线之上，如d或f，则称其有上出头部<br> 分（ascender）。如果一个字母延伸到中线之下，如p或g，则称其有下<br> 出头部分（descender）。编写程序，读入一个单词文件，输出最长的既<br> 不包含上出头部分，也不包含下出头部分的单词。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>ifstream<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ifstream <span class="token function">ifs</span><span class="token punctuation">(</span><span class="token string">&quot;../data/letter.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ifs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    string longest<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> update_with <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>longest<span class="token punctuation">]</span><span class="token punctuation">(</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> curr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token double-colon punctuation">::</span>npos <span class="token operator">==</span> curr<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span><span class="token string">&quot;aceimnorsuvwxz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            longest <span class="token operator">=</span> longest<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> curr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> curr <span class="token operator">:</span> longest<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>string curr<span class="token punctuation">;</span> ifs <span class="token operator">&gt;&gt;</span> curr<span class="token punctuation">;</span> <span class="token function">update_with</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> longest <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-5-4-compare函数" tabindex="-1"><a class="header-anchor" href="#_9-5-4-compare函数" aria-hidden="true">#</a> 9.5.4 compare函数</h3><ul><li><p>除了关系运算符外（参见3.2.2节，第79页），标准库string类型还<br> 提供了一组compare函数，这些函数与C标准库的strcmp函数（参见3.5.4<br> 节，第109页）很相似。类似strcmp，根据s是等于、大于还是小于参数<br> 指定的字符串，s.compare返回0、正数或负数。</p></li><li><p>如表9.15所示，compare有6个版本。根据我们是要比较两个string还<br> 是一个string与一个字符数组，参数各有不同。在这两种情况下，都可<br> 以比较整个或一部分字符串。<br><img src="`+V+`" alt="table9-15" loading="lazy"></p></li></ul><h3 id="_9-5-5-数值转换" tabindex="-1"><a class="header-anchor" href="#_9-5-5-数值转换" aria-hidden="true">#</a> 9.5.5　数值转换</h3><ul><li><p>字符串中常常包含表示数值的字符。例如，我们用两个字符的<br> string表示数值15——字符&#39;1&#39;后跟字符&#39;5&#39;。一般情况，一个数的字符表示<br> 不同于其数值。数值15如果保存为16位的short类型，则其二进制位模式<br> 为0000000000001111，而字符串&quot;15&quot;存为两个Latin-1编码的char，二进<br> 制位模式为0011000100110101。第一个字节表示字符&#39;1&#39;，其八进制值为<br> 061，第二个字节表示&#39;5&#39;，其Latin-1编码为八进制值065。</p></li><li><p>新标准引入了多个函数，可以实现数值数据与标准库string之间的转换：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// converts the int i to its character representation</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// converts the string s to floating-point</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>此例中我们调用to_string将42转换为其对应的string表示，然后调用<br> stod将此string转换为浮点值。</p></li><li><p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string s2 <span class="token operator">=</span> <span class="token string">&quot;pi = 3.14&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// convert the first substring in s that starts with a digit, d = 3.14</span>
d <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;+-.0123456789&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在这个stod调用中，我们调用了find_first_of（参见9.5.3节，第325<br> 页）来获得s中第一个可能是数值的一部分的字符的位置。我们将s中从<br> 此位置开始的子串传递给stod。stod函数读取此参数，处理其中的字<br> 符，直至遇到不可能是数值的一部分的字符。然后它就将找到的这个数<br> 值的字符串表示形式转换为对应的双精度浮点值。</p></li><li><p>string参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以<br> 以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函<br> 数，string参数也可以以小数点（.）开头，并可以包含e或E来表示指数<br> 部分。对于那些将字符串转换为整型值的函数，根据基数不同，string<br> 参数可以包含字母字符，对应大于数字9的数。</p></li><li><p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常（参见5.6<br> 节，第173页）。如果转换得到的数值无法用任何类型来表示，则抛出一个<br> out_of_range异常。<br><img src="`+C+`" alt="table9-16" loading="lazy"></p></li></ul><h3 id="_9-5-5节练习" tabindex="-1"><a class="header-anchor" href="#_9-5-5节练习" aria-hidden="true">#</a> 9.5.5节练习</h3><ul><li>练习9.50：编写程序处理一个<code>vector&lt;string&gt;</code>，其元素都表示整型值。计<br> 算vector中所有元素之和。修改程序，使之计算表示浮点值的string之和。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">auto</span> <span class="token function">sum_for_int</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> v<span class="token punctuation">)</span>
        sum <span class="token operator">+=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> <span class="token function">sum_for_float</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> v<span class="token punctuation">)</span>
        sum <span class="token operator">+=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;4.5&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum_for_int</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum_for_float</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习9.51：设计一个类，它有三个unsigned成员，分别表示年、月和<br> 日。为其编写构造函数，接受一个表示日期的string参数。你的构造函<br> 数应该能处理不同数据格式，如January 1，1900、1/1/1990、Jan 1 1900等。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">My_date</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">unsigned</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">My_date</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">unsigned</span> tag<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> format<span class="token punctuation">;</span>
        format <span class="token operator">=</span> tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment">// 1/1/1900</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token operator">!=</span> string <span class="token double-colon punctuation">::</span> npos<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            format <span class="token operator">=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// January 1, 1900 or Jan 1, 1900</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token char">&#39;,&#39;</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token char">&#39;,&#39;</span><span class="token punctuation">)</span><span class="token operator">!=</span> string <span class="token double-colon punctuation">::</span> npos<span class="token punctuation">)</span><span class="token punctuation">{</span>
            format <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment">// Jan 1 1900</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span>
                <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span><span class="token operator">!=</span> string <span class="token double-colon punctuation">::</span> npos<span class="token punctuation">)</span><span class="token punctuation">{</span>
                format <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>
                tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">switch</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">case</span> <span class="token number">0x01</span><span class="token operator">:</span>
            day <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            month <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token operator">-</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            year <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">break</span><span class="token punctuation">;</span>

        <span class="token keyword">case</span> <span class="token number">0x10</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Jan&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Feb&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Mar&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Apr&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;May&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Jun&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Jul&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Aug&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Sep&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Oct&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Nov&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;Dec&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  month <span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>

            <span class="token keyword">char</span> chr <span class="token operator">=</span> <span class="token char">&#39;,&#39;</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                chr <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            day <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;123456789&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>chr<span class="token punctuation">)</span> <span class="token operator">-</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;123456789&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            year <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token char">&#39; &#39;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;day:&quot;</span> <span class="token operator">&lt;&lt;</span> day <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;month: &quot;</span> <span class="token operator">&lt;&lt;</span> month <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;year: &quot;</span> <span class="token operator">&lt;&lt;</span> year<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    My_date <span class="token function">d</span><span class="token punctuation">(</span><span class="token string">&quot;Jan 1 1900&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    d<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-6-容器适配器" tabindex="-1"><a class="header-anchor" href="#_9-6-容器适配器" aria-hidden="true">#</a> 9.6　容器适配器</h2><ul><li>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、<br> queue和priority_queue。适配器（adaptor）是标准库中的一个通用概<br> 念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机<br> 制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器<br> 接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，<br> stack适配器接受一个顺序容器（除array或forward_list外），并使其操作<br> 起来像一个stack一样。表9.17列出了所有容器适配器都支持的操作和类型。<br><img src="`+A+`" alt="table9-17" loading="lazy"></li></ul><br><ul><li><p><mark>定义一个适配器</mark></p></li><li><p>每个适配器都定义两个构造函数：默认构造函数创建一个空对象，<br> 接受一个容器的构造函数拷贝该容器来初始化适配器。例如，假定deq<br> 是一个<code>deque&lt;int&gt;</code>，我们可以用deq来初始化一个新的stack，如下所示：<br><code>stack&lt;int&gt; stk(deq); // copies elements from deq into stk</code></p></li><li><p>默认情况下，stack和queue是基于deque实现的，priority_queue是在<br> vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容<br> 器作为第二个类型参数，来重载默认容器类型。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// empty stack implemented on top of vector</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> str_stk<span class="token punctuation">;</span>
<span class="token comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">str_stk2</span><span class="token punctuation">(</span>svec<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配<br> 器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在<br> array之上。类似的，我们也不能用forward_list来构造适配器，因为所有<br> 适配器都要求容器具有添加、删除以及访问尾元素的能力。stack只要求<br> push_back、pop_back和back操作，因此可以使用除array和forward_list之<br> 外的任何容器类型来构造stack。queue适配器要求back、push_back、<br> front和push_front，因此它可以构造于list或deque之上，但不能基于<br> vector构造。priority_queue除了front、push_back和pop_back操作之外还<br> 要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于<br> list构造。</li></ul><br><ul><li><mark>栈适配器</mark></li><li>stack类型定义在stack头文件中。表9.18列出了stack所支持的操作。<br> 下面的程序展示了如何使用stack：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> intStack<span class="token punctuation">;</span> <span class="token comment">// empty stack</span>
<span class="token comment">// fill up the stack</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span>
    intStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// intStackholds 0 ... 9 inclusive</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>intStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// while there are still values in intStack</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> intStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// code that uses value</span>
    intStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pop the top element, and repeat</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>其中，声明语句:<code>stack&lt;int&gt; intStack; // empty stack</code></p></li><li><p>定义了一个保存整型元素的栈intStack，初始时为空。for循环将10<br> 个元素添加到栈中，这些元素被初始化为从0开始连续的整数。while循<br> 环遍历整个stack，获取top值，将其从栈中弹出，直至栈空。<br><img src="`+E+'" alt="table9-18" loading="lazy"></p></li><li><p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操<br> 作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。例<br> 如，<code>intStack.push(ix); // intStackholds 0 ... 9 inclusive</code></p></li><li><p>此语句试图在intStack的底层deque对象上调用push_back。虽然stack<br> 是基于deque实现的，但我们不能直接使用deque操作。不能在一个stack<br> 上调用push_back，而必须使用stack自己的操作——push。</p></li></ul><br><ul><li><p><mark>队列适配器</mark></p></li><li><p>queue和priority_queue适配器定义在queue头文件中。表9.19列出了<br> 它们所支持的操作。<br><img src="'+j+`" alt="table9-19" loading="lazy"></p></li><li><p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储<br> 和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队<br> 首删除。饭店按客人到达的顺序来为他们安排座位，就是一个先进先出<br> 队列的例子。</p></li><li><p>priority_queue允许我们为队列中的元素建立优先级。新加入的元素<br> 会排在所有优先级比它低的已有元素之前。饭店按照客人预定时间而不<br> 是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。默认<br> 情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级。我们将<br> 在11.2.2节（第378页）学习如何重载这个默认设置。</p></li></ul><h3 id="_9-6节练习" tabindex="-1"><a class="header-anchor" href="#_9-6节练习" aria-hidden="true">#</a> 9.6节练习</h3><ul><li>练习9.52：使用stack处理括号化的表达式。当你看到一个左括号，将其<br> 记录下来。当你在一个左括号之后看到一个右括号，从stack中pop对<br> 象，直至遇到左括号，将左括号也一起弹出栈。然后将一个值（括号内<br> 的运算结果）push到栈中，表示一个括号化的（子）表达式已经处理完<br> 毕，被其运算结果所替代。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>stack<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string expression<span class="token punctuation">{</span> <span class="token string">&quot;This is (pezy).&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> bSeen <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> stk<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> expression<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token char">&#39;(&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> bSeen <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token char">&#39;)&#39;</span><span class="token punctuation">)</span> bSeen <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bSeen<span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    string repstr<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        repstr <span class="token operator">+=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    expression<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> repstr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> expression <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><ul><li><p>标准库容器是模板类型，用来保存给定类型的对象。在一个顺序容<br> 器中，元素是按顺序存放的，通过位置来访问。顺序容器有公共的标准<br> 接口：如果两个顺序容器都提供一个特定的操作，那么这个操作在两个<br> 容器中具有相同的接口和含义。</p></li><li><p>所有容器（除array外）都提供高效的动态内存管理。我们可以向容<br> 器中添加元素，而不必担心元素存储在哪里。容器负责管理自身的存<br> 储。vector和string都提供更细致的内存管理控制，这是通过它们的<br> reserve和capacity成员函数来实现的。</p></li><li><p>很大程度上，容器只定义了极少的操作。每个容器都定义了构造函<br> 数、添加和删除元素的操作、确定容器大小的操作以及返回指向特定元<br> 素的迭代器的操作。其他一些有用的操作，如排序或搜索，并不是由容<br> 器类型定义的，而是由标准库算法实现的，我们将在第10章介绍这些内容。</p></li><li><p>当我们使用添加和删除元素的容器操作时，必须注意这些操作可能<br> 使指向容器中元素的迭代器、指针或引用失效。很多会使迭代器失效的<br> 操作，如insert和erase，都会返回一个新的迭代器，来帮助程序员维护<br> 容器中的位置。如果循环程序中使用了改变容器大小的操作，就要尤其<br> 小心其中迭代器、指针和引用的使用。</p></li></ul><h2 id="术语表" tabindex="-1"><a class="header-anchor" href="#术语表" aria-hidden="true">#</a> 术语表</h2><ul><li><p>适配器（adaptor） 标准库类型、函数或迭代器，它们接受一个类<br> 型、函数或迭代器，使其行为像另外一个类型、函数或迭代器一样。标<br> 准库提供了三种顺序容器适配器：stack、queue和priority_queue。每个<br> 适配器都在其底层顺序容器类型之上定义了一个新的接口。</p></li><li><p>数组（array）固定大小的顺序容器。为了定义一个array，除了元<br> 素类型之外还必须给定大小。array中的元素可以用其位置下标来访问。<br> array支持快速的随机访问。</p></li><li><p>begin 容器操作，返回一个指向容器首元素的迭代器，如果容器为<br> 空，则返回尾后迭代器。是否返回const迭代器依赖于容器的类型。</p></li><li><p>cbegin 容器操作，返回一个指向容器首元素的const_iterator，如果<br> 容器为空，则返回尾后迭代器。</p></li><li><p>cend 容器操作，返回一个指向容器尾元素之后（不存在的）的<br> const_iterator。</p></li><li><p>容器（container）保存一组给定类型对象的类型。每个标准库容器<br> 类型都是一个模板类型。为了定义一个容器，我们必须指定保存在容器<br> 中的元素的类型。除了array之外，标准库容器都是大小可变的。</p></li><li><p>deque 顺序容器。deque中的元素可以通过位置下标来访问。支持快<br> 速的随机访问。deque各方面都与vector类似，唯一的差别是，deque支<br> 持在容器头尾位置的快速插入和删除，而且在两端插入或删除元素都不<br> 会导致重新分配空间。</p></li><li><p>end 容器操作，返回一个指向容器尾元素之后（不存在的）元素的<br> 迭代器。是否返回const迭代器依赖于容器的类型。</p></li><li><p>forward_list 顺序容器，表示一个单向链表。forward_list中的元素<br> 只能顺序访问。从一个给定元素开始，为了访问另一个元素，我们只能<br> 遍历两者之间的所有元素。forward_list上的迭代器不支持递减运算（-<br> -）。forward_list支持任意位置的快速插入（或删除）操作。与其他容<br> 器不同，插入和删除发生在一个给定的迭代器之后的位置。因此，除了<br> 通常的尾后迭代器之外，forward_list还有一个“首前”迭代器。在添加新<br> 元素后，原有的指向forward_list的迭代器仍有效。在删除元素后，只有<br> 原来指向被删元素的迭代器才会失效。</p></li><li><p>迭代器范围（iterator range） 由一对迭代器指定的元素范围。第<br> 一个迭代器表示序列中第一个元素，第二个迭代器指向最后一个元素之<br> 后的位置。如果范围为空，则两个迭代器是相等的（反之亦然，如果两<br> 个迭代器不等，则它们表示一个非空范围）。如果范围非空，则必须保<br> 证，通过反复递增第一个迭代器，可以到达第二个迭代器。通过递增迭<br> 代器，序列中每个元素都能被访问到。</p></li><li><p>左闭合区间（left-inclusive interval） 值范围，包含首元素，但不<br> 包含尾元素。通常表示为<code>[i，j）</code>，表示序列从i开始（包含）直至j结束<br> （不包含）。</p></li><li><p>list 顺序容器，表示一个双向链表。list中的元素只能顺序访问。从<br> 一个给定元素开始，为了访问另一个元素，我们只能遍历两者之间的所<br> 有元素。list上的迭代器既支持递增运算（++），也支持递减运算（-<br> -）。list支持任意位置的快速插入（或删除）操作。当加入新元素后，<br> 迭代器仍然有效。当删除元素后，只有原来指向被删除元素的迭代器才<br> 会失效。</p></li><li><p>首前迭代器（off-the-beginning iterator）表示一个forward_list开始<br> 位置之前（不存在的）元素的迭代器。是forward_list的成员函数<br> before_begin的返回值。与end（）迭代器类似，不能被解引用。</p></li><li><p>尾后迭代器（off-the-end iterator） 表示范围中尾元素之后位置的<br> 迭代器。通常被称为“末尾迭代器”（end iterator）。</p></li><li><p>priority_queue 顺序容器适配器，生成一个队列，插入其中的元素<br> 不放在末尾，而是根据特定的优先级排列。默认情况下，优先级用元素<br> 类型上的小于运算符确定。</p></li><li><p>queue 顺序容器适配器，生成一个类型，使我们能将新元素添加到<br> 末尾，从头部删除元素。</p></li><li><p>顺序容器（sequential container） 保存相同类型对象有序集合的类<br> 型。顺序容器中的元素通过位置来访问</p></li><li><p>stack 顺序容器适配器，生成一个类型，使我们只能在其一端添加<br> 和删除元素。</p></li><li><p>vector 顺序容器。vector中的元素可以通过位置下标访问。支持快<br> 速的随机访问。我们只能在vector末尾实现高效的元素添加/删除。向<br> vector添加元素可能导致内存空间的重新分配，从而使所有指向vector的<br> 迭代器失效。在vector内部添加（或删除）元素会使所有指向插入（删<br> 除）点之后元素的迭代器失效。</p></li></ul>`,373);function P(D,F){const a=c("router-link");return l(),i("div",null,[B,M,u(" more "),J,n("nav",N,[n("ul",null,[n("li",null,[t(a,{to:"#第九章顺序容器"},{default:p(()=>[s("第九章顺序容器")]),_:1})]),n("li",null,[t(a,{to:"#_9-1-顺序容器概述"},{default:p(()=>[s("9.1　顺序容器概述")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-1节练习"},{default:p(()=>[s("9.1节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_9-2-容器库概览"},{default:p(()=>[s("9.2　容器库概览")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-2节练习"},{default:p(()=>[s("9.2节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-1-迭代器"},{default:p(()=>[s("9.2.1　迭代器")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-1节练习"},{default:p(()=>[s("9.2.1节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-2-容器类型成员"},{default:p(()=>[s("9.2.2　容器类型成员")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-2节练习"},{default:p(()=>[s("9.2.2节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-3-begin和end成员"},{default:p(()=>[s("9.2.3 begin和end成员")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-3节练习"},{default:p(()=>[s("9.2.3节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-4-容器定义和初始化"},{default:p(()=>[s("9.2.4　容器定义和初始化")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-4节练习"},{default:p(()=>[s("9.2.4节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-5-赋值和swap"},{default:p(()=>[s("9.2.5　赋值和swap")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-5节练习"},{default:p(()=>[s("9.2.5节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-6-容器大小操作"},{default:p(()=>[s("9.2.6　容器大小操作")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-7-关系运算符"},{default:p(()=>[s("9.2.7　关系运算符")]),_:1})]),n("li",null,[t(a,{to:"#_9-2-7节练习"},{default:p(()=>[s("9.2.7节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_9-3-顺序容器操作"},{default:p(()=>[s("9.3　顺序容器操作")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-3-1-向顺序容器添加元素"},{default:p(()=>[s("9.3.1　向顺序容器添加元素")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-1节练习"},{default:p(()=>[s("9.3.1节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-2-访问元素"},{default:p(()=>[s("9.3.2　访问元素")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-2节练习"},{default:p(()=>[s("9.3.2节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-3-删除元素"},{default:p(()=>[s("9.3.3　删除元素")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-3节练习"},{default:p(()=>[s("9.3.3节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-4-特殊的forward-list操作"},{default:p(()=>[s("9.3.4　特殊的forward_list操作")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-4节练习"},{default:p(()=>[s("9.3.4节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-5-改变容器大小"},{default:p(()=>[s("9.3.5　改变容器大小")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-5节练习"},{default:p(()=>[s("9.3.5节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-6-容器操作可能使迭代器失效"},{default:p(()=>[s("9.3.6　容器操作可能使迭代器失效")]),_:1})]),n("li",null,[t(a,{to:"#_9-3-6节练习"},{default:p(()=>[s("9.3.6节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_9-4-vector对象是如何增长的"},{default:p(()=>[s("9.4 vector对象是如何增长的")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-4节练习"},{default:p(()=>[s("9.4节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_9-5-额外的string操作"},{default:p(()=>[s("9.5　额外的string操作")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-5-1-构造string的其他方法"},{default:p(()=>[s("9.5.1　构造string的其他方法")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-1节练习"},{default:p(()=>[s("9.5.1节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-2-改变string的其他方法"},{default:p(()=>[s("9.5.2　改变string的其他方法")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-2节练习"},{default:p(()=>[s("9.5.2节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-3-string搜索操作"},{default:p(()=>[s("9.5.3 string搜索操作")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-3节练习"},{default:p(()=>[s("9.5.3节练习")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-4-compare函数"},{default:p(()=>[s("9.5.4 compare函数")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-5-数值转换"},{default:p(()=>[s("9.5.5　数值转换")]),_:1})]),n("li",null,[t(a,{to:"#_9-5-5节练习"},{default:p(()=>[s("9.5.5节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#_9-6-容器适配器"},{default:p(()=>[s("9.6　容器适配器")]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#_9-6节练习"},{default:p(()=>[s("9.6节练习")]),_:1})])])]),n("li",null,[t(a,{to:"#小结"},{default:p(()=>[s("小结")]),_:1})]),n("li",null,[t(a,{to:"#术语表"},{default:p(()=>[s("术语表")]),_:1})])])]),W])}const K=o(H,[["render",P],["__file","K-第九章顺序容器.html.vue"]]);export{K as default};
