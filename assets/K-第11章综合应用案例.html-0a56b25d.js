import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as i,d,a as l,e as a,w as c,b as e,f as r}from"./app-2a2d189a.js";const m={},p=l("h1",{id:"k-第11章综合应用案例",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#k-第11章综合应用案例","aria-hidden":"true"},"#"),e(" K-第11章综合应用案例")],-1),h=l("p",null,"K-第11章综合应用案例",-1),u=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),g={class:"table-of-contents"},_=r('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="k-第11章综合应用案例-1" tabindex="-1"><a class="header-anchor" href="#k-第11章综合应用案例-1" aria-hidden="true">#</a> K-第11章综合应用案例</h2><h2 id="一、综合应用案例-归档文件" tabindex="-1"><a class="header-anchor" href="#一、综合应用案例-归档文件" aria-hidden="true">#</a> 一、综合应用案例-归档文件</h2><ul><li><p>到目前为止，我们已经学完了 Shell 编程中的主要语法特性。接下来，可以将其综合运用，解决实际工作中的问题。首先来看综合应用案例中的第一个——文件归档。</p></li><li><p>众所周知，在实际工作中，重要的数据或文件若丢失，会令人十分抓狂。相信大家都有过类似经历，比如写论文或重要文档时，电脑突然宕机且未保存，这种情况肯定非常惨痛。所以对于生产中的重要数据，像项目代码或其他重要文档，最好定时进行备份存档操作。</p></li><li><p>这个过程需要用到归档命令<code>tar</code>，该命令后可直接跟上<code>-c</code>参数，表示进行存档、归档操作。若加上<code>-z</code>，则表示同时进行压缩，得到的文件名后缀为<code>.tar.gz</code>。我们知道，其压缩使用的是<code>gzip</code>工具。</p></li><li><p>现在来看具体需求：实现一个脚本，每天对指定目录进行归档备份。调用此脚本时，输入一个目录名称（末尾不带斜杠），可带路径，之后对目录下的所有文件按天进行归档保存，并将归档日期附加在归档文件名上。例如，对<code>scripts</code>目录进行归档，定义文件名前缀为<code>archive</code>，则生成的文件名应为<code>archive_scripts_xxxx 年 xx 月 xx 日.tar.gz</code>。</p></li><li><p>这样操作的好处在于，完成设置后每天无需其他更改，文件名会自动生成。甚至可以进一步将其设置为定时任务，比如每天夜里 2 点或 3 点运行脚本，自动归档生成文件。此需求具有实际意义。</p></li><li><p>接下来，先到控制台创建这样一个脚本文件，在<code>script</code>目录下创建，命名为<code>daily_archive.sh</code>。先写上文件头<code>#!/bin/bash</code>。</p></li><li><p>接下来的操作整体较为简单，关键是<code>tar</code>命令。但在将其作为自动化运行的脚本前，需考虑更多问题。比如，调用传入参数时，若给定的目录不存在或并非正常目录，直接进行归档操作会出错，所以应先做更多判断。</p></li><li><p>首先判断输入参数个数是否为 1，因为只需要一个参数，即要归档的目录。使用特殊变量<code>$#</code>判断其是否不等于 1，<code>!=</code>表示“不等于”。若不等于 1，则出现问题，直接<code>echo</code>“当前参数不对，参数错误，个数错误。应输入一个参数作为归档的目录名。”，然后直接<code>exit</code>退出脚本，不再执行后续内容。<code>fi</code>结束当前判断。这是第一部分基本操作，空一行以便展示更清晰。</p></li><li><p>接下来添加注释，若参数个数正确，则从输入参数中获取目录名称。首先判断给定的参数是否为真正的目录，使用<code>-d</code>进行判断，后跟<code>$1</code>（第一个参数）。若是目录则无需操作，若不是目录则报错，空一行后<code>echo</code>“目录不存在”，然后<code>exit</code>退出。<code>fi</code>结束当前判断。</p></li><li><p>若目录正常，对目录名称进行提取。由于输入目录时不确定是绝对路径还是相对路径，最后希望获取绝对路径。之前讲过可使用<code>dirname</code>和<code>basename</code>对路径进行截取，<code>basename</code>截取的是最后一个斜杠后的内容，因输入目录不带斜杠，所以截取出来的就是底层目录名称。而<code>dirname</code>可结合<code>pwd</code>获取当前目录的绝对位置。</p></li><li><p>接下来，与之前的操作类似，定义一个变量<code>dirname</code>，通过命令替换执行<code>basename $1</code>。还应有一个变量<code>dirpath</code>，执行过程可能需要两条命令，首先<code>cd</code>到<code>$1</code>指定的目录，使用命令替换<code>dirname $1</code>提取当前所在路径，然后执行<code>pwd</code>获取当前工作目录的绝对路径。这与之前的操作完全相同。</p></li><li><p>接下来，可以定义要生成的归档文件名。首先获取当前日期（年月日），定义一个变量<code>date</code>，通过命令替换<code>date +%Y%m%d</code>实现。然后定义生成的归档文件名，首先给一个变量<code>file</code>表示文件名，加一个前缀<code>archive_</code>，后跟通过<code>basename</code>获取的目录名，比如<code>scripts</code>，即<code>archive_scripts_</code>。为清晰起见，用花括号括起来，然后跟<code>$date</code>和<code>.tar.gz</code>。生成路径直接定义为<code>/root/archive</code>，比如将其命名为<code>dest</code>，并将文件名跟在路径后，拼出最终想要的文件绝对路径。</p></li><li><p>接下来就可以真正开始归档目录文件，先<code>echo</code>一个人性化提示“开始归档...”，空一行。然后使用<code>tar</code>命令进行操作，<code>tar</code>加<code>-c</code>表示归档，<code>-z</code>表示压缩，<code>-f</code>使过程可视化，后跟生成文件的名称<code>dest</code>，以及要归档的目录名称，为保险起见使用绝对路径<code>$dirpath</code>。</p></li><li><p>之后判断是否成功，使用<code>if</code>判断<code>$?</code>是否等于 0。若等于 0，空几行后<code>echo</code>“归档成功”，然后<code>echo</code>归档文件的名称（即<code>dest</code>），再空一行。若<code>$?</code>不等于 0，则<code>else</code>输出“归档出现问题”，最后<code>exit</code>。这就是整个过程，整体较为简单，思路清晰，关键在于搞清楚每一步的具体操作，比如参数是否正确、目录名和文件名的拼接等。</p></li><li><p>接下来保存脚本，然后执行。使用<code>chmod</code>给脚本加上执行权限，一般在实际生产中，只需给当前用户（属主）加上执行权限，即<code>u+x</code>。查看<code>daily_archive</code>脚本的权限，只有属主有可执行权限。</p></li><li><p>然后执行脚本，若不跟目录直接敲或输入参数过多过少都会报错。这里输入<code>scripts</code>目录名称（要求不以斜杠结尾，因为使用了<code>basename</code>截取），回车后发现归档出现问题，因为<code>/root/archive</code>目录不存在，需创建该目录后再次执行脚本，此时归档成功，生成的文件名包含当前日期。</p></li><li><p>使用脚本进行自动化处理操作非常简单方便。若要更好地应用，可将其加入定时任务。还记得定时任务使用<code>crontab</code>命令，查看当前系统中<code>root</code>用户未定义任何定时任务，可使用<code>crontab -e</code>进行编辑。比如每天晚上凌晨 2 点执行此脚本，设置为“0 2 * * * /root/scripts/daily_archive.sh /root/scripts”，保存后就有了定时任务，之后每天会定期进行归档，实现重要数据的备份归档管理。</p></li><li><p>这就是这个具体的应用案例，大家可以尝试实现。</p></li></ul><h2 id="二、综合应用案例-发送消息" tabindex="-1"><a class="header-anchor" href="#二、综合应用案例-发送消息" aria-hidden="true">#</a> 二、综合应用案例-发送消息</h2>',6),x=l("ul",null,[l("li",null,[l("p",null,[l("mark",null,"综合应用案例：Linux 中向用户发送消息的脚本")])]),l("li",null,[l("p",null,"学习至此，对于 Linux 以及 Shell 编程和脚本的学习已接近尾声。在学习的最后，通过一个综合应用案例来对之前所学内容进行总结回顾。")]),l("li",null,[l("p",null,"其实此前已经列举过一个综合应用的案例，即每天对指定目录中的文件进行归档保存。之前仅使用所学过的基本命令就能完成该脚本。如今，我们学习了正则表达式，还学习了一些强大的文本处理工具，如 cat 和 AWK，现在能做更多的事情了。")]),l("li",null,[l("p",null,"接下来，列举一个有趣的案例。尽管在实际应用中可能不常这么做，但学会之后，大家可能会觉得 Linux 下的 Shell 编程还是很有趣的。")]),l("li",null,[l("p",null,"现在的需求是实现一个向某个用户快速发送消息的脚本。输入用户名作为第一个参数，即脚本调用时，前面是脚本名称，执行时后面跟上用户名，向该用户发送消息，接着是要发送的内容，可随意发送，数量不限。这个脚本的主要目的在于：需要检测用户是否在系统中，如果不在则直接报错；判断用户是否开启了消息功能，如果用户那边关闭了，需要让其打开才能给他发消息；另外，发送的消息不能为空，如果为空则没有意义。接下来看看这个脚本该怎么写。")]),l("li",null,[l("p",null,"在此之前，先说明一下基本思路，即如何利用小工具实现向其他用户发送消息的功能。接下来切换到控制台。首先介绍一个基本命令，之前已经了解过“who am i”，这个命令可以查看当前正在登录的自己是哪个用户、使用哪个终端控制台登录、登录的时间以及 IP 等。当时没有展开说，如果直接敲“who”，这本身也是一个命令，可以查看当前登录的所有用户。当然，现在只有一个用户登录且只登录了一个控制台，比如再登录一个“at 硅谷”用户，同样使用“Hedo B100”登录。如果是“who mi”，当然只能看到自己，如果是“who”，则能看到当前登录的所有用户。")]),l("li",null,[l("p",null,"既然“at 硅谷”用户当前在线，那是否可以给他发一个消息呢？在发消息之前，需要确认其是否打开了消息发送功能。此时需要用到一个检测工具，即“MESG”（message）。直接敲一下，可以看到它直接显示“is y”，这表明当前 root 用户登录后，默认的消息功能是打开的。再看一下“at 硅谷”，“message”后显示“is y”，也是打开的。对于 root 用户，如果要查看“at 硅谷”是否开启消息功能，可以使用“who”命令加“-t”参数，前面出现加号，表示消息功能开启。")]),l("li",null,[l("p",null,"当前默认情况下，不同的 Linux 发行版此功能的开启情况不同，比如 Ubuntu 默认是关闭的，而 CentOS 默认是开启的。如果当前它本身没有开启，比如可以通过“message n”将其关掉，此时 root 这里就变成减号了。如果要开启，当然就是“message y”，接下来就又开启了。所以这个操作本身还是非常简单的。")]),l("li",null,[l("p",null,"既然开启了，那就尝试一下能否给“at 硅谷”用户发一个消息。接下来怎么发呢？这就要用到另外一个命令，即“write”。“write”的使用非常简单，后面跟上要发送的对象，比如给“at 硅谷”用户发送，另外还得指定其当前的控制台，因为“at 硅谷”用户可能登录了多个控制台。如果查看“who”并加上“-t”，可以看到“PTS1”和“PTS2”都是“at 硅谷”登录的当前控制台。使用“write”命令时，指定“at 硅谷”，后面还要跟上对应的控制台，比如给“PTS1”发送。接下来可以看到没有任何显示，这说明现在就可以输入对应的信息了，比如输入“hi at 硅谷”。在“at 硅谷”端，可以看到有消息提示，仔细看会发现 Excel 上面有一个叹号，表示收到消息了。看一眼，“hi at 硅谷”果然已经收到了。所以这个功能非常简单，也很好玩且好用，可以实现两边通信，能够实时发送消息。")]),l("li",null,[l("p",null,"当然，如果不想再发了，还可以继续发，比如发一个“哈喽”，这里同样可以继续收到，还可以发“how are you”。需要注意的是，这里不能随便按退格键等，这些都是非法字符，如果直接这么操作，这边显示的会是乱码。比如这里输入“how are you”，就可以看到对应的这些信息。当然，这个功能没有像 QQ、微信那么强大，但至少可以发送一些简单的信息。")]),l("li",null,[l("p",null,"有了这个功能，首先把它退掉，如果要退，就按“Ctrl + c”，这边就会发现收到了一个“EOF”，我们知道“EOF”表示一个文档的结束，这边就表示发送消息已经结束。在接收端，只要回车一下，就可以退出当前接收信息的界面。")]),l("li",null,[l("p",null,"接下来思考一下，本来这个功能已经实现了，平常就是这么查看然后去发送。但是会想到，如果每次发送的时候，都要用用户命令去查看当前有谁在线，是否打开了消息功能，然后再去发送，这就有点麻烦。所以这里就想写一个更简洁的脚本，每次直接调用这个脚本，不管用户在不在，直接发，如果不在就给一个提示返回，不用每次都去查询。脚本的功能就体现在这里。")]),l("li",null,[l("p",null,"接下来，在这里直接将其命名为“send_msg.sh”。进入之后，先把当前的头写上“bin/bash”。")]),l("li",null,[l("p",null,"接下来，首先第一步应该要做的，就是查看这个用户有没有登录，也就是查看用户是否在线。这里定义一个变量，叫“log_in_user”，是否登录直接使用“who”命令查出来，把它的用户名直接提取出来。接下来就发现这个肯定就是登录的用户，所以直接就叫“logging_user”。")]),l("li",null,[l("p",null,"当然，接下来就是要使用“who”命令去进行查看，这里用到“$()”，这就是所说的命令替换，用“who”命令查到的内容直接付给“logging_user”这个变量。“who”命令后面跟上管道，然后直接提取对应的要查的对象，我们是按照这个脚本传入的参数，第一个参数就是要查的用户，所以就是“$1”，就是要把“$1”对应的那一行信息提取出来。所以这里直接“grep”，本质上来讲应该就是“grep $1”。但是我们发现，如果“at 硅谷”这个用户登录了两个控制台，这么提取会提取出来两个。另外还有一个问题，就是用户名有可能有大小写，这里其实是不希望区分大小写的。这样的话，“grep”这里可以做一个保证，加上“-i”，表示忽略大小写的影响，还可以加一个“-m”参数，“-m”参数指的是“Max count”，后面跟上一个数，比如给一个“-m 1”，这就表示只拿第一行就行了，它是最大的数量，就是到底匹配多少行，如果有多个登录的控制台，只选第一个，不要拿那么多。这样的话，当前这个定义就没有任何问题了。")]),l("li",null,[l("p",null,[e("提取出来之后，这一行数据还有很多内容，现在必须要第一个第一列的数据。所以这个第一列，可以用各种工具，比如 cat 或者 AWK，这里直接用 AWK，后面是一个单引号，花括号括起来“print $1”就可以了。整体来讲，这是一个很简单的操作。但是需要注意，把这个获取到之后，得看当前这个用户到底登录了没有。这就要进行判断，如果按照“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("mtext",null,"”查出来的没有，其实应该直接报错退出。所以接下来进行一个判断，“"),l("mi",null,"l"),l("mi",null,"o"),l("msub",null,[l("mi",null,"g"),l("mi",null,"i")]),l("msub",null,[l("mi",null,"n"),l("mi",null,"u")]),l("mi",null,"s"),l("mi",null,"e"),l("mi",null,"r"),l("mtext",null,"”到底有没有。这里就涉及到了另外一个判断，叫“"),l("mo",null,"−"),l("mi",null,"z"),l("mtext",null,"”。“"),l("mo",null,"−"),l("mi",null,"z"),l("mtext",null,"”是什么呢？其实就是判断这个值到底是否为空，对于一个字符串来讲，就是判断它是否是空的。后面跟着的就是“")]),l("annotation",{encoding:"application/x-tex"},"1”查出来的没有，其实应该直接报错退出。所以接下来进行一个判断，“log_in_user”到底有没有。这里就涉及到了另外一个判断，叫“-z”。“-z”是什么呢？其实就是判断这个值到底是否为空，对于一个字符串来讲，就是判断它是否是空的。后面跟着的就是“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),l("span",{class:"mord"},"1”"),l("span",{class:"mord cjk_fallback"},"查出来的没有，其实应该直接报错退出。所以接下来进行一个判断，"),l("span",{class:"mord"},"“"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),l("span",{class:"mord mathnormal"},"o"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3117em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mathnormal mtight"},"i")])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"n"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.1514em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mathnormal mtight"},"u")])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"ser"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"到底有没有。这里就涉及到了另外一个判断，叫"),l("span",{class:"mord"},"“"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"。"),l("span",{class:"mord"},"“"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"是什么呢？其实就是判断这个值到底是否为空，对于一个字符串来讲，就是判断它是否是空的。后面跟着的就是"),l("span",{class:"mord"},"“")])])]),e("log_in_user”，如果当前它是空的，那么“then”就直接“echo”一下，当前就说这个用户不在线，所以给一个“$1 不在线”，可以加一个感叹号，接下来再多输出一些消息，可以“echo”一个当前应该脚本退出，就不需要再等着了。这个时候就直接“exit”，然后“fi”结束当前的判断。这就是基本的一个想法，就是做这样的一个判断。")])]),l("li",null,[l("p",null,"有了这个判断之后，接下来还需要再看，用户到底是否开启了接收消息的功能。先退出去再确认一下，这个消息的功能需要用“who -t”这个命令来查看，然后得到的结果，其实这个加减符号应该就是第二列，所以同样可以使用这个命令然后去截取它的第二列，对应的用户还得查出来，找他的第二列到底是加号还是减号，就可以知道当前应该怎么做。所以接下来还是进来，接下来的这个过程，既然是查看他是否开启功能，也要用到“who”命令，那干脆做一个复制，下面应该是有 8 行，所以来一个“Y8Y”，到下面来直接复制一下。然后接下来，这里就不能叫“logging_user”了，把它叫做“is_allowed”，是否允许接收消息。然后接下来，这里的命令就是“who -t”，然后“grep -i -m 1 $1”进行匹配，后面不是“$1”了，在 AWK 里边截取的是第二列，把它拿出来。同样下面要做一个判断，拿到的“is_allowed”，这就应该要么是加号，要么是减号。所以这里直接判断“is_allowed”这个值是否等于，如果它不等于加号的话，这就有问题，就要报错退出。所以这里把这个信息也改一下，这个不叫不在线，这个叫没有开启消息功能，然后脚本退出，然后“fi”，封闭当前的“if”判断的分支就可以了。然后有了这一部分，也写一个对应的注释，这部分主要是用来查看用户是否开启消息功能。")]),l("li",null,[l("p",null,[e("然后接下来继续要做的操作，如果说用户也登录在线了，然后也开启了消息功能。另外还有一个要求，就是还得确认一下当前是否有消息发送。这个消息发送的话，当前第一个未知参数，这是指定的那个用户名，那第二个参数就应该是消息了，就看“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"2"),l("mtext",null,"”到底存不存在，有没有值就行了。这个也可以直接把前面那个先复制过来，这一行就不要了，然后在这里写一行注释，这里要查看的是确认是否有消息发送。然后接下来这个“"),l("mi",null,"i"),l("mi",null,"f"),l("mtext",null,"”要判断的，那就是“"),l("mo",null,"−"),l("mi",null,"z"),l("mtext",null,"”，这个不是“")]),l("annotation",{encoding:"application/x-tex"},"2”到底存不存在，有没有值就行了。这个也可以直接把前面那个先复制过来，这一行就不要了，然后在这里写一行注释，这里要查看的是确认是否有消息发送。然后接下来这个“if”要判断的，那就是“-z”，这个不是“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),l("span",{class:"mord"},"2”"),l("span",{class:"mord cjk_fallback"},"到底存不存在，有没有值就行了。这个也可以直接把前面那个先复制过来，这一行就不要了，然后在这里写一行注释，这里要查看的是确认是否有消息发送。然后接下来这个"),l("span",{class:"mord"},"“"),l("span",{class:"mord mathnormal"},"i"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"要判断的，那就是"),l("span",{class:"mord"},"“"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"，这个不是"),l("span",{class:"mord"},"“")])])]),e("logging_user”了，而是“$2”直接判断这个，如果说它真的为空的话，那这里就应该说没有消息发送，然后脚本退出“exit”。这就是前面基本要做的一些判断，保证当前没有问题。")])]),l("li",null,[l("p",null,[e("这些如果都保证了，接下来就是要获取发送的信息去做“write”发送。首先从参数中获取要发送的消息，这个获取稍微有点麻烦。因为如果所有参数都是消息，那就简单了，直接“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∗"),l("mtext",null,"”或者“")]),l("annotation",{encoding:"application/x-tex"},"*”或者“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord"},"∗"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"或者"),l("span",{class:"mord"},"“")])])]),e("@”拿出来就完了，现在很尴尬，就只有第一个不是，后面的都是。那怎么获取呢？也简单，想到可以用一个“cat”，用空格做分割把它切开，把第一个排除掉，从第二列开始往后所有的都拿出来就完事了。所以基于这个想法，使用“cat”就可以搞定。这里定义一个变量，比如叫做“hold_message”，完整的信息。那么既然是要使用“cat”命令，还是做一个命令替换，相当于调用系统函数了，那就直接“cat”。这里如果直接“cut”的话，后面需要跟一个文件名称，“$*”它并不是文件名称，所以这里应该是“"),l("code",null,"cat $*"),e("”，然后做一个管道输出，输出给到“cat”命令。接下来“cat”的话，那就“-d”，指定当前的分隔符是空格，然后接下来要截取的“-f”第几列，那就是从第二列开始一直到最后的所有内容。这就是截取这个消息的过程。")])]),l("li",null,[l("p",null,"接下来就可以直接把这个消息发送给对应的用户了。注意，最后“write”发送的时候，除了用户名，后面还得跟上终端。那还得再获取一下当前这个用户的终端，这个稍微有点麻烦，但是会想到跟前面这一句其实差不多，也是直接用最初的“who”，直接把它复制过来就可以，“YY”，把它做一个复制，然后接下来在下边做一个粘贴。这里输入一个注释，这里主要是获取用户登录的终端。这里就不是“logging_user”了，把它叫做“user_terminal”，用户登录的终端，后面就是“who”命令，然后“grep -i -m 1 $1”，用户名称后面的 AWK，如果不加“-f”参数的话，第二列就是终端，所以把它获取到。")]),l("li",null,[l("p",null,"接下来终于到最后一步了，现在就可以直接写入要发送的消息。这个写入涉及到一个问题，就是在外面执行的时候，直接“read”加上用户名，加上终端，然后在控制台去敲要发送的消息。那现在怎么敲呢？其实也简单，直接“echo”一下之前的“hold_message”，然后通过管道把它传递交给“write”就可以了。接下来“write”后面这里当然就是“log_in_user”，在后面跟着的就是“user_terminal”。这样的话，把当前所有的内容就搞定了。")]),l("li",null,[l("p",null,"那最后，可以再做一个到底发送成功没有的判断。那就是当前得到的“$?”，如果不等于 0 的话，那就说明出问题了，可以直接“echo”说发送失败。那如果是“else”的话，也就是说当前返回的这个“code”直接就是 0 的话，那就代表发送成功。这就是整个的流程。")]),l("li",null,[l("p",null,"当然了，这里在脚本里面就不用去退出了，因为完成之后肯定是要退出的。这就是整个的流程就做完了。所以整体来讲这个过程说难也不难，但是整体流程里面，还是有很多细节需要去考量的。")]),l("li",null,[l("p",null,"那现在做完了之后，保存退出。还是不要忘记把当前的权限打开，加上可执行权限“send_msg”。然后接下来就可以直接调用了。")]),l("li",null,[l("p",null,"假如说这里什么都不给，直接这么一敲，会发现它其实是没有获取到对应的东西，直接说不在线然后退出了，这个也是可以的。比如现在想要给小明发一个消息，那当然小明不在线了。然后接下来，如果给“at 硅谷”发一个消息，知道“at 硅谷”是在线的，但是当前没有给消息，那当然也就是脚本退出了。所以现在的话，就不用做任何的判断，直接敲就可以了。然后给“at 硅谷”发送消息，后面比如来一个“嗨 at 硅谷”，发送成功，来看一眼，发现这个是有一些问题的，说明前面这个代码应该是有问题，这里是已经建立连接在发送消息了，但是没有发送成功。说明可能当时这个消息写的有问题，还是进去看一眼，这个肯定是在最后这里写入要发送的消息的时候，看到了这里的“whole_message”，这个变量名给错了，多了一个“e”。有些细节还是要注意的。把它做一个更改保存，然后接下来重新做一个发送，现在发送成功，这里就收到了“嗨 at 硅谷”这样的一个消息。而且可以看到，现在每一次执行脚本，相当于完了之后会退出，这里就相当于一个消息已经结束了，“EOF”可以收到。当然了，还可以不停的发送其他的消息，比如提醒一下，比如说“老板来了”，赶紧提醒一下，该摸鱼的时候摸鱼，老板来了之后就不要摸鱼了。所以这个功能就可以看得非常明确，这是一个非常好玩的功能，实时发送消息，可以写一个脚本实现它。")])],-1);function w(f,b){const s=o("router-link");return t(),i("div",null,[p,h,d(" more "),u,l("nav",g,[l("ul",null,[l("li",null,[a(s,{to:"#概述框架"},{default:c(()=>[e("概述框架")]),_:1})]),l("li",null,[a(s,{to:"#k-第11章综合应用案例-1"},{default:c(()=>[e("K-第11章综合应用案例")]),_:1})]),l("li",null,[a(s,{to:"#一、综合应用案例-归档文件"},{default:c(()=>[e("一、综合应用案例-归档文件")]),_:1})]),l("li",null,[a(s,{to:"#二、综合应用案例-发送消息"},{default:c(()=>[e("二、综合应用案例-发送消息")]),_:1})])])]),_,x])}const v=n(m,[["render",w],["__file","K-第11章综合应用案例.html.vue"]]);export{v as default};
