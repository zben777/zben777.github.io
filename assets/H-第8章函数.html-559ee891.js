import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as n,c as t,d as r,a as e,e as c,w as a,b as o,f as s}from"./app-2a2d189a.js";const p={},h=e("h1",{id:"h-第8章函数",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#h-第8章函数","aria-hidden":"true"},"#"),o(" H-第8章函数")],-1),u=e("p",null,"H-第8章函数",-1),$=e("div",{class:"hint-container info"},[e("p",{class:"hint-container-title"},"说明"),e("p",null,"主要是各种搜索找的学习；")],-1),m={class:"table-of-contents"},_=s('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="h-第8章函数-1" tabindex="-1"><a class="header-anchor" href="#h-第8章函数-1" aria-hidden="true">#</a> H-第8章函数</h2><h2 id="一、函数-function" tabindex="-1"><a class="header-anchor" href="#一、函数-function" aria-hidden="true">#</a> 一、函数（Function）</h2><ul><li><p>接下来要介绍的是，如果将 Linux Shell 视为一种编程语言，那么其中的重要内容——函数（Function）。函数这一概念并不陌生，几乎在所有编程语言中都存在。在 C 语言中，它被称为函数；在 Java 中，熟悉的称呼可能是方法。可以认为方法就是函数的另一种说法。</p></li><li><p>那么，什么是函数呢？在计算机编程领域，函数通常被认为是一段代码的集合，将一些逐步执行的代码包装起来，能够完成某个特定的功能。在调用函数时，可以传入一些参数，并得到某个返回值。这样，就将这部分代码模块化，包装起来后能够方便地重复调用，这便是函数的概念和意义。</p></li><li><p>比如之前在脚本中写过的一个简单的<code>add.sh</code>，其中的操作是传入两个参数，然后得到它们相加的结果并将其<code>echo</code>打印到当前控制台。如果经常需要用到这个功能，就可以将其包装成一个函数，当需要进行两数加法时，直接调用这个函数即可。在 Linux Shell 中也是如此，它有许多现成的系统函数可供直接调用，当然也支持用户自定义函数的声明和使用，这些便是接下来要了解的内容。</p></li><li><p>在此过程中会发现，前面已经将相关功能写成了脚本，又说可以将其包装成函数，那么这与写成的<code>.sh</code>脚本有何区别？确实，脚本本质上可以被认为是一个代码的源文件，也是一段代码的集合，用于完成特定功能。若要为其传递参数，在调用脚本时使用特殊变量<code>$1</code>、<code>$2</code>等传入。本质上，这与函数的使用有相似之处，但也存在区别。</p></li><li><p>首先，脚本本身没有对应的返回值，若要有返回值，就是<code>$?</code>，表示执行命令<code>bash</code>时自动给出的返回值，通常只有 0 或其他错误代码，这并非我们通常所需的返回值。其次，脚本的调用过程显得较为笨重，每次调用都需要手动输入命令并传递相应参数。若要重复调用，每次都需手动操作，十分麻烦。相较而言，函数则轻量许多，可以在一个文件中重复定义多个函数，需要使用时可多次重复调用，甚至可以直接放在<code>for</code>循环中重复调用，灵活性更高。</p></li><li><p>可以认为，从某种意义上讲，函数是缩小版、简化版且更灵活的脚本；而脚本则是笨重、复杂的函数。</p></li><li><p>既然所有命令都可视为系统函数，那么在脚本中想要调用系统函数时，之前讲过的所有命令都可调用。比如，已知系统命令<code>date</code>可显示当前日期，在其后加上<code>%s</code>可显示当前时间戳，这在实际生产环境中非常有用。例如，在产生大量日志数据并写入日志文件时，为文件或文件夹命名时往往会带上时间信息，以表示其产生的时间点。</p></li><li><p>可以进行如下操作，重新创建一个测试脚本文件，命名为<code>command_test.sh</code>。首先，写上文件头<code>#!/bin/bash</code>，接下来要定义一个日志文件的名称<code>filename</code>，<code>filename</code>等于传入的用户名称（视为<code>$1</code>），后跟一个下划线、<code>log</code>和一个下划线以及当前的时间戳。要获取时间戳，需调用系统命令<code>date</code>，但直接写<code>date</code>不行，这只是拼接字符串。在调用系统命令时，要使用<code>$()</code>，这被称为命令替换。前面讲运算符时提到，若要将某个运算的值赋给变量，需加上<code>$</code>并将其括起来，这被称为命令替换。在调用系统函数或使用系统命令时，在脚本中就要用到命令替换。</p></li><li><p>这里多解释一句，从函数角度看，这相当于调用了系统的<code>date</code>函数，后面的部分相当于传入的参数，即实参。<code>date</code>函数肯定需要参数，传入实参后得到的返回结果就是命令得到的值，用<code>$</code>括起来，实现函数调用结果的返回值与字符串的拼接，从而得到当前的<code>filename</code>文件名称。可以发现，使用起来非常简单。</p></li><li><p>前面已经介绍过各种系统命令，无论是文件目录类、进程管理类，还是关于磁盘分区等的命令，只要想用，都可在脚本中作为系统函数调用，这里不再重复介绍之前讲过的内容。接下来，介绍两个在实际应用中较为常见的系统函数。</p></li><li><p>首先是<code>basename</code>，先来回忆之前的特殊变量<code>$n</code>，<code>$n</code>一般被称为位置参数，是从 1 开始的整数，表示第几个参数，<code>$0</code>表示当前脚本的名称，即获取当前脚本本身的文件名。但在测试时会发现，执行<code>parameter.sh</code>并打印<code>$0</code>，若使用相对路径执行，获取到的是<code>./parameter.sh</code>；若使用绝对路径执行，如<code>/root/scripts/parameter.sh</code>，后跟参数<code>a</code>、<code>b</code>，输出的脚本名称是带绝对路径的。有时可能根据当前执行的脚本名进行一些拼接操作，比如拼接日志文件名，可能只需要脚本名而不要完整路径，这时就可以使用<code>basename</code>命令。</p></li><li><p>其语法结构非常简单，<code>basename</code>后直接加上字符串类型的名称即可。测试一下，如<code>basename /root/scripts/parameter.sh</code>，会发现直接获取到最后的文件名。本质上，这是对字符串的剪切，即找到最后一个斜杠，将之前的部分全部切掉，只保留之后的部分。</p></li><li><p>有时可能需要去掉文件名的后缀，比如进行文件名拼接生成日志文件时。<code>basename</code>可以跟一个参数<code>suffix</code>，表示后缀。指定后缀后，<code>basename</code>命令会将文件名中的后缀去掉。使用一下便知，如加上<code>.sh</code>后缀，会发现得到的只有<code>parameter</code>这个名称。使用起来非常简单，在需要获取当前文件的名称且去掉后缀时，可以使用此命令。可以尝试修改之前的<code>parameter.sh</code>，在脚本中使用命令替换<code>$(basename $0)</code>并去掉后缀<code>.sh</code>，保存退出后运行<code>parameter.sh a b</code>，得到的脚本名称只有<code>parameter</code>，用绝对路径执行结果也相同，只显示脚本名称且不带后缀，这便是<code>basename</code>的基本用法，简单但实用。</p></li><li><p>除了<code>basename</code>，再介绍一个<code>dirname</code>，顾名思义，<code>basename</code>指的是文件名，<code>dirname</code>则指的是文件的路径名，它返回的是当前文件的路径。这里对其进行测试，如<code>dirname /root/scripts/parameter.sh</code>，与<code>basename</code>刚好相反，它截取的是最后一个斜杠之前的绝对路径。若输入的不是绝对路径，比如相对路径，<code>dirname</code>不管，它只是针对输入的字符串进行切分，找到最后一个斜杠之前的部分作为当前的路径。这便是<code>dirname</code>的使用过程。</p></li><li><p>有了这些之后，可以对之前的脚本做进一步改良。比如，在脚本中新增一行<code>echo</code>，不仅显示脚本名称，还显示当前脚本的执行路径。要获取路径，可以先切换当前工作目录到<code>$0</code>对应的目录，使用<code>dirname $0</code>进行命令替换，然后执行<code>cd</code>命令，因为<code>cd</code>命令需要的目录也要进行命令替换。接下来执行<code>pwd</code>命令，<code>pwd</code>命令可直接获取当前工作路径的绝对路径。这样就符合显示要求，当然，也可以将上述部分复制过来，用分号分隔，相当于先后执行这两条命令，再放在命令替换符中，先执行<code>cd</code>，再执行<code>pwd</code>获取绝对路径并输出。保存退出后运行脚本，传入参数<code>a</code>、<code>b</code>，会输出脚本名称<code>parameter</code>及其绝对路径<code>/root/scripts</code>。即便使用相对路径调用，也能获取到绝对路径。</p></li><li><p>对于系统函数的调用，本质上就是命令的使用，在脚本中主要需注意加上<code>$()</code>，将使用的命令放在其中，这就成为了系统函数的调用方式，在 Linux Shell 中通常称为命令替换，可以认为命令替换就是系统函数的调用。</p></li></ul><h2 id="二、自定义函数" tabindex="-1"><a class="header-anchor" href="#二、自定义函数" aria-hidden="true">#</a> 二、自定义函数</h2><ul><li><p>上一节介绍了系统函数的用法，会发现所谓系统函数，本质上就是 Linux Shell 提供的一些命令。若在脚本中使用这些命令或调用系统函数，直接使用<code>$()</code>，这被称为命令替换，可视为系统函数的调用方式。</p></li><li><p>在编写脚本时，有些功能可直接调用系统函数，有些则需自定义。下面来看自定义函数的基本语法，其实非常简单。其语法为：前面是<code>function</code>，后面跟当前的函数名称<code>function_name</code>，再加一个小括号，然后是一个花括号，花括号内是函数体，即具体要执行的操作，最后可以有一个<code>return</code>返回值。这里会发现，很多地方用方括号括起来，这表示此部分内容可选，可有可无。比如，前面的<code>function</code>本身可省略，因为定义函数时，后面有花括号，一看便知是函数。小括号也可省略，<code>return</code>返回语句同样可省略。返回语句可省略较易理解，有时执行完操作无需返回值。</p></li><li><p>前面提到小括号，在多数编程语言中，小括号内通常要写参数列表。若省略小括号，参数列表写在哪？需注意，自定义函数时传入的参数，即形参无需专门定义。默认情况下，形参通过<code>$1</code>表示调用函数时传入的第一个参数，<code>$2</code>表示第二个参数。由此可见，函数的使用与脚本类似。之前说过，脚本可视为重量级、复杂化的函数，函数则是轻量级、更灵活的脚本，其使用规则完全相同，参数都用未知参数表示。</p></li><li><p>这里的返回值，会想到之前脚本的执行返回值是<code>$?</code>，那么函数的返回值是否也用<code>$?</code>获取？答案是若要获取函数返回值，直接用<code>$?</code>即可。若函数中有<code>return</code>，则<code>$?</code>获取的就是<code>return</code>的值。这是基本的使用方式。</p></li><li><p>在自定义函数使用过程中，需注意一些要点，这与平常的高级编程语言有所不同。</p></li><li><p>首先，在 Linux Shell 中，调用函数前必须先声明函数。这很好理解，因为 Linux Shell 是解释型语言，从上到下逐行解释，若在函数声明前调用，它不知是何意。不像 C 或 Java 等编译型语言，有编译器先进行完整编译。所以必须按顺序，调用前先声明。</p></li><li><p>其次，关于函数返回值的说明。函数返回值的获取与脚本相同，必须使用<code>$?</code>这个系统变量。若函数中有<code>return</code>，则知道返回什么就获取什么。若没有<code>return</code>，返回的是函数体里最后一句命令执行的结果。提到这会想到，<code>$?</code>返回值并非想返回什么就返回什么，它返回的是脚本或命令执行的结果码。若为 0 表示执行成功，若为 1 表示执行错误，还有些其他额外数字，一般在 1 - 255 之间。所以这里的返回有限制，若获取<code>$?</code>，其值只能是 0 - 255 的整数，不能返回其他类型。具体使用时，若想返回其他东西，可通过具体事例查看如何操作。</p></li><li><p>还是以之前的两数求和的脚本为例，将其用函数进行包装实现。更改一下，不在脚本外传入参数，要相加的两个数直接在命令行通过<code>read</code>读取控制台输入。创建一个新脚本用于测试函数功能，命名为<code>fun_test.sh</code>。先创建出来，写上文件头<code>#!/bin/bash</code>。</p></li><li><p>接下来首先定义函数，一般约定俗成将<code>function</code>写出来，尽管可省略，但写出后代码可读性更高，一看便知是在声明函数。直接写为<code>add()</code>，花括号括起来。在文档中，花括号可放在下一行，回车后显示，直接跟在后面也可以，位置无关。下一行开始写函数体，要做两数叠加，形参就是<code>$1</code>和<code>$2</code>，做加法运算需用<code>$(( ))</code>括起来，得到的结果赋给另一个变量，比如叫<code>s</code>。接下来可在控制台<code>echo</code>当前值，再输出一个，比如“和：多少”，后跟<code>s</code>。这就是函数的定义。</p></li><li><p>定义完函数，具体调用执行还需操作。中间空一行，为了显示美观，不空行也行。接下来，执行过程中需先输入参数，参数从命令行控制台直接输入，用<code>read</code>，后跟显示信息<code>-p</code>，比如“请输入第一个整数”，再给一个变量名，比如<code>a</code>。然后复制此操作输入第二个整数，变量名设为<code>b</code>。接下来就是调用函数，直接写<code>add</code>，参数通过<code>$1</code>和<code>$2</code>传递，即<code>$a</code>和<code>$b</code>，这就是调用函数的过程，非常简单。保存退出，给脚本增加可执行权限，然后执行脚本，会有交互式提醒，输入第一个整数，比如 35，再输入 67，看到和是 102，得到最终显示输出，过程简单。</p></li><li><p>可能会发现问题，参数通过脚本方式空格调用，函数后加空格传入，形参用未知参数<code>$1</code>、<code>$2</code>实现。若想获取返回值怎么办？函数应有输入和输出，输出通过返回值实现，这里直接在控制台打印结果。若获取<code>$?</code>，应是 0，因执行成功。若想捕获结果，不在函数内输出到控制台，能否做到？可以试试。</p></li><li><p>把<code>echo</code>改为<code>return</code>，然后下面再<code>echo</code>当前返回值<code>$?</code>，即调用<code>add</code>函数的返回值。会想到这样是否可行，试一下，输入 35、67，报错，提示需要数字参数。这是因为<code>return</code>的结果给<code>$?</code>，<code>$?</code>表示前面命令或脚本执行的结果代码，只能是 0 - 255，不能是字符串，只能是数字。所以想到干脆去掉“和”，在最后<code>echo</code>时加上“和”。保存退出再执行，输入 35、67，没问题，捕获到执行结果并正常输出。但又有问题，前面说<code>return</code>能返回的值只有 0 - 255，若两数较大，比如 156 和 237 相加会怎样？不会报错，但结果错误，得出 137，因为最大值是 255，超出就会绕回。所以最多只能输出 0 - 255 的值，这太受限，一个函数连简单加法超出 255 都无法显示，怎么办？别着急，有解决方案。</p></li><li><p>进入脚本，函数直接<code>return</code>返回，只能捕获 0 - 255 的值给<code>$?</code>，那干脆不用<code>$?</code>获取，也不用<code>return</code>。这里有个小技巧，把<code>return</code>改为直接<code>echo $s</code>，要知道<code>echo $s</code>是打印输出，这不等同于返回，那怎么办？回忆系统函数的调用方式，调用后做命令替换，将返回值赋给另一个变量。接下来，定义一个变量<code>some</code>，等于命令替换<code>$(add $a $b)</code>，即把<code>a</code>和<code>b</code>相加的结果，<code>echo</code>这个值，执行肯定是 0，但不看<code>$?</code>，而是看这个值，通过命令替换获取后赋给<code>some</code>。接下来可在下面直接打印<code>$some</code>的值。甚至可以对结果进行进一步计算，比如求“和的平方”，后面再做一层计算<code>$some * $some</code>，需用<code>$(( ))</code>括起来。为清晰起见，这里还是输出对应的和，即<code>$s</code>。保存退出，输入 156、237，可正常叠加出 393，以及和的平方。</p></li><li><p>这就是关于自定义函数的一些用法和小技巧，在具体实践中可自行体会。</p></li></ul>',7);function f(b,x){const d=l("router-link");return n(),t("div",null,[h,u,r(" more "),$,e("nav",m,[e("ul",null,[e("li",null,[c(d,{to:"#概述框架"},{default:a(()=>[o("概述框架")]),_:1})]),e("li",null,[c(d,{to:"#h-第8章函数-1"},{default:a(()=>[o("H-第8章函数")]),_:1})]),e("li",null,[c(d,{to:"#一、函数-function"},{default:a(()=>[o("一、函数（Function）")]),_:1})]),e("li",null,[c(d,{to:"#二、自定义函数"},{default:a(()=>[o("二、自定义函数")]),_:1})])])]),_])}const C=i(p,[["render",f],["__file","H-第8章函数.html.vue"]]);export{C as default};
