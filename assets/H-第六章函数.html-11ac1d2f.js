import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as u,d as r,a as n,e as a,w as t,b as s,f as e}from"./app-2a2d189a.js";const k={},d=n("h1",{id:"h-第六章函数",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#h-第六章函数","aria-hidden":"true"},"#"),s(" H-第六章函数")],-1),m=n("p",null,"H-第六章函数",-1),b=e('<div class="hint-container info"><p class="hint-container-title">说明</p><p>主要是各种搜索找的学习；<br><strong>百度链接：</strong><br> :<br> :</p><p><strong>知乎链接：</strong><br> :<br> :</p><p><strong>B站链接：</strong><br> ：<br> ：</p><p><strong>博客链接：</strong><br> ：<br> ：</p><p><strong>GitHub链接：</strong><br> ：<br> ：</p></div>',1),v={class:"table-of-contents"},g=e(`<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="第6章-函数-完毕" tabindex="-1"><a class="header-anchor" href="#第6章-函数-完毕" aria-hidden="true">#</a> 第6章　函数[完毕]</h2><ul><li><p>本章首先介绍函数的定义和声明(要知道这两个的区别)，包括参数如何传入函数以及函数<br> 如何返回结果。在C++语言中允许重载函数，也就是几个不同的函数可<br> 以使用同一个名字。所以接下来我们介绍重载函数的方法，以及编译器<br> 如何从函数的若干重载形式中选取一个与<mark>调用</mark>匹配的版本。最后，我们<br> 将介绍一些关于函数指针的知识。</p></li><li><p>函数是一个命名了的代码块，我们通过<mark>调用函数执行相应的代码</mark>。<br> 函数可以有0个或多个参数，而且（通常）会产生一个结果。可以重载<br> 函数，也就是说，同一个名字可以对应几个不同的函数。</p></li></ul><h2 id="_6-1-函数基础" tabindex="-1"><a class="header-anchor" href="#_6-1-函数基础" aria-hidden="true">#</a> 6.1　函数基础</h2><ul><li><p>一个典型的函数（function）定义包括以下部分：返回类型（return<br> type）、函数名字、由0个或多个形参（parameter）组成的列表以及函<br> 数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内。函数<br> 执行的操作在语句块（参见5.1节，第155页）中说明，该语句块称为函<br> 数体（function body）。</p></li><li><p>我们通过<mark>调用运算符（call operator）来执行函数</mark>。调用运算符的形<br> 式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数<br> 的指针；圆括号之内是一个用逗号隔开的实参（argument）列表，我们<br> 用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p></li><li><p><mark>编写函数</mark></p></li><li><p>举个例子，我们准备编写一个求数的阶乘的程序。n的阶乘是从1到<br> n所有数字的乘积，例如5的阶乘是120。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)</span>
<span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// local variable to hold the result as we calculate it</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
    ret <span class="token operator">*=</span> val<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// assign ret * val to ret and decrement val</span>
 <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment">// return the result</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>函数的名字是fact，它作用于一个整型参数，返回一个整型值。在<br> while循环内部，在每次迭代时用后置递减运算符（参见4.5节，第131<br> 页）将val的值减1。return语句负责结束fact并返回ret的值。</p></li><li><p><mark>调用函数</mark></p></li><li><p>要调用fact函数，必须提供一个整数值，调用得到的结果也是一个整数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j equals 120, i.e., the result of fact(5)</span>
 cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;5! is &quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二<br> 是将控制权转移给被调用函数。此时，<mark>主调函数</mark>（calling function）的<br> 执行被暂时中断，<mark>被调函数</mark>（called function）开始执行。</p></li><li><p>执行函数的第一步是（隐式地）定义并初始化它的形参。因此，当<br> 调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调<br> 用时所用的实参5。</p></li><li><p>当遇到一条return语句时函数结束执行过程。和函数调用一样，<br> return语句也完成两项工作：一是返回return语句中的值（如果有的<br> 话），二是将控制权从被调函数转移回主调函数。<mark>函数的返回值用于初<br> 始化调用表达式的结果</mark>，之后继续完成调用所在的表达式的剩余部分。<br> 因此，我们对fact函数的调用等价于如下形式：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// initialize val from the literal 5</span>
<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// code from the body of fact</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
  ret <span class="token operator">*=</span> val<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> ret<span class="token punctuation">;</span> <span class="token comment">// initialize j as a copy of ret</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p><mark>形参和实参</mark></p></li><li><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参<br> 初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并<br> 没有规定实参的求值顺序（参见4.1.3节，第123页）。编译器能以任意<br> 可行的顺序对实参求值。</p></li><li><p>实参的类型必须与对应的形参类型匹配，这一点与之前的规则是一<br> 致的，我们知道在初始化过程中初始值的类型也必须与初始化对象的类<br> 型匹配。函数有几个形参，我们就必须提供相同数量的实参。因为函数<br> 的调用规定实参数量应与形参数量一致(后面有讲到默认实参)，<br> 所以形参一定会被初始化。</p></li><li><p>在上面的例子中，fact函数只有一个int类型的形参，所以每次我们<br> 调用它的时候，都必须提供一个能转换（参见4.11节，第141页）成int的实参：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">fact</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: wrong argument type</span>
<span class="token function">fact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: too few arguments</span>
<span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: too many arguments</span>
<span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: argument is converted to int</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为不能将const char＊转换成int，所以第一个调用失败。第二个和<br> 第三个调用也会失败，不过错误的原因与第一个不同，它们是因为传入<br> 的实参数量不对。要想调用fact函数只能使用一个实参，只要实参数量<br> 不是一个，调用都将失败。最后一个调用是合法的，因为double可以转<br> 换成int。执行调用时，实参隐式地转换成int类型（截去小数部分），调<br> 用等价于 <code>fact(3);</code></li></ul><br><ul><li><mark>函数的形参列表</mark></li><li>函数的形参列表可以为空，但是不能省略。要想定义一个不带形参<br> 的函数，最常用的办法是书写一个空的形参列表。不过为了与C语言兼<br> 容，也可以使用关键字void表示函数没有形参：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// implicit void parameter list</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// explicit void parameter list</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声<br> 明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// error错误的</span>
<span class="token keyword">int</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// ok</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>任意两个形参都不能同名，<br><mark>而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字(可能要举个error代码例子)</mark></p></li><li><p>形参名是可选的，但是由于我们无法使用未命名的形参，所以形参<br> 一般都应该有个名字。偶尔，函数确实有个别形参不会被用到，则此类<br> 形参通常不命名以表示在函数体内不会使用它。不管怎样，是否设置未<br> 命名的形参并不影响调用时提供的实参数量。即使某个形参不被函数使<br> 用，也必须为它提供一个实参。</p></li></ul><br><ul><li><mark>函数返回类型</mark></li><li>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，<br> 它表示函数不返回任何值。<mark>函数的返回类型不能是数组（参见3.5<br> 节，第101页）类型或函数类型，但可以是指向数组或函数的指针</mark>。</li><li>将在6.3.3节（第205页）介绍如何定义一种特殊的函数，它的返回值是数组的指针（或引用），</li><li>在6.7节（第221页）将介绍如何返回指向函数的指针</li></ul><h3 id="_6-1节练习" tabindex="-1"><a class="header-anchor" href="#_6-1节练习" aria-hidden="true">#</a> 6.1节练习</h3><p>练习6.1：实参和形参的区别是什么？<br> 练习6.2：请指出下列函数哪个有错误，为什么？应该如何修改这些错误呢？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 string s<span class="token punctuation">;</span>
 <span class="token comment">// ...</span>
 <span class="token keyword">return</span> s<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v1<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">double</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span> <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习6.3：编写你自己的fact函数，上机检查是否正确。<br> 练习6.4：编写一个与用户交互的函数，要求用户输入一个数字，计算<br> 生成该数字的阶乘。在main函数中调用该函数。<br> 练习6.5：编写一个函数输出其实参的绝对值</p><h3 id="_6-1-1-局部对象" tabindex="-1"><a class="header-anchor" href="#_6-1-1-局部对象" aria-hidden="true">#</a> 6.1.1　局部对象</h3><ul><li><p>在C++语言中，<mark>名字有作用域</mark>（参见2.2.4节，第43页），<mark>对象有生命周期</mark>（lifetime）。<br> 理解这两个概念非常重要<br> · 名字的作用域是程序文本的一部分，名字在其中可见。<br> · 对象的生命周期是程序执行过程中该对象存在的一段时间。</p></li><li><p>如我们所知，函数体是一个语句块。块构成一个新的作用域，我们<br> 可以在其中定义变量。<mark>形参和函数体内部定义的变量统称为局部变量</mark><br> （local variable）。它们对函数而言是“局部”的，仅在函数的作用域内<br> 可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。</p></li><li><p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类<br> 对象在程序启动时被创建，直到程序结束才会销毁。<br> 局部变量的生命周期依赖于定义的方式。</p></li></ul><br><ul><li><p><mark>自动对象</mark></p></li><li><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定<br> 义语句时创建该对象，当到达定义所在的块末尾时销毁它。<br> 我们把只存在于块执行期间的对象称为自动对象（automatic object）。<br> 当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</p></li><li><p>形参是一种自动对象。<mark>函数开始时为形参申请存储空间</mark>，因为形参<br> 定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。</p></li><li><p>我们用传递给函数的实参初始化形参对应的自动对象。对于局部变<br> 量对应的自动对象来说，则分为两种情况：如果变量定义本身含有初始值，<br> 就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，<br> 执行默认初始化（参见2.2.1节，第40页）。这意味着内置类型的未<br> 初始化局部变量将产生未定义的值。</p></li></ul><br><ul><li><p><mark>局部静态对象(这个挺实用的)</mark></p></li><li><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时<br> 间。可以将局部变量定义成static类型从而获得这样的对象。局部静态<br> 对象（local static object）在程序的执行路径第一次经过对象定义语句时<br> 初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结<br> 束执行也不会对它有影响。</p></li><li><p>举个例子，下面的函数统计它自己被调用了多少次，这样的函数也<br> 许没什么实际意义，但是足够说明问题：</p></li><li><p>这段程序将输出从1到10（包括10在内）的数字。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>size_t <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       <span class="token keyword">static</span> size_t ctr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// value will persist across calls</span>
       <span class="token keyword">return</span> <span class="token operator">++</span>ctr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
       cout <span class="token operator">&lt;&lt;</span> <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次<br> 调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已<br> 经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值<br> 是1，第三次调用时ctr的值是2，以此类推。</p></li><li><p>如果局部静态变量没有显式的初始值，它将执行值初始化（参见<br> 3.3.1节，第88页），内置类型的局部静态变量初始化为0。</p></li></ul><h3 id="_6-1-1节练习" tabindex="-1"><a class="header-anchor" href="#_6-1-1节练习" aria-hidden="true">#</a> 6.1.1节练习</h3><p>练习6.6：说明形参、局部变量以及局部静态变量的区别。编写一个函<br> 数，同时用到这三种形式。<br> 练习6.7：编写一个函数，当它第一次被调用时返回0，以后每次被调用<br> 返回值加1。</p><h3 id="_6-1-2-函数声明" tabindex="-1"><a class="header-anchor" href="#_6-1-2-函数声明" aria-hidden="true">#</a> 6.1.2　函数声明</h3><ul><li><p>声明和定义的区别？</p></li><li><p>和其他名字一样，函数的名字也必须在使用之前声明。类似于变量<br> （参见2.2.2节，第41页），函数只能定义一次，但可以声明多次。唯一<br> 的例外是如15.3节（第535页）将要介绍的，如果一个函数永远也不会<br> 被我们用到，那么它可以只有声明没有定义。</p></li><li><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函<br> 数体，用一个分号替代即可。</p></li><li><p>因为函数的声明不包含函数体，所以也就无须形参的名字。事实<br> 上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字<br> 还是有用处的，它可以帮助使用者更好地理解函数的功能：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// parameter names chosen to indicate that the iterators denote a range of values to print</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator beg<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>函数的三要素（返回类型、函数名、形参类型）描述了函数的接<br> 口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）。</li></ul><br><ul><li><p><mark>在头文件中进行函数声明</mark></p></li><li><p>声明和定义？？</p></li><li><p>回忆之前所学的知识，我们建议变量在头文件（参见2.6.3节，第68页）中声明，<br> 在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p></li><li><p>看起来把函数的声明直接放在使用该函数的源文件中是合法的，也<br> 比较容易被人接受；但是这么做可能会很烦琐而且容易出错。相反，如<br> 果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。<br> 而且一旦我们想改变函数的接口，只需改变一条声明即可。</p></li><li><p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器<br> 负责验证函数的定义和声明是否匹配。</p></li><li><p><mark>含有函数声明的头文件应该被包含到定义函数的源文件中。</mark></p></li></ul><h3 id="_6-1-2节练习" tabindex="-1"><a class="header-anchor" href="#_6-1-2节练习" aria-hidden="true">#</a> 6.1.2节练习</h3><p>练习6.8：编写一个名为Chapter6.h的头文件，令其包含6.1节练习（第<br> 184页）中的函数声明。</p><h3 id="_6-1-3-分离式编译-需要去了解编译的细节" tabindex="-1"><a class="header-anchor" href="#_6-1-3-分离式编译-需要去了解编译的细节" aria-hidden="true">#</a> 6.1.3　分离式编译(需要去了解编译的细节)</h3><ul><li><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同<br> 文件中。例如，可以把6.1节练习（第184页）的函数存在一个文件里，<br> 把使用这些函数的代码存在其他源文件中。为了允许编写程序时按照逻<br> 辑关系将其划分开来，C++语言支持所谓的分离式编译（separate<br> compilation）。分离式编译允许我们把程序分割到几个文件中去，每个<br> 文件独立编译。</p></li><li><p><mark>编译和链接多个源文件</mark></p></li><li><p>举个例子，假设fact函数的定义位于一个名为fact.cc的文件中，它的<br> 声明位于名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文<br> 件一样，fact.cc应该包含Chapter6.h头文件。另外，我们在名为<br> factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成<br> 可执行文件（executable file），必须告诉编译器我们用到的代码在哪<br> 里。对于上述几个文件来说，编译的过程如下所示：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>$ CC factMain<span class="token punctuation">.</span>cc fact<span class="token punctuation">.</span>cc # generates factMain<span class="token punctuation">.</span>exe <span class="token operator">or</span> a<span class="token punctuation">.</span>out
$ CC factMain<span class="token punctuation">.</span>cc fact<span class="token punctuation">.</span>cc <span class="token operator">-</span>o main # generates main <span class="token operator">or</span> main<span class="token punctuation">.</span>exe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>其中，CC是编译器的名字，$是系统提示符，#后面是命令行下的<br> 注释语句。接下来运行可执行文件，就会执行我们定义的main函数。</p></li><li><p>如果我们修改了其中一个源文件，那么只需重新编译那个改动了的<br> 文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常<br> 会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的<br> 含义是该文件包含对象代码（object code）。</p></li><li><p>接下来编译器负责把对象文件链接在一起形成可执行文件。在我们<br> 的系统中，编译的过程如下所示：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>$ CC <span class="token operator">-</span>c factMain<span class="token punctuation">.</span>cc # generates factMain<span class="token punctuation">.</span>o
$ CC <span class="token operator">-</span>c fact<span class="token punctuation">.</span>cc # generates fact<span class="token punctuation">.</span>o
$ CC factMain<span class="token punctuation">.</span>o fact<span class="token punctuation">.</span>o # generates factMain<span class="token punctuation">.</span>exe <span class="token operator">or</span> a<span class="token punctuation">.</span>out
$ CC factMain<span class="token punctuation">.</span>o fact<span class="token punctuation">.</span>o <span class="token operator">-</span>o main # generates main <span class="token operator">or</span> main<span class="token punctuation">.</span>exe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>你可以仔细阅读编译器的用户手册，弄清楚由多个文件组成的程序<br> 是如何编译并执行的。</li></ul><h3 id="_6-1-3节练习" tabindex="-1"><a class="header-anchor" href="#_6-1-3节练习" aria-hidden="true">#</a> 6.1.3节练习</h3>`,51),f={href:"http://xn--fact-uo6fu1jbx3a738bceq6og.xn--ccfactMain-ih7q.cc",target:"_blank",rel:"noopener noreferrer"},h=n("br",null,null,-1),y=n("br",null,null,-1),w=e(`<h2 id="_6-2-参数传递" tabindex="-1"><a class="header-anchor" href="#_6-2-参数传递" aria-hidden="true">#</a> 6.2 参数传递</h2><ul><li><p>如前所述，每次调用函数时都会重新创建它的形参，并用传入的实<br> 参对形参进行初始化。</p></li><li><p><mark>形参初始化的机理与变量初始化一样</mark></p></li><li><p>和其他变量一样，形参的类型决定了形参和实参交互的方式。<br><mark>如果形参是引用类型（参见2.3.1节，第45页），它将绑定到对应的实参上</mark>；<br> 否则，将实参的值拷贝后赋给形参。</p></li><li><p>当形参是引用类型时，我们说它<mark>对应的实参被引用传递</mark>（passed by<br> reference）或者<mark>函数被传引用调用</mark>（called by reference）。和其他引用<br> 一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。</p></li><li><p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。<br> 我们说这样的实参被值传递（passed by value）或者函数被传值调用<br> （called by value）。</p></li></ul><h3 id="_6-2-1-传值参数" tabindex="-1"><a class="header-anchor" href="#_6-2-1-传值参数" aria-hidden="true">#</a> 6.2.1　传值参数</h3><ul><li>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，<br> 对变量的改动不会影响初始值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ordinary variable of type int</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// i is a copy of the value in n</span>
i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// value in i is changed; n is unchanged</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>传值参数的机理完全一样，函数对形参做的所有操作都不会影响实<br> 参。例如，在fact函数（参见6.1节，第182页）内对变量val执行递减操<br> 作:<code>ret *= val--; // 将val的数值减1</code></p></li><li><p>尽管fact函数改变了val的值，但是这个改动不会影响传入fact的实<br> 参。调用fact（i）不会改变i的值。</p></li></ul><br><ul><li><mark>指针形参</mark></li><li>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝<br> 的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可<br> 以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// p points to n; q points to i</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// value in n is changed; p is unchanged</span>
p <span class="token operator">=</span> q<span class="token punctuation">;</span> <span class="token comment">// p now points to i; values in i and n are unchanged</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>指针形参的行为与之类似(用内存存储空间来理解)：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// function that takes a pointer and sets the pointed-to value to zero</span>
<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// changes the value of the object to which ip points</span>
  ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// changes only the local copy of ip; the argument is unchanged</span>
  <span class="token comment">// 这里的话 仅仅是 局部对象 ip 的数值改变了；实参并没有改变；仅仅是一个copy的对象改变了</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调用reset函数之后，实参所指的对象被置为0，但是实参本身并没有改变：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// changes i but not the address of i</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;i = &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// prints i = 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><mark>熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建<br> 议使用引用类型的形参替代指针。(所以还是尽量使用引用&amp;)</mark></li></ul><h3 id="_6-2-1节练习" tabindex="-1"><a class="header-anchor" href="#_6-2-1节练习" aria-hidden="true">#</a> 6.2.1节练习</h3><ul><li>练习6.10：编写一个函数，使用指针形参交换两个整数的值。在代码中<br> 调用该函数并输出交换后的结果，以此验证函数的正确性。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_6-2-2-传引用参数" tabindex="-1"><a class="header-anchor" href="#_6-2-2-传引用参数" aria-hidden="true">#</a> 6.2.2　传引用参数</h3><ul><li>回忆过去所学的知识，我们知道对于引用的操作实际上是作用在引<br> 用所引的对象上（参见2.3.1节，第45页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// r is bound to n (i.e., r is another name for n)</span>
r <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// n is now 42</span>
r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// n now has the same value as i</span>
i <span class="token operator">=</span> r<span class="token punctuation">;</span> <span class="token comment">// i has the same value as n</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>引用形参的行为与之类似。通过使用引用形参，允许函数改变一个<br> 或多个实参的值。</p></li><li><p>举个例子，我们可以改写上一小节的reset程序，使其接受的参数是<br> 引用类型而非指针：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// function that takes a reference to an int and sets the given object to zero</span>
<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span> <span class="token comment">// i is just another name for the object passed to reset</span>
<span class="token punctuation">{</span>
    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// changes the value of the object to which i refers</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>和其他引用一样，引用形参绑定初始化它的对象。当调用这一版本<br> 的reset函数时，i绑定我们传给函数的int对象，此时改变i也就是改变i所<br> 引对象的值。此例中，被改变的对象是传入reset的实参。</p></li><li><p>调用这一版本的reset函数时，我们直接传入对象而无须传递对象的地址：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token function">reset</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j is passed by reference; the value in j is changed</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;j = &quot;</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// prints j = 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在上述调用过程中，形参i仅仅是j的又一个名字。在reset内部对i的使用即是对j的使用。</li></ul><br><ul><li><p><mark>使用引用避免拷贝(重点)</mark></p></li><li><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包<br> 括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作<br> 时，函数只能通过引用形参访问该类型的对象。<mark>Warning</mark></p></li><li><p>举个例子，我们准备编写一个函数比较两个string对象的长度。因<br> 为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使<br> 用引用形参是比较明智的选择。<mark>又因为比较长度无须改变string对象的<br> 内容，所以把形参定义成对常量的引用</mark>（参见2.4.1节，第54页）：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// compare the length of two strings</span>
<span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如6.2.3节（第191页）将要介绍的，<mark>当函数无须修改引用形参的值时最好使用常量引用</mark>。</p></li><li><p><mark>如果函数无须改变引用形参的值，最好将其声明为常量引用。</mark></p></li><li><p>不改变就使用 const</p></li></ul><br><ul><li><p><mark>使用引用形参返回额外信息</mark></p></li><li><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引<br> 用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定<br> 义一个名为find_char的函数，它返回在string对象中某个指定字符第一次<br> 出现的位置。同时，我们也希望函数能返回该字符出现的总次数。</p></li><li><p>该如何定义函数使得它能够既返回位置也返回出现次数呢？一种方<br> 法是定义一个新的数据类型，让它包含位置和数量两个成员。还有另一<br> 种更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存<br> 字符出现的次数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// returns the index of the first occurrence of c in s</span>
<span class="token comment">// the reference parameter occurs counts how often c occurs</span>
string<span class="token double-colon punctuation">::</span>size_type <span class="token function">find_char</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>size_type <span class="token operator">&amp;</span>occurs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> ret <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// position of the first occurrence, if any</span>
    occurs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// set the occurrence count parameter</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            ret <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// remember the first occurrence of c</span>
            <span class="token operator">++</span>occurs<span class="token punctuation">;</span> <span class="token comment">// increment the occurrence count</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment">// count is returned implicitly in occurs</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当我们调用find_char函数时，必须传入三个实参：作为查找范围的<br> 一个string对象、要找的字符以及一个用于保存字符出现次数的<br> size_type（参见3.2.2节，第79页）对象。假设s是一个string对象，ctr是<br> 一个size_type对象，则我们通过如下形式调用find_char函数：<br><code>auto index = find_char(s, &#39;o&#39;, ctr);</code></p></li><li><p>调用完成后，如果string对象中确实存在o，那么ctr的值就是o出现<br> 的次数，index指向o第一次出现的位置；否则如果string对象中没有o，<br> index等于s.size（）而ctr等于0。</p></li></ul><h3 id="_6-2-2节练习" tabindex="-1"><a class="header-anchor" href="#_6-2-2节练习" aria-hidden="true">#</a> 6.2.2节练习</h3><ul><li><p>练习6.11：编写并验证你自己的reset函数，使其作用于引用类型的参数。</p></li><li><p>练习6.12：改写6.2.1节中练习6.10（第188页）的程序，使用引用而非指<br> 针交换两个整数的值。你觉得哪种方法更易于使用呢？为什么？</p></li><li><p>练习6.13：假设T是某种类型的名字，说明以下两个函数声明的区别：<br> 一个是void f（T），另一个是void f（&amp;T）。</p></li><li><p>练习6.14：举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。</p></li><li><p>练习6.15：说明find_char函数中的三个形参为什么是现在的类型，特别<br> 说明为什么s是常量引用而occurs是普通引用？为什么s和occurs是引用类<br> 型而c不是？如果令s是普通引用会发生什么情况？如果令occurs是常量<br> 引用会发生什么情况？</p></li></ul><h3 id="_6-2-3-const形参和实参" tabindex="-1"><a class="header-anchor" href="#_6-2-3-const形参和实参" aria-hidden="true">#</a> 6.2.3 const形参和实参</h3><ul><li>当形参是const时，必须要注意2.4.3节（第57页）关于顶层const的<br> 讨论。如前所述，顶层const作用于对象本身：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// we cannot change ci; const is top-level</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// ok: when we copy ci, its top-level const is ignored</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// const is top-level; we can&#39;t assign to p</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ok: changes through p are allowed; i is now 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层<br> const。换句话说，形参的顶层const被忽略掉了。<br><mark>当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：</mark></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* fcn can read but not write to i */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的<br> 顶层const可能产生意想不到的结果：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* fcn can read but not write to i */</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* . . . */</span> <span class="token punctuation">}</span> <span class="token comment">// error: redefines fcn(int)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在C++语言中，允许我们定义若干具有相同名字的函数，不过前提<br> 是不同函数的形参列表应该有明显的区别。因为顶层const被忽略掉了，<br> 所以在上面的代码中传入两个fcn函数的参数可以完全一样。因此第二<br> 个fcn是错误的，尽管形式上有差异，但实际上它的形参和第一个fcn的<br> 形参没什么不同。</li></ul><br><ul><li><mark>指针或引用形参与const</mark></li><li>形参的初始化方式和变量的初始化方式是一样的，所以回顾通用的<br> 初始化规则有助于理解本节知识。我们可以使用非常量初始化一个底层<br> const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象<br> 初始化。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// ok: but cp can&#39;t change i (§ 2.4.2 (p. 62))</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// ok: but r can&#39;t change i (§ 2.4.1 (p. 61))</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// ok: (§ 2.4.1 (p. 61))</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> cp<span class="token punctuation">;</span> <span class="token comment">// error: types of p and cp don&#39;t match (§ 2.4.2 (p. 62))</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> r<span class="token punctuation">;</span> <span class="token comment">// error: types of r3 and r don&#39;t match (§ 2.4.1 (p. 61))</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r4 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t initialize a plain reference from a literal (§ 2.3.1 (p.50))</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将同样的初始化规则应用到参数传递上可得如下形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span>
string<span class="token double-colon punctuation">::</span>size_type ctr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls the version of reset that has an int* parameter</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t initialize an int* from a pointer to a const int object</span>
<span class="token function">reset</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls the version of reset that has an int&amp; parameter</span>
<span class="token function">reset</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t bind a plain reference to the const object ci</span>
<span class="token function">reset</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: can&#39;t bind a plain reference to a literal</span>
<span class="token function">reset</span><span class="token punctuation">(</span>ctr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: types don&#39;t match; ctr has an unsigned type</span>
<span class="token comment">// ok: find_char&#39;s first parameter is a reference to const</span>
<span class="token function">find_char</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">,</span> <span class="token char">&#39;o&#39;</span><span class="token punctuation">,</span> ctr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>要想调用引用版本的reset（参见6.2.2节，第189页），只能使用int<br> 类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的<br> 对象或者const int类型的对象。类似的，要想调用指针版本的reset（参<br> 见6.2.1节，第188页）只能使用int＊。另一方面，我们能传递一个字符<br> 串字面值作为find_char（参见6.2.2节，第189页）的第一个实参，这是<br> 因为该函数的引用形参是常量引用，而C++允许我们用字面值初始化常<br> 量引用。</li></ul><br><ul><li><p><mark>尽量使用常量引用</mark></p></li><li><p>把函数不会改变的形参定义成（普通的）引用是一种比较常见的错<br> 误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的<br> 值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参<br> 类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转<br> 换的对象传递给普通的引用形参。</p></li><li><p>这种错误绝不像看起来那么简单，它可能造成出人意料的后果。以<br> 6.2.2节（第189页）的find_char函数为例，那个函数（正确地）将它的<br> string类型的形参定义成常量引用。假如我们把它定义成普通的<code>string&amp;</code>：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// bad design: the first parameter should be a const string&amp;</span>
string<span class="token double-colon punctuation">::</span>size_type <span class="token function">find_char</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>size_type <span class="token operator">&amp;</span>occurs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    则只能将find_char函数作用于string对象。类似下面这样的调用
    <span class="token function">find_char</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">,</span> <span class="token char">&#39;o&#39;</span><span class="token punctuation">,</span> ctr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    将在编译时发生错误。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>还有一个更难察觉的问题，假如其他函数（正确地）将它们的形参<br> 定义成常量引用，那么第二个版本的find_char无法在此类函数中正常使<br> 用。举个例子，我们希望在一个判断string对象是否是句子的函数中使<br> 用find_char：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">is_sentence</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// if there&#39;s a single period at the end of s, then s is a sentence</span>
    string<span class="token double-colon punctuation">::</span>size_type ctr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">find_char</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token char">&#39;.&#39;</span><span class="token punctuation">,</span> ctr<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> ctr <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果find_char的第一个形参类型是string&amp;，那么上面这条调用<br> find_char的语句将在编译时发生错误。原因在于s是常量引用，但<br> find_char被（不正确地）定义成只能接受普通引用。</p></li><li><p>解决该问题的一种思路是修改is_sentence的形参类型，但是这么做<br> 只不过转移了错误而已，结果是is_sentence函数的调用者只能接受非常<br> 量string对象了。</p></li><li><p>正确的修改思路是改正find_char函数的形参。如果实在不能修改<br> find_char，就在is_sentence内部定义一个string类型的变量，令其为s的副<br> 本，然后把这个string对象传递给find_char。</p></li></ul><h3 id="_6-2-3节练习" tabindex="-1"><a class="header-anchor" href="#_6-2-3节练习" aria-hidden="true">#</a> 6.2.3节练习</h3><ul><li>练习6.16：下面的这个函数虽然合法，但是不算特别有用。指出它的局<br> 限性并设法改善。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>练习6.17：编写一个函数，判断string对象中是否含有大写字母。编写另<br> 一个函数，把string对象全都改成小写形式。在这两个函数中你使用的<br> 形参类型相同吗？为什么？</p></li><li><p>练习6.18：为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> A function named compare that returns a <span class="token keyword">bool</span> <span class="token operator">and</span> has two parameters
that are references to a <span class="token keyword">class</span> <span class="token class-name">named</span> matrix<span class="token punctuation">.</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> A function named change_val that returns a vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> iterator
<span class="token operator">and</span> takes two parameters<span class="token operator">:</span> One is an <span class="token keyword">int</span> <span class="token operator">and</span> the other is an iterator <span class="token keyword">for</span> a
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">.</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.19：假定有如下声明，判断哪个调用合法、哪个调用不合法。对<br> 于不合法的函数调用，说明原因。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">double</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">23.4</span><span class="token punctuation">,</span> <span class="token number">55.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token string">&quot;abcda&quot;</span><span class="token punctuation">,</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token function">sum</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.20：引用形参什么时候应该是常量引用？如果形参应该是常量引<br> 用，而我们将其设为了普通引用，会发生什么情况？</li></ul><h3 id="_6-2-4-数组形参" tabindex="-1"><a class="header-anchor" href="#_6-2-4-数组形参" aria-hidden="true">#</a> 6.2.4　数组形参</h3><ul><li><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影<br> 响，这两个性质分别是：不允许拷贝数组（参见3.5.1节，第102页）以<br> 及使用数组时（通常）会将其转换成指针（参见3.5.3节，第105页）。<br> 因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为<br> 数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递<br> 的是指向数组首元素的指针。</p></li><li><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似<br> 数组的形式：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token comment">// each function has a single parameter of type const int*</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// shows the intent that the function takes an array</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dimension for documentation purposes (at best)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一<br> 形参都是const int＊类型的。当编译器处理对print函数的调用时，只检<br> 查传入的参数是否是const int＊类型：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: &amp;i is int*</span>
<span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: j is converted to an int* that points to j[0]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果我们传给print函数的是一个数组，则实参自动地转换成指向数<br> 组首元素的指针，数组的大小对函数的调用没有影响。</p></li><li><p>和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。</p></li><li><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道<br> 数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参<br> 有三种常用的技术。</p></li></ul><br><ul><li><mark>使用标记指定数组长度</mark></li><li>管理数组实参的第一种方法是要求数组本身包含一个结束标记，使<br> 用这种方法的典型示例是C风格字符串（参见3.5.4节，第109页）。C风<br> 格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字<br> 符。函数在处理C风格字符串时遇到空字符停止：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token comment">// if cp is not a null pointer</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token punctuation">)</span> <span class="token comment">// so long as the character it points to is not a null character</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>cp<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// print the character and advance the pointer</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆<br> 的情况，但是对于像int这样所有取值都是合法值的数据就不太有效了。</li></ul><br><ul><li><mark>使用标准库规范</mark></li><li>管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指<br> 针，这种方法受到了标准库技术的启发，关于其细节将在第II部分详细<br> 介绍。使用该方法，我们可以按照如下形式输出元素内容：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// print every element starting at beg up to but not including end</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>beg <span class="token operator">!=</span> end<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// print the current element</span>
    <span class="token comment">// and advance the pointer</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>while循环使用解引用运算符和后置递减运算符（参见4.5节，第131<br> 页）输出当前元素并在数组内将beg向前移动一个元素，当beg和end相<br> 等时结束循环。</p></li><li><p>为了调用这个函数，我们需要传入两个指针：一个指向要输出的首<br> 元素，另一个指向尾元素的下一位置：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// j is converted to a pointer to the first element in j</span>
<span class="token comment">// the second argument is a pointer to one past the end of j</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// begin and end functions, see § 3.5.3 (p. 118)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只要调用者能正确地计算指针所指的位置，那么上述代码就是安全<br> 的。在这里，我们使用标准库begin和end函数（参见3.5.3节，第106页）<br> 提供所需的指针。</li></ul><br><ul><li><mark>显式传递一个表示数组大小的形参</mark></li><li>第三种管理数组实参的方法是专门定义一个表示数组大小的形参，<br> 在C程序和过去的C++程序中常常使用这种方法。使用该方法，可以将<br> print函数重写成如下形式：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// const int ia[] is equivalent to const int* ia</span>
<span class="token comment">// size is passed explicitly and used to control access to elements of ia</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个版本的程序通过形参size的值确定要输出多少个元素，调用<br> print函数时必须传入这个表示数组大小的值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// int array of size 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只要传递给函数的size值不超过数组实际的大小，函数就是安全的。</li></ul><br><ul><li><p><mark>数组形参和const</mark></p></li><li><p>我们的三个print函数都把数组形参定义成了指向const的指针，6.2.3<br> 节（第191页）关于引用的讨论同样适用于指针。当函数不需要对数组<br> 元素执行写操作的时候，数组形参应该是指向const的指针（参见2.4.2<br> 节，第56页）。只有当函数确实要改变元素值的时候，才把形参定义成<br> 指向非常量的指针。</p></li><li><p>数组引用形参:</p></li><li><p>C++语言允许将变量定义成数组的引用（参见3.5.1节，第101<br> 页），基于同样的道理，形参也可以是数组的引用。此时，引用形参绑<br> 定到对应的实参上，也就是绑定到数组上：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// ok: parameter is a reference to an array; the dimension is part of the type</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> arr<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><mark>&amp;arr两端的括号必不可少（参见3.5.1节，第101页）：</mark></p></li><li><p>f(int &amp;arr[10]) // error: declares arr as an array of references</p></li><li><p>f(int (&amp;arr)[10]) // ok: arr is a reference to an array of ten ints</p></li><li><p>因为数组的大小是构成数组类型的一部分，所以只要不超过维度，<br> 在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了<br> print函数的可用性，我们只能将函数作用于大小为10的数组：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> k<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: argument is not an array of ten ints</span>
<span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: argument is not an array of ten ints</span>
<span class="token function">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: argument is an array of ten ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>16.1.1节（第578页）将要介绍我们应该如何编写这个函数，使其可<br> 以给引用类型的形参传递任意大小的数组。</li></ul><br><ul><li><p><mark>传递多维数组</mark></p></li><li><p>我们曾经介绍过，在C++语言中实际上没有真正的多维数组（参见<br> 3.6节，第112页），所谓多维数组其实是数组的数组。</p></li><li><p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向<br> 数组首元素的指针（参见3.6节，第115页）。因为我们处理的是数组的<br> 数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。<br> 数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能<br> 省略：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// matrix points to the first element in an array whose elements are arrays of ten ints</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rowSize<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* . . . */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>上述语句将matrix声明成指向含有10个整数的数组的指针。</p></li><li><p><mark>再一次强调，＊matrix两端的括号必不可少：</mark></p></li></ul><h3 id="_6-2-4节练习" tabindex="-1"><a class="header-anchor" href="#_6-2-4节练习" aria-hidden="true">#</a> 6.2.4节练习</h3><ul><li><p>练习6.21：编写一个函数，令其接受两个参数：一个是int型的数，另一<br> 个是int指针。函数比较int的值和指针所指的值，返回较大的那个。在该<br> 函数中指针的类型应该是什么？</p></li><li><p>练习6.22：编写一个函数，令其交换两个int指针。</p></li><li><p>练习6.23：参考本节介绍的几个print函数，根据理解编写你自己的版<br> 本。依次调用每个函数使其输入下面定义的i和j：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.24：描述下面这个函数的行为。如果代码中存在问题，请指出并<br> 改正。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
  cout <span class="token operator">&lt;&lt;</span> ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-5-main-处理命令行选项" tabindex="-1"><a class="header-anchor" href="#_6-2-5-main-处理命令行选项" aria-hidden="true">#</a> 6.2.5 main：处理命令行选项</h3><ul><li><p>main函数是演示C++程序如何向函数传递数组的好例子。到目前为<br> 止，我们定义的main函数都只有空形参列表：<br><code>int main() {...}</code></p></li><li><p>然而，有时我们确实需要给main传递实参，一种常见的情况是用户<br> 通过设置一组选项来确定函数所要执行的操作。例如，假定main函数位<br> 于可执行文件prog之内，我们可以向程序传递下面的选项：<br><code>prog -d -o ofile data0</code></p></li><li><p>这些命令行选项通过两个（可选的）形参传递给main函数：<br><code>int main(int argc, char *argv[]) {...}</code></p></li><li><p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指<br> 针；第一个形参argc表示数组中字符串的数量。因为第二个形参是数<br> 组，所以main函数也可以定义成：其中argv指向char＊。<br><code>int main(int argc, char **argv) {...}</code></p></li><li><p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者<br> 一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指<br> 针之后的元素值保证为0。</p></li><li><p>以上面提供的命令行为例，argc应该等于5，argv应该包含如下的C<br> 风格字符串：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;prog&quot;</span><span class="token punctuation">;</span> <span class="token comment">// or argv[0] might point to an empty string</span>
argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;-d&quot;</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;-o&quot;</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;ofile&quot;</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;data0&quot;</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><mark>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序<br> 的名字，而非用户输入。</mark></li></ul><h3 id="_6-2-5节练习" tabindex="-1"><a class="header-anchor" href="#_6-2-5节练习" aria-hidden="true">#</a> 6.2.5节练习</h3><ul><li><p>练习6.25：编写一个main函数，令其接受两个实参。把实参的内容连接<br> 成一个string对象并输出出来。</p></li><li><p>练习6.26：编写一个程序，使其接受本节所示的选项；输出传递给main<br> 函数的实参的内容。</p></li></ul><h3 id="_6-2-6-含有可变形参的函数-先不进行整" tabindex="-1"><a class="header-anchor" href="#_6-2-6-含有可变形参的函数-先不进行整" aria-hidden="true">#</a> 6.2.6　含有可变形参的函数(先不进行整)</h3><ul><li></li></ul><h2 id="_6-3-返回类型和return语句" tabindex="-1"><a class="header-anchor" href="#_6-3-返回类型和return语句" aria-hidden="true">#</a> 6.3　返回类型和return语句</h2><ul><li>return语句终止当前正在执行的函数并将控制权返回到调用该函数<br> 的地方。return语句有两种形式：<br><code>return ;</code><br><code>return expression;</code></li></ul><h3 id="_6-3-1-无返回值函数" tabindex="-1"><a class="header-anchor" href="#_6-3-1-无返回值函数" aria-hidden="true">#</a> 6.3.1　无返回值函数</h3><ul><li><p>没有返回值的return语句只能用在返回类型是void的函数中。返回<br> void的函数不要求非得有return语句，因为在这类函数的最后一句后面会<br> 隐式地执行return。</p></li><li><p>通常情况下，void函数如果想在它的中间位置提前退出，可以使用<br> return语句。return的这种用法有点类似于我们用break语句（参见5.5.1<br> 节，第170页）退出循环。例如，可以编写一个swap函数，使其在参与<br> 交换的值相等时什么也不做直接退出：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// if the values are already the same, no need to swap, just return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2<span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// if we&#39;re here, there&#39;s work to do</span>
  <span class="token keyword">int</span> tmp <span class="token operator">=</span> v2<span class="token punctuation">;</span>
  v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
  v1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
  <span class="token comment">// no explicit return necessary</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这个函数首先检查值是否相等，如果相等直接退出函数；如果不相<br> 等才交换它们的值。在最后一条赋值语句后面隐式地执行return。</p></li><li><p>一个返回类型是void的函数也能使用return语句的第二种形式，不过<br> 此时return语句的expression必须是另一个返回void的函数。强行令void<br> 函数返回其他类型的表达式将产生编译错误。</p></li></ul><h3 id="_6-3-2-有返回值函数" tabindex="-1"><a class="header-anchor" href="#_6-3-2-有返回值函数" aria-hidden="true">#</a> 6.3.2　有返回值函数</h3><ul><li><p>return语句的第二种形式提供了函数的结果。只要函数的返回类型<br> 不是void，则该函数内的每条return语句必须返回一个值。return语句返<br> 回值的类型必须与函数的返回类型相同，或者能隐式地转换成（参见<br> 4.11节，第141页）函数的返回类型。</p></li><li><p>尽管C++无法确保结果的正确性，但是可以保证每个return语句的结<br> 果类型正确。也许无法顾及所有情况，但是编译器仍然尽量确保具有返<br> 回值的函数只能通过一条有效的return语句退出。例如：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// incorrect return values, this code will not compile</span>
<span class="token keyword">bool</span> <span class="token function">str_subrange</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>str1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>str2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// same sizes: return normal equality test</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> str1 <span class="token operator">==</span> str2<span class="token punctuation">;</span> <span class="token comment">// ok: == returns bool</span>
 <span class="token comment">// find the size of the smaller string; conditional operator, see § 4.7 (p. 151)</span>
 <span class="token keyword">auto</span> size <span class="token operator">=</span> <span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// look at each element up to the size of the smaller string</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// error #1: no return value; compiler should detect this error</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// error #2: control might flow off the end of the function without a return</span>
 <span class="token comment">// the compiler might not detect this error</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>for循环内的return语句是错误的，因为它没有返回值，编译器能检测到这个错误。</p></li><li><p>第二个错误是函数在for循环之后没有提供return语句。在上面的程<br> 序中，如果一个string对象是另一个的子集，则函数在执行完for循环后<br> 还将继续其执行过程，显然应该有一条return语句专门处理这种情况。<br> 编译器也许能检测到这个错误，也许不能；如果编译器没有发现这个错<br> 误，则运行时的行为将是未定义的。</p></li><li><p><mark>在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是<br> 错误的。很多编译器都无法发现此类错误。</mark></p></li></ul><br><ul><li><p><mark>值是如何被返回的</mark></p></li><li><p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回<br> 的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p></li><li><p>必须注意当函数返回局部变量时的初始化规则。例如我们书写一个<br> 函数，给定计数值、单词和结束符之后，判断计数值是否大于1：如果<br> 是，返回单词的复数形式；如果不是，返回单词原形：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// return the plural version of word if ctr is greater than 1</span>
string <span class="token function">make_plural</span><span class="token punctuation">(</span>size_t ctr<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>word<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>ending<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>ctr <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> word <span class="token operator">+</span> ending <span class="token operator">:</span> word<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>该函数的返回类型是string，意味着返回值将被拷贝到调用点。因<br> 此，该函数将返回word的副本或者一个未命名的临时string对象，该对<br> 象的内容是word和ending的和。</p></li><li><p>同其他引用类型一样，如果函数返回引用，则该引用仅是它所引对<br> 象的一个别名。举个例子来说明，假定某函数挑出两个string形参中较<br> 短的那个并返回其引用(返回的是 s1 or s2)：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// return a reference to the shorter of two strings</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其中形参和返回类型都是const string的引用，不管是调用函数还是<br> 返回结果都不会真正拷贝string对象。</li></ul><br><ul><li><mark>不要返回局部对象的引用或指针</mark></li><li>函数完成后，它所占用的存储空间也随之被释放掉（参见6.1.1节，<br> 第184页）。因此，函数终止意味着局部变量的引用将指向不再有效的<br> 内存区域：（局部完成后内存释放, 以存储的角度去看思考）</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// disaster: this function returns a reference to a local object</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">manip</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 string ret<span class="token punctuation">;</span>
 <span class="token comment">// transform ret in some way</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment">// WRONG: returning a reference to a local object!</span>
 <span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token string">&quot;Empty&quot;</span><span class="token punctuation">;</span> <span class="token comment">// WRONG: &quot;Empty&quot; is a local temporary string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>上面的两条return语句都将返回未定义的值，也就是说，试图使用<br> manip函数的返回值将引发未定义的行为。对于第一条return语句来说，<br> 显然它返回的是局部对象的引用。在第二条return语句中，字符串字面<br> 值转换成一个局部临时string对象，对于manip来说，该对象和ret一样都<br> 是局部的。当函数结束时临时对象占用的空间也就随之释放掉了，所以<br> 两条return语句都指向了不再可用的内存空间。</p></li><li><p><mark>要想确保返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象？</mark></p></li><li><p>如前所述，返回局部对象的引用是错误的；同样，返回局部对象的<br> 指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不<br> 存在的对象。</p></li></ul><br><ul><li><p><mark>返回类类型的函数和调用运算符</mark></p></li><li><p>和其他运算符一样，调用运算符也有优先级和结合律（参见4.1.2<br> 节，第121页）。调用运算符的优先级与点运算符和箭头运算符（参见<br> 4.6节，第133页）相同，并且也符合左结合律。因此，如果函数返回指<br> 针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成<br> 员。</p></li><li><p>例如，我们可以通过如下形式得到较短string对象的长度：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// call the size member of the string returned by shorterString</span>
<span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因为上面提到的运算符都满足左结合律，所以shorterString的结果<br> 是点运算符的左侧运算对象，点运算符可以得到该string对象的size成<br> 员，size又是第二个调用运算符的左侧运算对象。</p></li><li><p><mark>引用返回左值</mark></p></li><li><p>函数的返回类型决定函数调用是否是左值（参见4.1.1节，第121<br> 页）。调用一个返回引用的函数得到左值，其他返回类型得到右值。可<br> 以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能<br> 为返回类型是非常量引用的函数的结果赋值：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token function">get_val</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>size_type ix<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> str<span class="token punctuation">[</span>ix<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// get_val assumes the given index is valid</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;a value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// prints a value</span>
 <span class="token function">get_val</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span> <span class="token comment">// changes s[0] to A</span>
 cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// prints A value</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没<br> 什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它也<br> 能出现在赋值运算符的左侧。</p></li><li><p>如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和<br> 我们熟悉的情况是一样的：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bye&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;X&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error: return value is const</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><ul><li><p><mark>列表初始化返回值</mark></p></li><li><p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于<br> 其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始<br> 化。如果列表为空，临时量执行值初始化（参见3.3.1节，第88页）；否<br> 则，返回的值由函数的返回类型决定。</p></li><li><p>举个例子，回忆6.2.6节（第198页）的error_msg函数，该函数的输<br> 入是一组可变数量的string实参，输出由这些string对象组成的错误信<br> 息。在下面的函数中，我们返回一个vector对象，用它存放表示错误信<br> 息的string对象：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// . . .</span>
 <span class="token comment">// expected and actual are strings</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>expected<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// return an empty vector</span>
 <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expected <span class="token operator">==</span> actual<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;okay&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// return list-initialized vector</span>
 <span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">&quot;functionX&quot;</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> actual<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第一条return语句返回一个空列表，此时，process函数返回的vector<br> 对象是空的。如果expected不为空，根据expected和actual是否相等，函<br> 数返回的vector对象分别用两个或三个元素初始化。</p></li><li><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个<br> 值，而且该值所占空间不应该大于目标类型的空间（参见2.2.1节，第39<br> 页）。如果函数返回的是类类型，由类本身定义初始值如何使用（参见<br> 3.3.1节，第89页）。</p></li></ul><br><ul><li><p><mark>主函数main的返回值</mark></p></li><li><p>之前介绍过，如果函数的返回类型不是void，那么它必须返回一个<br> 值。但是这条规则有个例外：我们允许main函数没有return语句直接结<br> 束。如果控制到达了main函数的结尾处而且没有return语句，编译器将<br> 隐式地插入一条返回0的return语句。</p></li><li><p>如1.1节（第2页）介绍的，main函数的返回值可以看做是状态指示<br> 器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体<br> 含义依机器而定。为了使返回值与机器无关，cstdlib头文件定义了两个<br> 预处理变量（参见2.3.2节，第49页），我们可以使用这两个变量分别表<br> 示成功与失败：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>some_failure<span class="token punctuation">)</span>
    <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span> <span class="token comment">// defined in cstdlib</span>
 <span class="token keyword">else</span>
    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span> <span class="token comment">// defined in cstdlib</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为它们是预处理变量，所以既不能在前面加上std：：，也不能在<br> using声明中出现。</li></ul><br><ul><li><mark>递归</mark></li><li>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，<br> 都称该函数为递归函数（recursive function）。举个例子，我们可以使<br> 用递归函数重新实现求阶乘的功能：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// calculate val!, which is 1 * 2 * 3 . . . * val</span>
<span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>val<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在上面的代码中，我们递归地调用factorial函数以求得从val中减去1<br> 后新数字的阶乘。当val递减到1时，递归终止，返回1。</p></li><li><p>在递归函数中，一定有某条路径是不包含递归调用的；否则，函数<br> 将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空<br> 间耗尽为止。我们有时候会说这种函数含有递归循环（recursion<br> loop）。在factorial函数中，递归终止的条件是val等于1。</p></li><li><p><mark>main函数不能调用它自己。</mark></p></li></ul><h3 id="_6-3-2节练习" tabindex="-1"><a class="header-anchor" href="#_6-3-2节练习" aria-hidden="true">#</a> 6.3.2节练习</h3><ul><li>练习6.30：编译第200页的str_subrange函数，看看你的编译器是如何处理函数中的错误的。</li><li>练习6.31：什么情况下返回的引用无效？什么情况下返回常量的引用无效？</li><li>练习6.32：下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释原因。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arry<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> arry<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
 <span class="token function">get</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.33：编写一个递归函数，输出vector对象的内容。</li><li>练习6.34：如果factorial函数的停止条件如下所示，将发生什么情况？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.35：在调用factorial函数时，为什么我们传入的值是val-1而非val--？</li></ul><h3 id="_6-3-3-返回数组指针-繁琐的" tabindex="-1"><a class="header-anchor" href="#_6-3-3-返回数组指针-繁琐的" aria-hidden="true">#</a> 6.3.3　返回数组指针(繁琐的)</h3><ul><li>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返<br> 回数组的指针或引用（参见3.5.1节，第102页）。虽然从语法上来说，<br> 要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法<br> 可以简化这一任务，其中最直接的方法是使用类型别名（参见2.5.1节，<br> 第60页）：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> arrT<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// arrT is a synonym for the type array of ten ints</span>
<span class="token keyword">using</span> arrtT <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// equivalent declaration of arrT; see § 2.5.1 (p. 68)</span>
arrT<span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// func returns a pointer to an array of five ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>其中arrT是含有10个整数的数组的别名。因为我们无法返回数组，<br> 所以将返回类型定义成数组的指针。因此，func函数接受一个int实参，<br> 返回一个指向包含10个整数的数组的指针。</p></li><li><p><mark>声明一个返回数组指针的函数</mark></p></li><li><p>要想在声明func时不使用类型别名，我们必须牢记被定义的名字后<br> 面数组的维度：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// arr is an array of ten ints</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p1 is an array of ten pointers</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span> <span class="token comment">// p2 points to an array of ten ints</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>和这些声明一样，如果我们想定义一个返回数组指针的函数，则数<br> 组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名<br> 字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形<br> 式如下所示：<br><code>Type (*function(parameter_list))[dimension]</code></p></li><li><p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组<br> 的大小。<code>（*function（parameter_list））</code>两端的括号必须存在，就像我<br> 们定义p2时两端必须有括号一样。如果没有这对括号，函数的返回类型<br> 将是指针的数组。</p></li><li><p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：<br><code>int (*func(int i))[10];</code></p></li><li><p>可以按照以下的顺序来逐层理解该声明的含义：<br> · <code>func（int i）表示调用func函数时需要一个int类型的实参。</code><br> · <code>（＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。</code><br> · <code>（＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。</code><br> · <code>int （＊func（int i））[10]表示数组中的元素是int类型。</code></p></li></ul><br><ul><li><mark>使用尾置返回类型</mark></li><li>在C++11新标准中还有一种可以简化上述func声明的方法，就是使<br> 用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置<br> 返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类<br> 型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以<br> 一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我<br> 们在本应该出现返回类型的地方放置一个auto：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地<br> 看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。</li></ul><br><ul><li><mark>使用decltype</mark></li><li>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就<br> 可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指<br> 针，该指针根据参数i的不同指向两个已知数组中的某一个：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// returns a pointer to an array of five int elements</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">arrPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>odd <span class="token operator">:</span> <span class="token operator">&amp;</span>even<span class="token punctuation">;</span> <span class="token comment">// returns a pointer to the array</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针<br> 所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指<br> 向含有5个整数的数组的指针。有一个地方需要注意：decltype并不负责<br> 把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表<br> 示arrPtr返回指针还必须在函数声明时加一个＊符号。</li></ul><h3 id="_6-3-3节练习" tabindex="-1"><a class="header-anchor" href="#_6-3-3节练习" aria-hidden="true">#</a> 6.3.3节练习</h3><ul><li>练习6.36：编写一个函数的声明，使其返回数组的引用并且该数组包含10个string对象。不要使用尾置返回类型、decltype或者类型别名。</li><li>练习6.37：为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。你觉得哪种形式最好？为什么？</li><li>练习6.38：修改arrPtr函数，使其返回数组的引用。</li></ul><h2 id="_6-4-函数重载" tabindex="-1"><a class="header-anchor" href="#_6-4-函数重载" aria-hidden="true">#</a> 6.4　函数重载</h2><ul><li>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之<br> 为重载（overloaded）函数。例如，在6.2.4节（第193页）中我们定义了<br> 几个名为print的函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调<br> 用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(const char*)</span>
<span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(const int*, size_t)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(const int*, const int*)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载<br> 可以在一定程度上减轻程序员起名字、记名字的负担。</p></li><li><p><mark>main函数不能重载。</mark></p></li></ul><br><ul><li><mark>定义重载函数</mark></li><li>有一种典型的数据库应用，需要创建几个不同的函数分别根据名<br> 字、电话、账户号码等信息查找记录。函数重载使得我们可以定义一组<br> 函数，它们的名字都是lookup，但是查找的依据不同。我们能通过以下<br> 形式中的任意一种调用lookup函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// find by Account</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// find by Phone</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Name<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// find by Name</span>
Account acct<span class="token punctuation">;</span>
Phone phone<span class="token punctuation">;</span>
Record r1 <span class="token operator">=</span> <span class="token function">lookup</span><span class="token punctuation">(</span>acct<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call version that takes an Account</span>
Record r2 <span class="token operator">=</span> <span class="token function">lookup</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call version that takes a Phone</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>其中，虽然我们定义的三个函数各不相同，但它们都有同一个名<br> 字。编译器根据实参的类型确定应该调用哪一个函数。</p></li><li><p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不<br> 同。在上面的代码中，虽然每个函数都只接受一个参数，但是参数的类<br> 型不同</p></li><li><p>不允许两个函数除了返回类型外其他所有的要素都相同。假设有两<br> 个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明<br> 是错误的：（仅仅是返回类型不同是不行的？）</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: only the return type is different</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>判断两个形参的类型是否相异</mark></li><li>有时候两个形参列表看起来不一样，但实际上是相同的：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// each pair declares the same function</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account <span class="token operator">&amp;</span>acct<span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// parameter names are ignored</span>
<span class="token keyword">typedef</span> Phone Telno<span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Telno<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Telno and Phone are the same type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在第一对声明中，第一个函数给它的形参起了名字，第二个函数没<br> 有。形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表<br> 的内容。</p></li><li><p>第二对声明看起来类型不同，但事实上Telno不是一种新类型，它<br> 只是Phone的别名而已。类型别名（参见2.5.1节，第60页）为已存在的<br> 类型提供另外一个名字，它并不是创建新类型。因此，第二对中两个形<br> 参的区别仅在于一个使用类型原来的名字，另一个使用它的别名，从本<br> 质上来说它们没什么不同。</p></li></ul><br><ul><li><mark>重载和const形参</mark></li><li>如6.2.3节（第190页）介绍的，顶层const（参见2.4.3节，第57页）<br> 不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶<br> 层const的形参区分开来：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// redeclares Record lookup(Phone)</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// redeclares Record lookup(Phone*)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。</p></li><li><p>另一方面，如果形参是某种类型的指针或引用，则通过区分其指向<br> 的是常量对象还是非常量对象可以实现函数重载，此时的const是底层<br> 的：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// functions taking const and nonconst references or pointers have different parameters</span>
<span class="token comment">// declarations for four independent, overloaded functions</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function that takes a reference to Account</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new function that takes a const reference</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new function, takes a pointer to Account</span>
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new function, takes a pointer to const</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在上面的例子中，编译器可以通过实参是否是常量来推断应该调用<br> 哪个函数。因为const不能转换成其他类型（参见4.11.2节，第144页），<br> 所以我们只能把const对象（或指向const的指针）传递给const形参。相<br> 反的，因为非常量可以转换成const，所以上面的4个函数都能作用于非<br> 常量对象或者指向非常量对象的指针。不过，如6.6.1节（第220页）将<br> 要介绍的，当我们传递一个非常量对象或者指向非常量对象的指针时，<br> 编译器会优先选用非常量版本的函数。</li></ul><br><ul><li><mark>建议：何时不应该重载函数</mark></li><li>尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好<br> 只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易<br> 理解。举个例子，下面是几个负责移动屏幕光标的函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Screen<span class="token operator">&amp;</span><span class="token function">moveHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen<span class="token operator">&amp;</span><span class="token function">moveAbs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen<span class="token operator">&amp;</span><span class="token function">moveRel</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>string direction<span class="token punctuation">)</span><span class="token punctuation">;</span>
乍看上去，似乎可以把这组函数统一命名为move，从而实现函数的重载：
Screen<span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen<span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen<span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>string direction<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其实不然，重载之后这些函数失去了名字中本来拥有的信息。尽管这些函数确实<br> 都是在移动光标，但是具体移动的方式却各不相同。以moveHome为例，它表示的是<br> 移动光标的一种特殊实例。一般来说，是否重载函数要看哪个更容易理解：<br> // which is easier to understand?<br><code>myScreen.moveHome(); // we think this one!</code><br><code>myScreen.move();</code></li></ul><br><ul><li><mark>const_cast和重载</mark></li><li>在4.11.3节（第145页）中我们说过，const_cast在重载函数的情景中<br> 最有用。举个例子，回忆6.3.2节（第201页）的shorterString函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// return a reference to the shorter of two strings</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个函数的参数和返回类型都是const string的引用。我们可以对两<br> 个非常量的string实参调用这个函数，但返回的结果仍然是const string的<br> 引用。因此我们需要一种新的shorterString函数，当它的实参不是常量<br> 时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在这个版本的函数中，首先将它的实参强制转换成对const的引用，<br> 然后调用了shorterString函数的const版本。const版本返回对const string的<br> 引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们<br> 可以再将其转换回一个普通的string&amp;，这显然是安全的。</li></ul><br><ul><li><p><mark>调用重载的函数</mark></p></li><li><p>定义了一组重载函数后，我们需要以合理的实参调用它们。函数匹<br> 配（function matching）是指一个过程，在这个过程中我们把函数调用<br> 与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定<br> （overload resolution）。编译器首先将调用的实参与重载集合中每一个<br> 函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。</p></li><li><p>在很多（可能是大多数）情况下，程序员很容易判断某次调用是否<br> 合法，以及当调用合法时应该调用哪个函数。通常，重载集中的函数区<br> 别明显，它们要不然是参数的数量不同，要不就是参数类型毫无关系。<br> 此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函<br> 数就比较困难了，比如当两个重载函数参数数量相同且参数类型可以相<br> 互转换时（第4.11节，141页）。我们将在6.6节（第217页）介绍当函数<br> 调用存在类型转换时编译器处理的方法。</p></li><li><p>现在我们需要掌握的是，当调用重载函数时有三种可能的结果：<br> · 编译器找到一个与实参最佳匹配（best match）的函数，并生成调<br> 用该函数的代码。<br> · 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配<br> （no match）的错误信息。<br> · 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。<br> 此时也将发生错误，称为二义性调用（ambiguous call）。</p></li></ul><h3 id="_6-4节练习" tabindex="-1"><a class="header-anchor" href="#_6-4节练习" aria-hidden="true">#</a> 6.4节练习</h3><ul><li>练习6.39：说明在下面的每组声明中第二条声明语句是何含义。如果有非法的声明，请指出来。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-4-1-重载与作用域" tabindex="-1"><a class="header-anchor" href="#_6-4-1-重载与作用域" aria-hidden="true">#</a> 6.4.1　重载与作用域</h3><ul><li><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作<br> 用域和重载的相互关系，我们将暂时违反这一原则而使用局部函数声明。</p></li><li><p>对于刚接触C++的程序员来说，不太容易理清作用域和重载的关<br> 系。其实，重载对作用域的一般性质并没有什么改变：如果我们在内层<br> 作用域中声明名字，它将隐藏外层作用域中声明的同名实体。<br><mark>在不同的作用域中无法重载函数名</mark>:</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// overloads the print function</span>
<span class="token keyword">void</span> <span class="token function">fooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> ival<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">bool</span> read <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// new scope: hides the outer declaration of read</span>
 string s <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: read is a bool variable, not a function</span>
 <span class="token comment">// bad practice: usually it&#39;s a bad idea to declare functions at local scope</span>
 <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new scope: hides previous instances of print</span>
 <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Value: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: print(const string &amp;) is hidden</span>
 <span class="token function">print</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: print(int) is visible</span>
 <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: calls print(int); print(double) is hidden</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>大多数读者都能理解调用read函数会引发错误。因为当编译器处理<br> 调用read的请求时，找到的是定义在局部作用域中的read。这个名字是<br> 个布尔变量，而我们显然无法调用一个布尔值，因此该语句非法。</p></li><li><p>调用print函数的过程非常相似。在fooBar内声明的print（int）隐藏<br> 了之前两个print函数，因此只有一个print函数是可用的：该函数以int值<br> 作为参数。</p></li><li><p>当我们调用print函数时，编译器首先寻找对该函数名的声明，找到<br> 的是接受int值的那个局部声明。<mark>一旦在当前作用域中找到了所需的名<br> 字，编译器就会忽略掉外层作用域中的同名实体</mark>。剩下的工作就是检查<br> 函数调用是否有效了.</p></li><li><p><mark>在C++语言中，名字查找发生在类型检查之前。</mark></p></li><li><p>第一个调用传入一个字符串字面值，但是当前作用域内print函数唯<br> 一的声明要求参数是int类型。字符串字面值无法转换成int类型，所以这<br> 个调用是错误的。在外层作用域中的print（const string&amp;）函数虽然与<br> 本次调用匹配，但是它已经被隐藏掉了，根本不会被考虑。</p></li><li><p>当我们为print函数传入一个double类型的值时，重复上述过程。编<br> 译器在当前作用域内发现了print（int）函数，double类型的实参转换成<br> int类型，因此调用是合法的。</p></li><li><p>假设我们把print（int）和其他print函数声明放在同一个作用域中，<br> 则它将成为另一种重载形式。此时，因为编译器能看到所有三个函数，<br> 上述调用的处理结果将完全不同：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// overloads the print function</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// another overloaded instance</span>
<span class="token keyword">void</span> <span class="token function">fooBar2</span><span class="token punctuation">(</span><span class="token keyword">int</span> ival<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Value: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(const string &amp;)</span>
 <span class="token function">print</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(int)</span>
 <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls print(double)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><mark>总的来说就是在作用域内重载可以；不同作用域内外层的直接被隐藏</mark></li></ul><h2 id="_6-5-特殊用途语言特性" tabindex="-1"><a class="header-anchor" href="#_6-5-特殊用途语言特性" aria-hidden="true">#</a> 6.5　特殊用途语言特性</h2><ul><li>本节我们介绍三种函数相关的语言特性，这些特性对大多数程序都<br> 有用，它们分别是：默认实参、内联函数和constexpr函数，以及在程序<br> 调试过程中常用的一些功能。</li></ul><h3 id="_6-5-1-默认实参" tabindex="-1"><a class="header-anchor" href="#_6-5-1-默认实参" aria-hidden="true">#</a> 6.5.1　默认实参</h3><ul><li><p>某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一<br> 个相同的值，此时，我们把这个反复出现的值称为函数的默认实参<br> （default argument）。调用含有默认实参的函数时，可以包含该实参，<br> 也可以省略该实参</p></li><li><p>例如，我们使用string对象表示窗口的内容。一般情况下，我们希<br> 望该窗口的高、宽和背景字符都使用默认值。但是同时我们也应该允许<br> 用户为这几个参数自由指定与默认值不同的数值。为了使得窗口函数既<br> 能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token keyword">typedef</span> string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">;</span> <span class="token comment">// typedef see § 2.5.1 (p. 67)</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz ht <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> sz wid <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token keyword">char</span> backgrnd <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其中我们为每一个形参都提供了默认实参，默认实参作为形参的初<br> 始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过<br> 需要注意的是，<mark>一旦某个形参被赋予了默认值，它后面的所有形参都必<br> 须有默认值</mark>.</li></ul><br><ul><li><mark>使用默认实参调用函数</mark></li><li>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可<br> 以了。例如，screen函数为它的所有形参都提供了默认实参，所以我们<br> 可以使用0、1、2或3个实参调用该函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string window<span class="token punctuation">;</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to screen(24,80,&#39; &#39;)</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// equivalent to screen(66,80,&#39; &#39;)</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// screen(66,256,&#39; &#39;)</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token char">&#39;#&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// screen(66,256,&#39;#&#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的<br> 尾部实参（靠右侧位置）。例如，要想覆盖backgrnd的默认值，必须为<br> ht和wid提供实参：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token char">&#39;?&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: can omit only trailing arguments</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token char">&#39;?&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls screen(&#39;?&#39;,80,&#39; &#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>需要注意，第二个调用传递一个字符值，是合法的调用。然而尽管<br> 如此，它的实际效果却与书写的意图不符。该调用之所以合法是因<br> 为&#39;？&#39;是个char，而函数最左侧形参的类型string：：size_type是一种无符<br> 号整数类型，所以char类型可以转换成（参见4.11节，第141页）函数最<br> 左侧形参的类型。当该调用发生时，char类型的实参隐式地转换成<br> string：：size_type，然后作为height的值传递给函数。在我们的机器<br> 上，&#39;？&#39;对应的十六进制数是0x3F，也就是十进制数的63，所以该调用<br> 把值63传给了形参height。</p></li><li><p><mark>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺<br> 序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默<br> 认值的形参出现在后面.</mark></p></li></ul><br><ul><li><mark>默认实参声明</mark></li><li>对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个<br> 函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需<br> 要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话<br> 说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，<br> 而且该形参右侧的所有形参必须都有默认值。假如给定</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// no default for the height or width parameters</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们不能修改一个已经存在的默认值：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">screen</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">=</span> <span class="token char">&#39;*&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: redeclaration</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>但是可以按照如下形式添加默认实参：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string <span class="token function">screen</span><span class="token punctuation">(</span>sz <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: adds default arguments</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><mark>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中</mark></li></ul><br><ul><li><mark>默认实参初始值</mark></li><li>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换<br> 成形参所需的类型，该表达式就能作为默认实参：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// the declarations of wd, def, and ht must appear outside a function</span>
sz wd <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> def <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
sz <span class="token function">ht</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz <span class="token operator">=</span> <span class="token function">ht</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> wd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">=</span> def<span class="token punctuation">)</span><span class="token punctuation">;</span>
string window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls screen(ht(), 80, &#39; &#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字<br> 的求值过程发生在函数调用时：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 def <span class="token operator">=</span> <span class="token char">&#39;*&#39;</span><span class="token punctuation">;</span> <span class="token comment">// changes the value of a default argument</span>
 sz wd <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// hides the outer definition of wd but does not change the default</span>
 window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls screen(ht(), 80, &#39;*&#39;)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们在函数f2内部改变了def的值，所以对screen的调用将会传递这<br> 个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于<br> 隐藏外层的wd，但是该局部变量与传递给screen的默认实参没有任何关系。</li></ul><h3 id="_6-5-1节练习" tabindex="-1"><a class="header-anchor" href="#_6-5-1节练习" aria-hidden="true">#</a> 6.5.1节练习</h3><ul><li>练习6.40：下面的哪个声明是错误的？为什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> ht <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token keyword">int</span> wd<span class="token punctuation">,</span> <span class="token keyword">char</span> bckgrnd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.41：下面的哪个调用是非法的？为什么？哪个调用虽然合法但显然与程序员的初衷不符？为什么？</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> ht<span class="token punctuation">,</span> <span class="token keyword">int</span> wd <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token keyword">char</span> bckgrnd <span class="token operator">=</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token char">&#39;*&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.42：给make_plural函数（参见6.3.2节，第201页）的第二个形参赋予默认实参&#39;s&#39;，利用新版本的函数输出单词success和failure的单数和复数形式。</li></ul><h3 id="_6-5-2-内联函数和constexpr函数" tabindex="-1"><a class="header-anchor" href="#_6-5-2-内联函数和constexpr函数" aria-hidden="true">#</a> 6.5.2　内联函数和constexpr函数</h3><ul><li><p>在6.3.2节（第201页）中我们编写了一个小函数，它的功能是比较<br> 两个string形参的长度并返回长度较小的string的引用。把这种规模较小<br> 的操作定义成函数有很多好处，主要包括：<br> · 阅读和理解shorterString函数的调用要比读懂等价的条件表达式容易得多。<br> · 使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行。<br> · 如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改更容易。<br> · 函数可以被其他应用重复利用，省去了程序员重新编写的代价。</p></li><li><p>然而，使用shorterString函数也存在一个潜在的缺点：调用函数一<br> 般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实<br> 包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需<br> 要拷贝实参；程序转向一个新的位置继续执行。</p></li></ul><br><ul><li><mark>内联函数可避免函数调用的开销</mark></li><li>将函数指定为内联函数（inline），通常就是将它在每个调用点<br> 上“内联地”展开。假设我们把shorterString函数定义成内联函数，则如下<br> 调用:</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
将在编译过程中展开成类似于下面的形式
cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>从而消除了shorterString函数的运行时开销。</p></li><li><p>在shorterString函数的返回类型前面加上关键字inline，这样就可以<br> 将它声明成内联函数了：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// inline version: find the shorter of two strings</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><mark>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</mark></li><li>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函<br> 数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可<br> 能在调用点内联地展开。</li></ul><br><ul><li><mark>constexpr函数</mark></li><li>constexpr函数（constexpr function）是指能用于常量表达式（参见<br> 2.4.4节，第58页）的函数。定义constexpr函数的方法与其他函数类似，<br> 不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值<br> 类型（参见2.4.4节，第59页），而且函数体中必须有且只有一条return<br> 语句：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: foo is a constant expression</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>我们把new_sz定义成无参数的constexpr函数。因为编译器能在程序<br> 编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初<br> 始化constexpr类型的变量foo。</p></li><li><p>执行该初始化任务时，编译器把对constexpr函数的调用替换成其结<br> 果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内<br> 联函数。</p></li><li><p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不<br> 执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名<br> （参见2.5.1节，第60页）以及using声明。</p></li><li><p>我们允许constexpr函数的返回值并非一个常量：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// scale(arg) is a constant expression if arg is a constant expression</span>
<span class="token keyword">constexpr</span> size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span> <span class="token punctuation">}</span>

当scale的实参是常量表达式时，它的返回值也是常量表达式；反之
则不然：
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok: scale(2) is a constant expression</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// i is not a constant expression</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error: scale(i) is not a constant expression</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如上例所示，当我们给scale函数传入一个形如字面值2的常量表达<br> 式时，它的返回类型也是常量表达式。此时，编译器用相应的结果值替<br> 换对scale函数的调用。</p></li><li><p>如果我们用一个非常量表达式调用scale函数，比如int类型的对象<br> i，则返回值是一个非常量表达式。当把scale函数用在需要常量表达式<br> 的上下文中时，由编译器负责检查函数的结果是否符合要求。如果结果<br> 恰好不是常量表达式，编译器将发出错误信息。</p></li><li><p><mark>constexpr函数不一定返回常量表达式。</mark></p></li><li><p><mark>把内联函数和constexpr函数放在头文件内</mark></p></li><li><p>和其他函数不一样，内联函数和constexpr函数可以在程序中多次定<br> 义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的<br> 定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多<br> 个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定<br> 义在头文件中。</p></li></ul><h3 id="_6-5-2节练习" tabindex="-1"><a class="header-anchor" href="#_6-5-2节练习" aria-hidden="true">#</a> 6.5.2节练习</h3><p>练习6.43：你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？<br> 练习6.44：将6.2.2节（第189页）的isShorter函数改写成内联函数。<br> 练习6.45：回顾在前面的练习中你编写的那些函数，它们应该是内联函数吗？如果是，将它们改写成内联函数；如果不是，说明原因。<br> 练习6.46：能把isShorter函数定义成constexpr函数吗？如果能，将它改写成constexpr函数；如果不能，说明原因。</p><h3 id="_6-5-3-调试帮助" tabindex="-1"><a class="header-anchor" href="#_6-5-3-调试帮助" aria-hidden="true">#</a> 6.5.3　调试帮助</h3><ul><li><p>C++程序员有时会用到一种类似于头文件保护（参见2.6.3节，第67<br> 页）的技术，以便有选择地执行调试代码。基本思想是，程序可以包含<br> 一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序<br> 编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理<br> 功能：assert和NDEBUG。</p></li><li><p><mark>assert预处理宏</mark></p></li><li><p>assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实<br> 是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个<br> 表达式作为它的条件：<code>assert(expr);</code></p></li><li><p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止<br> 程序的执行。如果表达式为真（即非0），assert什么也不做。</p></li><li><p>assert宏定义在cassert头文件中。如我们所知，预处理名字由预处理<br> 器而非编译器管理（参见2.3.2节，第49页），因此我们可以直接使用预<br> 处理名字而无须提供using声明。也就是说，我们应该使用assert而不是<br> std：：assert，也不需要为assert提供using声明。</p></li><li><p>和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件<br> 的程序不能再定义名为assert的变量、函数或者其他实体。在实际编程<br> 过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使<br> 用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含<br> cassert，它也很有可能通过其他途径包含在你的程序中。</p></li><li><p>assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行<br> 操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序<br> 可以包含一条如下所示的语句：<br><code>assert(word.size() &gt; threshold);</code></p></li></ul><br><ul><li><p><mark>NDEBUG预处理变量</mark></p></li><li><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果<br> 定义了NDEBUG，则assert什么也不做。默认状态下没有定义<br> NDEBUG，此时assert将执行运行时检查。</p></li><li><p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。<br> 同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：<br><code>$ CC -D NDEBUG main.C # use /D with the Microsoft compiler</code></p></li><li><p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p></li><li><p>定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根<br> 本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可<br> 能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是<br> 不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的<br> 错误检查。</p></li><li><p>除了用于assert外，也可以使用NDEBUG编写自己的条件调试代<br> 码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定<br> 义了NDEBUG，这些代码将被忽略掉：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NDEBUG</span></span>
<span class="token comment">// _ _func_ _ is a local static defined by the compiler that holds the function&#39;s name</span>
cerr <span class="token operator">&lt;&lt;</span> _ _func_ _ <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;: array size is &quot;</span> <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在这段代码中，我们使用变量_ <em>func</em> <em>输出当前调试的函数的名<br> 字。编译器为每个函数都定义了</em> <em>func</em> _，它是const char的一个静态<br> 数组，用于存放函数的名字。</p></li><li><p>除了C++编译器定义的_ <em>func</em> _之外，预处理器还定义了另外4个<br> 对于程序调试很有用的名字：</p></li></ul><p>_ <em>FILE</em> _ 存放文件名的字符串字面值。<br> _ <em>LINE</em> _ 存放当前行号的整型字面值。<br> _ <em>TIME</em> _ 存放文件编译时间的字符串字面值。<br> _ <em>DATE</em> _ 存放文件编译日期的字符串字面值。</p><ul><li>可以使用这些常量在错误消息中提供更多信息：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> threshold<span class="token punctuation">)</span>
 cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Error: &quot;</span> <span class="token operator">&lt;&lt;</span> _ _FILE_ _
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; : in function &quot;</span> <span class="token operator">&lt;&lt;</span> _ _func_ _
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; at line &quot;</span> <span class="token operator">&lt;&lt;</span> _ _LINE_ _ <span class="token operator">&lt;&lt;</span> endl
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; Compiled on &quot;</span> <span class="token operator">&lt;&lt;</span> _ _DATE_ _
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; at &quot;</span> <span class="token operator">&lt;&lt;</span> _ _TIME_ _ <span class="token operator">&lt;&lt;</span> endl
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; Word read was \\&quot;&quot;</span> <span class="token operator">&lt;&lt;</span> word
 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\\&quot;: Length too short&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果我们给程序提供了一个长度小于threshold的string对象，将得到<br> 下面的错误消息：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Error<span class="token operator">:</span> wdebug<span class="token punctuation">.</span>cc <span class="token operator">:</span> in function main at line <span class="token number">27</span>
 Compiled on Jul <span class="token number">11</span> <span class="token number">2012</span> at <span class="token number">20</span><span class="token operator">:</span><span class="token number">50</span><span class="token operator">:</span><span class="token number">03</span>
 Word read was <span class="token string">&quot;foo&quot;</span><span class="token operator">:</span> Length too <span class="token keyword">short</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-5-3节练习" tabindex="-1"><a class="header-anchor" href="#_6-5-3节练习" aria-hidden="true">#</a> 6.5.3节练习</h3><ul><li><p>练习6.47：改写6.3.2节（第205页）练习中使用递归输出vector内容的程<br> 序，使其有条件地输出与执行过程有关的信息。例如，每次调用时输出<br> vector对象的大小。分别在打开和关闭调试器的情况下编译并执行这个程序。</p></li><li><p>练习6.48：说明下面这个循环的含义，它对assert的使用合理吗？</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string s<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> s <span class="token operator">&amp;&amp;</span> s <span class="token operator">!=</span> sought<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//空函数体</span>
<span class="token function">assert</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-6-函数匹配" tabindex="-1"><a class="header-anchor" href="#_6-6-函数匹配" aria-hidden="true">#</a> 6.6 函数匹配</h2><ul><li><p>在大多数情况下，我们容易确定某次调用应该选用哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，这项工作就不那么容易了。以下面这组函数及其调用为例：</p></li><li><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6); //调用 void f(double, double) 函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><br><ul><li><p><mark>确定候选函数和可行函数</mark></p></li><li><p>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。在这个例子中，有4个名为f的候选函数。</p></li><li><p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p></li><li><p>我们能根据实参的数量从候选函数中排除掉两个。不使用形参的函数和使用两个int形参的函数显然都不适合本次调用，这是因为我们的调用只提供了一个实参，而它们分别有0个和两个形参。</p></li><li><p>使用一个int形参的函数和使用两个double形参的函数是可行的，它们都能用一个实参调用。其中最后那个函数本应该接受两个double值，但是因为它含有一个默认实参，所以只用一个实参也能调用它。(如果函数含有默认实参（参见6.5.1节，第211页），则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量)</p></li><li><p>在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。在上面的例子中，剩下的两个函数都是可行的：</p><ul><li>f（int）是可行的，因为实参类型double能转换成形参类型int。</li><li>f（double，double）是可行的，因为它的第二个形参提供了默认值，而第一个形参的类型正好是double，与函数使用的实参类型完全一致。</li></ul></li><li><p><mark>如果没找到可行函数，编译器将报告无匹配函数的错误。</mark></p></li></ul><br><ul><li><mark>寻找最佳匹配（如果有的话）</mark></li><li>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。下一节将介绍“最匹配”的细节，它的基本思想是，实参类型与形参类型越接近，它们匹配得越好。</li><li>在我们的例子中，调用只提供了一个（显式的）实参，它的类型是double。如果调用f（int），实参将不得不从double转换成int。另一个可行函数f（double，double）则与实参精确匹配。精确匹配比需要类型转换的匹配更好，因此，编译器把f（5.6）解析成对含有两个double形参的函数的调用，并使用默认值填补我们未提供的第二个实参。</li></ul><br><ul><li><mark>含有多个形参的函数匹配</mark></li><li>当实参的数量有两个或更多时，函数匹配就比较复杂了。对于前面那些名为f的函数，我们来分析如下的调用会发生什么情况：</li><li>(42, 2.56);</li><li>选择可行函数的方法和只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。此例中，可行函数包括f（int，int）和f（double，double）。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功： <ul><li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li></ul></li><li>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</li><li>在上面的调用中，只考虑第一个实参时我们发现函数f（int，int）能精确匹配；要想匹配第二个函数，int类型的实参必须转换成double类型。显然需要内置类型转换的匹配劣于精确匹配，因此仅就第一个实参来说，f（int，int）比f（double，double）更好。</li><li>接着考虑第二个实参2.56，此时f（double，double）是精确匹配；要想调用f（int，int）必须将2.56从double类型转换成int类型。因此仅就第二个实参来说，f（double，double）更好。</li><li>编译器最终将因为这个调用具有二义性而拒绝其请求：因为每个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。看起来我们似乎可以通过强制类型转换（参见4.11.3节，第144页）其中的一个实参来实现函数的匹配，但是在设计良好的系统中，不应该对实参进行强制类型转换。</li><li><mark>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。</mark></li></ul><br><h3 id="_6-6节练习题" tabindex="-1"><a class="header-anchor" href="#_6-6节练习题" aria-hidden="true">#</a> 6.6节练习题</h3><ul><li><mark>练习<strong>6.49</strong>：什么是候选函数？什么是可行函数？</mark></li><li>候选函数：与被调用函数同名，并且其声明在调用点可见。</li><li>可行函数：形参与实参的数量相等，并且每个实参类型与对应的形参类型相同或者能转换成形参的类型。</li></ul><br><ul><li><mark>练习<strong>6.50</strong>：已知有第217页对函数f的声明，对于下面的每一个调用列出可行函数。其中哪个函数是最佳匹配？如果调用不合法，是因为没有可匹配的函数还是因为调用具有二义性？</mark></li><li>对于(a) f(2.56, 42) 的调用的可行函数为 void f(int, int) 和 void f(double, double = 3.14);该调用具有二义性而不合法。</li><li>对于(b) f(42) 的调用的可行函数为 void f(int); 调用合法。</li><li>对于(c) f(42, 0) 的调用的可行函数 为 <code>void f(int, int);</code>和<code>void f(double, double = 3.14);</code>。void f(int, int) 是最佳匹配</li><li>对于(d) f(2.56, 3.14) 的调用的可行函数<code>void f(int, int);</code>和<code>void f(double, double = 3.14);</code>。<code>void f(double, double = 3.14);</code>是最佳匹配</li></ul><br><ul><li>练习<strong>6.51</strong>：编写函数f的4个版本，令其各输出一条可以区分的消息。验证上一个练习的答案，如果你回答错了，反复研究本节的内容直到你弄清自己错在何处。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
  <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;f()&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;f(int)&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;f(int, int)&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;f(double, double)&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token comment">//f(2.56, 42); // error: &#39;f&#39; is ambiguous.</span>
      <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2.56</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-6-1-实参类型转换" tabindex="-1"><a class="header-anchor" href="#_6-6-1-实参类型转换" aria-hidden="true">#</a> 6.6.1　实参类型转换</h3><ul><li>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：</li><li>1-精确匹配，包括以下情况： <ul><li>实参类型和形参类型相同。</li><li>实参从数组类型或函数类型转换成对应的指针类型（参见6.7节，第221页，将介绍函数指针）。</li><li>向实参添加顶层const或者从实参中删除顶层const。</li></ul></li><li>2-通过const转换实现的匹配（参见4.11.2节，第143页）。</li><li>3-通过类型提升实现的匹配（参见4.11.1节，第142页）。</li><li>4-通过算术类型转换（参见4.11.1节，第142页）或指针转换（参见4.11.2节，第143页）实现的匹配。</li><li>5-通过类类型转换实现的匹配（参见14.9节，第514页，将详细介绍这种转换）。</li></ul><br><ul><li><p><mark>需要类型提升和算术类型转换的匹配</mark></p></li><li><p>内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在<br> 设计良好的系统中函数很少会含有与下面例子类似的形参。</p></li><li><p>分析函数调用前，我们应该知道小整型一般都会提升到int类型或更<br> 大的整数类型。假设有两个函数，一个接受int、另一个接受short，则只<br> 有当调用提供的是short类型的值时才会选择short版本的函数。有时候，<br> 即使实参是一个很小的整数值，也会直接将它提升成int类型；此时使用<br> short版本反而会导致类型转换：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ff</span><span class="token punctuation">(</span><span class="token char">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//char 提升为int；调用f(int);</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有算术类型转换的级别都一样。例如，从int向unsigned int的转换<br> 并不比从int向double的转换级别高。举个具体点的例子，考虑</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">manip</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: ambiguous call</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>字面值3.14的类型是double，它既能转换成long也能转换成float。因<br> 为存在两种可能的算数类型转换，所以该调用具有二义性。</li></ul><br><ul><li><mark>函数匹配和const实参</mark></li><li>如果重载函数的区别在于它们的引用类型的形参是否引用了const，<br> 或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是<br> 否是常量来决定选择哪个函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Record <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function that takes a reference to</span>
Account
Record <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new function that takes a const reference</span>
<span class="token keyword">const</span> Account a<span class="token punctuation">;</span>
Account b<span class="token punctuation">;</span>
<span class="token function">lookup</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls lookup(const Account&amp;)</span>
<span class="token function">lookup</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls lookup(Account&amp;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在第一个调用中，我们传入的是const对象a。因为不能把普通引用<br> 绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参<br> 的那个函数，并且调用该函数与实参a精确匹配。</p></li><li><p>在第二个调用中，我们传入的是非常量对象b。对于这个调用来<br> 说，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可<br> 以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类<br> 型转换，接受非常量形参的版本则与b精确匹配。因此，应该选用非常<br> 量版本的函数。</p></li><li><p>指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参<br> 指向常量或非常量，则编译器能通过实参是否是常量决定选用哪个函<br> 数：如果实参是指向常量的指针，调用形参是const＊的函数；如果实参<br> 是指向非常量的指针，调用形参是普通指针的函数。</p></li></ul><h3 id="_6-6-1节练习" tabindex="-1"><a class="header-anchor" href="#_6-6-1节练习" aria-hidden="true">#</a> 6.6.1节练习</h3><ul><li>练习6.52：已知有如下声明，请指出下列调用中每个类型转换的等级（参见6.6.1节，第219页）。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> dobj<span class="token punctuation">;</span>

<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token char">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token number">55.4</span><span class="token punctuation">,</span> dobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>练习6.53：说明下列每组声明中的第二条语句会产生什么影响，并指出哪些不合法（如果有的话）</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-7-函数指针" tabindex="-1"><a class="header-anchor" href="#_6-7-函数指针" aria-hidden="true">#</a> 6.7　函数指针</h2><ul><li>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向<br> 某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函<br> 数名无关。例如：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// compares lengths of two strings</span>
<span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>该函数的类型是bool（const string&amp;，const string&amp;）。要想声明一<br> 个可以指向该函数的指针，只需要用指针替换函数名即可：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// pf points to a function returning bool that takes two const string references</span>
<span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// uninitialized</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧<br> 是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型<br> 是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两<br> 个const string的引用，返回值是bool类型。</p></li><li><p><mark>Note</mark></p></li><li><p>＊pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// declares a function named pf that returns a bool*</span>
<span class="token keyword">bool</span> <span class="token operator">*</span><span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>使用函数指针</mark></li><li>当我们把函数名作为一个值使用时，该函数自动地转换成指针。例<br> 如，按照如下形式我们可以将lengthCompare的地址赋给pf：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span> <span class="token comment">// pf now points to the function named lengthCompare</span>
pf <span class="token operator">=</span> <span class="token operator">&amp;</span>lengthCompare<span class="token punctuation">;</span> <span class="token comment">// equivalent assignment: address-of operator is optional</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>此外，我们还能直接使用指向函数的指针调用该函数，无须提前解<br> 引用指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls lengthCompare</span>
<span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent call</span>
<span class="token keyword">bool</span> b3 <span class="token operator">=</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;goodbye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent call</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在指向不同函数类型的指针间不存在转换规则。但是和往常一样，<br> 我们可以为函数指针赋一个nullptr（参见2.3.2节，第48页）或者值为0的<br> 整型常量表达式，表示该指针没有指向任何一个函数：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string<span class="token double-colon punctuation">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">cstringCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ok: pf points to no function</span>
pf <span class="token operator">=</span> sumLength<span class="token punctuation">;</span> <span class="token comment">// error: return type differs</span>
pf <span class="token operator">=</span> cstringCompare<span class="token punctuation">;</span> <span class="token comment">// error: parameter types differ</span>
pf <span class="token operator">=</span> lengthCompare<span class="token punctuation">;</span> <span class="token comment">// ok: function and pointer types match exactly</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>重载函数的指针</mark></li><li>当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个<br> 函数。如果定义了指向重载函数的指针</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> ff<span class="token punctuation">;</span> <span class="token comment">// pf1 points to ff(unsigned)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数<br> 中的某一个精确匹配</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> ff<span class="token punctuation">;</span> <span class="token comment">// error: no ff with a matching parameter list</span>
<span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> ff<span class="token punctuation">;</span> <span class="token comment">// error: return type of ff and pf3 don&#39;t match</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><mark>函数指针形参</mark></li><li>和数组类似（参见6.2.4节，第193页），虽然不能定义函数类型的<br> 形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类<br> 型，实际上却是当成指针使用：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// third parameter is a function type and is automatically treated as a pointer to function</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span>
 <span class="token keyword">bool</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">,</span>
 <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们可以直接把函数作为实参使用，此时它会自动转换成指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// automatically converts the function lengthCompare to a pointer to function</span>
<span class="token function">useBigger</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> lengthCompare<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>正如useBigger的声明语句所示，直接使用函数指针类型显得冗长而<br> 烦琐。类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第<br> 62页）能让我们简化使用了函数指针的代码：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// Func and Func2 have function type</span>
<span class="token keyword">typedef</span> <span class="token keyword">bool</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> Func2<span class="token punctuation">;</span> <span class="token comment">// equivalent type</span>
<span class="token comment">// FuncP and FuncP2 have pointer to function type</span>
<span class="token keyword">typedef</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span>FuncP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>lengthCompare<span class="token punctuation">)</span> <span class="token operator">*</span>FuncP2<span class="token punctuation">;</span> <span class="token comment">// equivalent type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们使用typedef定义自己的类型。Func和Func2是函数类型，而<br> FuncP和FuncP2是指针类型。需要注意的是，decltype返回函数类型，此<br> 时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类<br> 型，所以只有在结果前面加上＊才能得到指针。可以使用如下的形式重<br> 新声明useBigger：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// equivalent declarations of useBigger using type aliases</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> Func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">useBigger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> FuncP2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这两个声明语句声明的是同一个函数，在第一条语句中，编译器自<br> 动地将Func表示的函数类型转换成指针。</li></ul><br><ul><li><mark>返回指向函数的指针</mark></li><li>和数组类似（参见6.3.3节，第205页），虽然不能返回一个函数，<br> 但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针<br> 形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与<br> 往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类<br> 型别名：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">using</span> F <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// F is a function type, not a pointer</span>
<span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// PF is a pointer type</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>其中我们使用类型别名（参见2.5.1节，第60页）将F定义成函数类<br> 型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型<br> 的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返<br> 回类型指定为指针：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>PF <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: PF is a pointer to function; f1 returns a pointer to function</span>
F <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: F is a function type; f1 can&#39;t return a function</span>
F <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok: explicitly specify that the return type is a pointer to function</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当然，我们也能用下面的形式直接声明f1：<br><code>int (*f1(int))(int*, int);</code></p></li><li><p>按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，<br> 所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，<br> 指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类<br> 型是int。</p></li><li><p>出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型<br> 的方式（参见6.3.3节，第206页）声明一个返回函数指针的函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><ul><li><mark>将auto和decltype用于函数指针类型</mark></li><li>如果我们明确知道返回的函数是哪一个，就能使用decltype简化书<br> 写函数指针返回类型的过程。例如假定有两个函数，它们的返回类型都<br> 是string：：size_type，并且各有两个const string&amp;类型的形参，此时我<br> 们可以编写第三个函数，它接受一个string类型的参数，返回一个指<br> 针，该指针指向前两个函数中的一个：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>string<span class="token double-colon punctuation">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string<span class="token double-colon punctuation">::</span>size_type <span class="token function">largerLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// depending on the value of its string parameter,</span>
<span class="token comment">// getFcn returns a pointer to sumLength or to largerLength</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>sumLength<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某<br> 个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以<br> 表明我们需要返回指针，而非函数本身。</li></ul><h3 id="_6-7节练习" tabindex="-1"><a class="header-anchor" href="#_6-7节练习" aria-hidden="true">#</a> 6.7节练习</h3><p>练习6.54：编写函数的声明，令其接受两个int形参并且返回类型也是<br> int；然后声明一个vector对象，令其元素是指向该函数的指针。<br> 练习6.55：编写4个函数，分别对两个int值执行加、减、乘、除运算；<br> 在上一题创建的vector对象中保存指向这些函数的指针。<br> 练习6.56：调用上述vector对象中的每个元素并输出其结果。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><ul><li><p>函数是命名了的计算单元，它对程序（哪怕是不大的程序）的结构<br> 化至关重要。每个函数都包含返回类型、名字、（可能为空的）形参列<br> 表以及函数体。函数体是一个块，当函数被调用的时候执行该块的内<br> 容。此时，传递给函数的实参类型必须与对应的形参类型相容。</p></li><li><p>在C++语言中，函数可以被重载：同一个名字可用于定义多个函<br> 数，只要这些函数的形参数量或形参类型不同就行。根据调用时所使用<br> 的实参，编译器可以自动地选定被调用的函数。从一组重载函数中选取<br> 最佳函数的过程称为函数匹配。</p></li></ul><h2 id="术语表" tabindex="-1"><a class="header-anchor" href="#术语表" aria-hidden="true">#</a> 术语表</h2><ul><li><p>二义性调用（ambiguous call） 是一种编译时发生的错误，造成二<br> 义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编<br> 译器找不到唯一的最佳匹配。</p></li><li><p>实参（argument） 函数调用时提供的值，用于初始化函数的形参。</p></li><li><p>Assert 是一个预处理宏，作用于一条表示条件的表达式。当未定义<br> 预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条<br> 错误信息并终止当前程序的执行。</p></li><li><p>自动对象（automatic object） 仅存在于函数执行过程中的对象。<br> 当程序的控制流经过此类对象的定义语句时，创建该对象；当到达了定<br> 义所在的块的末尾时，销毁该对象。</p></li><li><p>最佳匹配（best match） 从一组重载函数中为调用选出的一个函<br> 数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少<br> 在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差。</p></li><li><p>传引用调用（call by reference） 参见引用传递。</p></li><li><p>传值调用（call by value） 参见值传递。</p></li><li><p>候选函数（candidate function） 解析某次函数调用时考虑的一组<br> 函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点<br> 候选函数的声明在作用域之内。</p></li><li><p>constexpr 可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数。</p></li><li><p>默认实参（default argument） 当调用缺少了某个实参时，为该实参指定的默认值。</p></li><li><p>可执行文件（executable file） 是操作系统能够执行的文件，包含着与程序有关的代码</p></li><li><p>函数（function）可调用的计算单元。</p></li><li><p>函数体（function body） 是一个块，用于定义函数所执行的操作。</p></li><li><p>函数匹配（function matching） 编译器解析重载函数调用的过程，<br> 在此过程中，实参与每个重载函数的形参列表逐一比较。</p></li><li><p>函数原型（function prototype） 函数的声明，包含函数名字、返<br> 回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型。</p></li><li><p>隐藏名字（hidden name） 某个作用域内声明的名字会隐藏掉外层<br> 作用域中声明的同名实体。</p></li><li><p>initializer_list 是一个标准类，表示的是一组花括号包围的类型相同<br> 的对象，对象之间以逗号隔开。</p></li><li><p>内联函数（inline function） 请求编译器在可能的情况下在调用点<br> 展开函数。内联函数可以避免常见的函数调用开销。</p></li><li><p>链接（link）是一个编译过程，负责把若干对象文件链接起来形成可执行程序。</p></li><li><p>局部静态对象（local static object） 它的值在函数调用结束后仍然<br> 存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局<br> 部静态对象才被销毁。</p></li><li><p>局部变量（local variable） 定义在块中的变量。</p></li><li><p>无匹配（no match）是一种编译时发生的错误，原因是在函数匹配<br> 过程中所有函数的形参都不能与调用提供的实参匹配。</p></li><li><p>对象代码（object code） 编译器将我们的源代码转换成对象代码格式。</p></li><li><p>对象文件（object file）编译器根据给定的源文件生成的保存对象<br> 代码的文件。一个或多个对象文件经过链接生成可执行文件。</p></li><li><p>对象生命周期（object lifetime） 每个对象都有相应的生命周期。<br> 块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末<br> 尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定<br> 义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象。</p></li><li><p>重载确定（overload resolution） 参见函数匹配。</p></li><li><p>重载函数（overloaded function） 函数名与其他函数相同的函数。<br> 多个重载函数必须在形参数量或形参类型上有所区别。</p></li><li><p>形参（parameter） 在函数的形参列表中声明的局部变量。用实参<br> 初始化形参。</p></li><li><p>引用传递（pass by reference） 描述如何将实参传递给引用类型的<br> 形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的<br> 实参上。</p></li><li><p>值传递（pass by value） 描述如何将实参传递给非引用类型的形<br> 参。非引用类型的形参实际上是相应实参值的一个副本。</p></li><li><p>预处理宏（preprocessor macro）类似于内联函数的一种预处理功<br> 能。除了assert之外，现代C++程序很少再使用预处理宏了。</p></li><li><p>递归循环（recursion loop）描述某个递归函数没有终止条件，因<br> 而不断调用自身直至耗尽程序栈空间的过程。</p></li><li><p>递归函数（recursive function） 直接或间接调用自身的函数。</p></li><li><p>返回类型（return type）是函数声明的一部分，用于指定函数返回值的类型。</p></li><li><p>分离式编译（separate compilation） 把一个程序分割成多个独立源文件的能力。</p></li><li><p>尾置返回类型（trailing return type） 在参数列表后面指定的返回类型。</p></li><li><p>可行函数（viable function）是候选函数的子集。可行函数能匹配<br> 本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类<br> 型都能转换成相应的形参类型。</p></li><li><p>（）运算符（（） operator） 调用运算符，用于执行某函数。括<br> 号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为<br> 空）。</p></li></ul>`,352);function _(x,q){const p=o("router-link"),c=o("ExternalLinkIcon");return i(),u("div",null,[d,m,r(" more "),b,n("nav",v,[n("ul",null,[n("li",null,[a(p,{to:"#第6章-函数-完毕"},{default:t(()=>[s("第6章　函数[完毕]")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-函数基础"},{default:t(()=>[s("6.1　函数基础")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-1节练习"},{default:t(()=>[s("6.1节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-1-局部对象"},{default:t(()=>[s("6.1.1　局部对象")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-1节练习"},{default:t(()=>[s("6.1.1节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-2-函数声明"},{default:t(()=>[s("6.1.2　函数声明")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-2节练习"},{default:t(()=>[s("6.1.2节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-3-分离式编译-需要去了解编译的细节"},{default:t(()=>[s("6.1.3　分离式编译(需要去了解编译的细节)")]),_:1})]),n("li",null,[a(p,{to:"#_6-1-3节练习"},{default:t(()=>[s("6.1.3节练习")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-2-参数传递"},{default:t(()=>[s("6.2 参数传递")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-2-1-传值参数"},{default:t(()=>[s("6.2.1　传值参数")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-1节练习"},{default:t(()=>[s("6.2.1节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-2-传引用参数"},{default:t(()=>[s("6.2.2　传引用参数")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-2节练习"},{default:t(()=>[s("6.2.2节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-3-const形参和实参"},{default:t(()=>[s("6.2.3 const形参和实参")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-3节练习"},{default:t(()=>[s("6.2.3节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-4-数组形参"},{default:t(()=>[s("6.2.4　数组形参")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-4节练习"},{default:t(()=>[s("6.2.4节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-5-main-处理命令行选项"},{default:t(()=>[s("6.2.5 main：处理命令行选项")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-5节练习"},{default:t(()=>[s("6.2.5节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-2-6-含有可变形参的函数-先不进行整"},{default:t(()=>[s("6.2.6　含有可变形参的函数(先不进行整)")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-3-返回类型和return语句"},{default:t(()=>[s("6.3　返回类型和return语句")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-3-1-无返回值函数"},{default:t(()=>[s("6.3.1　无返回值函数")]),_:1})]),n("li",null,[a(p,{to:"#_6-3-2-有返回值函数"},{default:t(()=>[s("6.3.2　有返回值函数")]),_:1})]),n("li",null,[a(p,{to:"#_6-3-2节练习"},{default:t(()=>[s("6.3.2节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-3-3-返回数组指针-繁琐的"},{default:t(()=>[s("6.3.3　返回数组指针(繁琐的)")]),_:1})]),n("li",null,[a(p,{to:"#_6-3-3节练习"},{default:t(()=>[s("6.3.3节练习")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-4-函数重载"},{default:t(()=>[s("6.4　函数重载")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-4节练习"},{default:t(()=>[s("6.4节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-4-1-重载与作用域"},{default:t(()=>[s("6.4.1　重载与作用域")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-5-特殊用途语言特性"},{default:t(()=>[s("6.5　特殊用途语言特性")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-5-1-默认实参"},{default:t(()=>[s("6.5.1　默认实参")]),_:1})]),n("li",null,[a(p,{to:"#_6-5-1节练习"},{default:t(()=>[s("6.5.1节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-5-2-内联函数和constexpr函数"},{default:t(()=>[s("6.5.2　内联函数和constexpr函数")]),_:1})]),n("li",null,[a(p,{to:"#_6-5-2节练习"},{default:t(()=>[s("6.5.2节练习")]),_:1})]),n("li",null,[a(p,{to:"#_6-5-3-调试帮助"},{default:t(()=>[s("6.5.3　调试帮助")]),_:1})]),n("li",null,[a(p,{to:"#_6-5-3节练习"},{default:t(()=>[s("6.5.3节练习")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-6-函数匹配"},{default:t(()=>[s("6.6 函数匹配")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-6节练习题"},{default:t(()=>[s("6.6节练习题")]),_:1})]),n("li",null,[a(p,{to:"#_6-6-1-实参类型转换"},{default:t(()=>[s("6.6.1　实参类型转换")]),_:1})]),n("li",null,[a(p,{to:"#_6-6-1节练习"},{default:t(()=>[s("6.6.1节练习")]),_:1})])])]),n("li",null,[a(p,{to:"#_6-7-函数指针"},{default:t(()=>[s("6.7　函数指针")]),_:1}),n("ul",null,[n("li",null,[a(p,{to:"#_6-7节练习"},{default:t(()=>[s("6.7节练习")]),_:1})])])]),n("li",null,[a(p,{to:"#小结"},{default:t(()=>[s("小结")]),_:1})]),n("li",null,[a(p,{to:"#术语表"},{default:t(()=>[s("术语表")]),_:1})])])]),g,n("p",null,[s("练习6.9："),n("a",f,[s("编写你自己的fact.cc和factMain.cc"),a(c)]),s("，这两个文件都应该包含上"),h,s(" 一小节的练习中编写的Chapter6.h头文件。通过这些文件，理解你的编"),y,s(" 译器是如何支持分离式编译的。")]),w])}const j=l(k,[["render",_],["__file","H-第六章函数.html.vue"]]);export{j as default};
