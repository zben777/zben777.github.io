const l=JSON.parse('{"key":"v-5105cb7d","path":"/article/CUDA/B-CUDAc-Programming/E-%E7%AC%AC%E4%BA%94%E7%AB%A0.html","title":"E-第五章","lang":"zh-CN","frontmatter":{"date":"2024-07-01T00:00:00.000Z","category":["C++","CUDA开启的GPU编程"],"tag":["C++","CUDA开启的GPU编程"],"seo":false,"head":[]},"headers":[{"level":2,"title":"简单介绍主要是基础","slug":"简单介绍主要是基础","link":"#简单介绍主要是基础","children":[]},{"level":2,"title":"第5章 共享内存和常量内存","slug":"第5章-共享内存和常量内存","link":"#第5章-共享内存和常量内存","children":[]},{"level":2,"title":"5.1 CUDA共享内存概述","slug":"_5-1-cuda共享内存概述","link":"#_5-1-cuda共享内存概述","children":[{"level":3,"title":"5.1.1 共享内存","slug":"_5-1-1-共享内存","link":"#_5-1-1-共享内存","children":[]},{"level":3,"title":"5.1.2 共享内存分配","slug":"_5-1-2-共享内存分配","link":"#_5-1-2-共享内存分配","children":[]},{"level":3,"title":"5.1.3 共享内存存储体和访问模式","slug":"_5-1-3-共享内存存储体和访问模式","link":"#_5-1-3-共享内存存储体和访问模式","children":[]},{"level":3,"title":"5.1.4 配置共享内存量","slug":"_5-1-4-配置共享内存量","link":"#_5-1-4-配置共享内存量","children":[]},{"level":3,"title":"5.1.5 同步","slug":"_5-1-5-同步","link":"#_5-1-5-同步","children":[]}]},{"level":2,"title":"5.2 共享内存的数据布局","slug":"_5-2-共享内存的数据布局","link":"#_5-2-共享内存的数据布局","children":[{"level":3,"title":"5.2.1 方形共享内存","slug":"_5-2-1-方形共享内存","link":"#_5-2-1-方形共享内存","children":[]},{"level":3,"title":"5.2.2 矩形共享内存","slug":"_5-2-2-矩形共享内存","link":"#_5-2-2-矩形共享内存","children":[]}]},{"level":2,"title":"5.3 减少全局内存访问","slug":"_5-3-减少全局内存访问","link":"#_5-3-减少全局内存访问","children":[{"level":3,"title":"5.3.1 使用共享内存的并行归约","slug":"_5-3-1-使用共享内存的并行归约","link":"#_5-3-1-使用共享内存的并行归约","children":[]},{"level":3,"title":"5.3.2 使用展开的并行归约","slug":"_5-3-2-使用展开的并行归约","link":"#_5-3-2-使用展开的并行归约","children":[]},{"level":3,"title":"5.3.3 使用动态共享内存的并行归约","slug":"_5-3-3-使用动态共享内存的并行归约","link":"#_5-3-3-使用动态共享内存的并行归约","children":[]},{"level":3,"title":"5.3.4 有效带宽","slug":"_5-3-4-有效带宽","link":"#_5-3-4-有效带宽","children":[]}]},{"level":2,"title":"5.4 合并的全局内存访问","slug":"_5-4-合并的全局内存访问","link":"#_5-4-合并的全局内存访问","children":[{"level":3,"title":"5.4.1 基准转置内核","slug":"_5-4-1-基准转置内核","link":"#_5-4-1-基准转置内核","children":[]},{"level":3,"title":"5.4.2 使用共享内存的矩阵转置","slug":"_5-4-2-使用共享内存的矩阵转置","link":"#_5-4-2-使用共享内存的矩阵转置","children":[]},{"level":3,"title":"5.4.3 使用填充共享内存的矩阵转置","slug":"_5-4-3-使用填充共享内存的矩阵转置","link":"#_5-4-3-使用填充共享内存的矩阵转置","children":[]},{"level":3,"title":"5.4.4 使用展开的矩阵转置","slug":"_5-4-4-使用展开的矩阵转置","link":"#_5-4-4-使用展开的矩阵转置","children":[]},{"level":3,"title":"5.4.5 增大并行性","slug":"_5-4-5-增大并行性","link":"#_5-4-5-增大并行性","children":[]}]},{"level":2,"title":"5.5 常量内存","slug":"_5-5-常量内存","link":"#_5-5-常量内存","children":[{"level":3,"title":"5.5.1 使用常量内存实现一维模板","slug":"_5-5-1-使用常量内存实现一维模板","link":"#_5-5-1-使用常量内存实现一维模板","children":[]},{"level":3,"title":"5.5.2 与只读缓存的比较","slug":"_5-5-2-与只读缓存的比较","link":"#_5-5-2-与只读缓存的比较","children":[]}]},{"level":2,"title":"5.6 线程束洗牌指令","slug":"_5-6-线程束洗牌指令","link":"#_5-6-线程束洗牌指令","children":[{"level":3,"title":"5.6.1 线程束洗牌指令的不同形式","slug":"_5-6-1-线程束洗牌指令的不同形式","link":"#_5-6-1-线程束洗牌指令的不同形式","children":[]},{"level":3,"title":"5.6.2 线程束内的共享数据","slug":"_5-6-2-线程束内的共享数据","link":"#_5-6-2-线程束内的共享数据","children":[]},{"level":3,"title":"5.6.3 使用线程束洗牌指令的并行归约","slug":"_5-6-3-使用线程束洗牌指令的并行归约","link":"#_5-6-3-使用线程束洗牌指令的并行归约","children":[]}]},{"level":2,"title":"5.7 总结","slug":"_5-7-总结","link":"#_5-7-总结","children":[]},{"level":2,"title":"5.8 习题","slug":"_5-8-习题","link":"#_5-8-习题","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":95.6,"words":28680},"filePathRelative":"article/CUDA/B-CUDAc-Programming/E-第五章.md","localizedDate":"2024年7月1日"}');export{l as data};
