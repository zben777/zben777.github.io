import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as n,c,d as m,a as l,e,w as o,b as i,f as p}from"./app-2a2d189a.js";const u={},h=l("h1",{id:"b-从cmake学起",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#b-从cmake学起","aria-hidden":"true"},"#"),i(" B-从Cmake学起")],-1),k=l("p",null,"B-从Cmake学起",-1),s=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("ul",null,[l("li",null,"主要是各种搜索找的学习；")])],-1),d={class:"table-of-contents"},_=p('<h2 id="简单介绍主要是基础" tabindex="-1"><a class="header-anchor" href="#简单介绍主要是基础" aria-hidden="true">#</a> 简单介绍主要是基础</h2><h2 id="一、什么是编译器" tabindex="-1"><a class="header-anchor" href="#一、什么是编译器" aria-hidden="true">#</a> 一、什么是编译器？</h2><ul><li><p>编译器，是一个根据<strong>源代码</strong>生成<strong>机器码</strong>的程序。<br><br></p></li><li><p><mark>什么是CMake？</mark></p></li><li><p>涉及到Cmake，Cmake就是用来编译一个程序的。<br><br></p></li><li><p><mark>Cmake要做什么呢？</mark></p></li><li><p>Cmake就是要把一个 源文件.cpp文件 编译成一个 可执行文件 .out</p></li></ul><br><ul><li><mark>编译器的种类</mark></li><li>1-Linux的厂商的GNU系统：gcc(C) g++(C++) gfortran(Forgtran)</li><li>2-LLVM: clang(C) clang++(C++) flang(Forgtran)</li><li>3-微软的MSVC系列</li><li>对应使用命令行，然后链接库使用对应命令，链接对应的库。g++ main.cpp -o a.out</li></ul><br><ul><li><mark>g++ main.cpp -o a.out</mark></li><li>该命令会调用编译器程序g++，让他读取main.cpp中的字符串（称为源码），并根据C++标准生成相应的机器指令码，输出到a.out这个文件中，（称为可执行文件）。</li><li><mark>./a.out</mark></li><li>之后执行该命令，操作系统会读取刚刚生成的可执行文件，从而执行其中编译成机器码，调用系统提供的printf函数，并在终端显示出Hello, world。</li><li>a.out 里面均是机器码，01系列</li><li>objdump 程序可以将机器码反汇编成汇编语言，可以进行查看过程以及看懂了。(高级语言C++---&gt;汇编语言---&gt;机器码)</li></ul><br><h2 id="二、多文件编译与链接" tabindex="-1"><a class="header-anchor" href="#二、多文件编译与链接" aria-hidden="true">#</a> 二、多文件编译与链接</h2><ul><li><mark>单文件编译虽然方便，但也有如下缺点</mark></li><li>1-所有的代码都堆在一起，不利于模块化和理解。</li><li>2-工程变大时，编译时间变得很长，改动一个地方就得全部重新编译。</li><li>比如一个 main.cpp 和 hello.cpp 如果更改了hello.cpp文件的话</li><li>g++ hello.cpp main.cpp -o a.out 这样的话就是重新全部编译一次了。</li></ul><br><ul><li><mark>提出多文件编译的概念，文件之间通过符号声明相互引用</mark></li><li>g++ -c hello.cpp -o hello.o</li><li>g++ -c main.cpp -o main.o</li><li>其中使用 -c 选项指定生成临时的对象文件 main.o，之后再根据一系列对象文件进行链接，得到最终的a.out：或者说将这个.o文件为预编译文件。</li><li>g++ hello.o main.o -o a.out 然后将两个预编译文件 变为 可执行文件.out</li><li>也就是说，如果仅仅更改了hello.cpp 文件的话，仅仅需要 g++ -c hello.cpp -o hello.o 这个再重新生成临时对象文件就行了。</li></ul><br><h2 id="三、为什么需要构建系统-makefile" tabindex="-1"><a class="header-anchor" href="#三、为什么需要构建系统-makefile" aria-hidden="true">#</a> 三、为什么需要构建系统（Makefile）</h2><ul><li><mark>GNU 厂家 的 Make 软件</mark></li></ul><br><ul><li><mark>为什么需要Make这个软件？</mark></li><li>1-文件越来越多时，一个个调用g++编译链接会变得很麻烦。</li><li>2-于是，发明了 make 这个程序，你只需写出不同文件之间的依赖关系，和生成各文件的规则。</li></ul><br><ul><li><mark>make a.out</mark></li><li>敲下这个命令，就可以构建出 a.out 这个可执行文件了。</li></ul><br><ul><li><mark>和直接用一个脚本写出完整的构建过程相比，make 指明依赖关系的好处</mark></li><li>1-当更新了hello.cpp时只会重新编译hello.o，而不需要把main.o也重新编译一遍。</li><li>2-能够自动并行地发起对hello.cpp和main.cpp的编译，加快编译速度（make -j）。</li><li>3-用通配符批量生成构建规则，避免针对每个.cpp和.o重复写 g++ 命令（%.o: %.cpp）。</li><li><mark>坏处</mark></li><li>1-make 在 Unix 类系统上是通用的，但在 Windows 则不然。</li><li>2-需要准确地指明每个项目之间的依赖关系，有头文件时特别头疼。</li><li>3-make 的语法非常简单，不像 shell 或 python 可以做很多判断等。</li><li>4-不同的编译器有不同的 flag 规则，为 g++ 准备的参数可能对 MSVC 不适用。</li></ul>',21);function f(g,b){const a=t("router-link");return n(),c("div",null,[h,k,m(" more "),s,l("nav",d,[l("ul",null,[l("li",null,[e(a,{to:"#简单介绍主要是基础"},{default:o(()=>[i("简单介绍主要是基础")]),_:1})]),l("li",null,[e(a,{to:"#一、什么是编译器"},{default:o(()=>[i("一、什么是编译器？")]),_:1})]),l("li",null,[e(a,{to:"#二、多文件编译与链接"},{default:o(()=>[i("二、多文件编译与链接")]),_:1})]),l("li",null,[e(a,{to:"#三、为什么需要构建系统-makefile"},{default:o(()=>[i("三、为什么需要构建系统（Makefile）")]),_:1})])])]),_])}const M=r(u,[["render",f],["__file","B-从Cmake学起.html.vue"]]);export{M as default};
