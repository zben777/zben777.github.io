import{_ as u}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c as k,d as b,a as n,e,w as a,b as s,f as l}from"./app-2a2d189a.js";const m="/assets/figure7-1-3bc8c175.png",v="/assets/figure7-2-e1093559.png",_="/assets/figure7-3-2597217b.png",f="/assets/figure7-4-17b06eff.png",h="/assets/table7-1-4830b0c3.png",g="/assets/table7-2-95d0845f.png",A="/assets/table7-3-90d1411e.png",y="/assets/table7-4-c10fbef8.png",x="/assets/table7-5-4df10a53.png",C="/assets/table7-6-a157ddf2.png",D="/assets/figure7-5-c9a4b691.png",w="/assets/figure7-7-544bfdcf.png",U="/assets/figure7-6-6f376ae7.png",P="/assets/table7-8-c6f2393b.png",S={},I=n("h1",{id:"g-第七章",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#g-第七章","aria-hidden":"true"},"#"),s(" G-第七章")],-1),M=n("p",null,"G-第七章",-1),E={class:"table-of-contents"},V=l('<h2 id="简单介绍主要是基础" tabindex="-1"><a class="header-anchor" href="#简单介绍主要是基础" aria-hidden="true">#</a> 简单介绍主要是基础</h2><div class="hint-container info"><p class="hint-container-title">说明</p><p>主要是各种搜索找的学习；</p><p>主题：CUDA核心GPU编程</p><p>前置条件：</p><ul><li>应具备C++编程知识</li><li>需理解内存管理，如malloc和free</li><li>理解STL及其模板机制</li><li>需配置NVIDIA显卡，型号需为900系列或更高</li><li>所用扩展要求版本为11或更新</li><li>编译器版本不低于11</li><li>CMake版本需在3.18以上</li></ul></div><div class="hint-container info"><p class="hint-container-title">问题</p><ul><li></li></ul></div><h2 id="第7章-调整指令级原语" tabindex="-1"><a class="header-anchor" href="#第7章-调整指令级原语" aria-hidden="true">#</a> 第7章 调整指令级原语</h2><ul><li><p>本章内容：<br> ·学习CUDA指令及其在应用程序行为中的作用<br> ·单浮点数和双浮点数的精确度对比<br> ·有关标准函数及CUDA内部函数的性能和精确度的实验<br> ·从不安全的内存访问中发现未定义行为<br> ·理解运算指令的意义和使用不当所产生的后果</p></li><li><p>当决定使用CUDA处理一个特殊的应用程序时，通常主要应该考虑的是GPU的计算吞<br> 吐量。正如本书前面章节所介绍的，为了在GPU上实现较高的吞吐量，你需要了解有哪些<br> 因素限制峰值的性能。如果很看重延迟、带宽或算术运算的话，那么你可以借助所学到的<br> CUDA工具。基于此，可以将应用程序分为两类：<br> ·I/O密集型<br> ·计算密集型</p></li><li><p>本章重点介绍计算密集型应用。处理器的计算吞吐量可以用它在一段时间内执行操作<br> 的数量来衡量。因为GPU有很多SIMT指令和计算核心，所以其峰值计算吞吐量通常比其<br> 他的处理器要高。</p></li><li><p>但并不是所有的指令都是平等的。如果结果不能正确收敛或没有获得预期的结果，那<br> 么程序运行速度再快也没有用。对应用程序的吞吐量和正确性进行优化时，理解不同低级<br> 原语的性能、数值精确度和线程安全性方面的优缺点是很重要的。知道内核代码在什么时<br> 候被编译成一条原语或其他语句，能让你根据需求调整编译器生成的代码。</p></li><li><p>为了演示如何有效地调整低级指令，看一下以下的代码段：<code>double value = in1 * in2 + in3;</code></p></li><li><p>这种乘法后紧跟加法的算术模式被称为乘法加，或者MAD，其应用非常广泛。任何<br> 利用向量和矩阵的应用程序都可能包含许多MAD指令来执行线性代数中的点积运算、矩<br> 阵乘法运算，以及其他运算。一个简单的编译器会把一个MAD指令转化成两个算术指<br> 令：先进行乘法运算紧接着进行加法运算。因为这种模式很常见，所以现代运算结构（包<br> 括NVIDIA GPU）都支持MAD指令。因此，执行一个MAD的结果是循环次数减少了一半。<br> 这种性能的提升并不是没有代价的。一个MAD指令的数据准确性往往比单独的乘法和加<br> 法指令的要低。与MAD指令类似，本章所讨论的内容都将在一个理想的应用程序行为和<br> 另一个理想的应用程序之间进行权衡。</p></li><li><p>在本章中，你将学到各种用于优化性能、提高准确性和正确性比较低级的CUDA的原<br> 语。你将学习到这些特性是如何在指令级中对应用程序产生影响的。在本章的最后，你会<br> 明白单精度浮点值和双精度浮点值、内部函数和标准函数，以及原子操作的优点和缺点。</p></li></ul><h2 id="_7-1-cuda指令概述" tabindex="-1"><a class="header-anchor" href="#_7-1-cuda指令概述" aria-hidden="true">#</a> 7.1 CUDA指令概述</h2><ul><li>指令是处理器中的一个逻辑单元。对你来说CUDA指令可能很陌生，但是知道CUDA<br> 内核代码什么时候会产生不同指令以及高级语言如何转化为指令，对你来说却是很重要<br> 的。对两个功能等效指令的选择可以影响很多应用程序的特性，包括性能、精确度和正确<br> 性。当通过严格的数字验证请求，把遗留应用程序传输到CUDA时，就要特别留意这些问<br> 题了。本节涵盖了显著影响CUDA内核生成指令的3大因素：浮点运算、内置和标准函<br> 数、原子操作。浮点运算是针对于非整数值的计算，并且会影响CUDA程序的精确度和性<br> 能。虽然内置和标准的函数使用相同的数学运算，但有不同的精确度和性能。当调用多个<br> 线程执行操作时，原子指令确保了程序执行的正确性。本章将围绕这些话题展开，使你更<br> 深入地了解它们对编译器生成指令的影响。</li></ul><h3 id="_7-1-1-浮点指令" tabindex="-1"><a class="header-anchor" href="#_7-1-1-浮点指令" aria-hidden="true">#</a> 7.1.1 浮点指令</h3><ul><li><p>自从浮点运算采用IEEE——754标准后，所有的主流处理器厂商都使用这一标准，包<br> 括NVIDIA。这个标准规定将二进制浮点数据编码成3段：符号段（sign），一个比特位；<br> 指数段（exponent），多个比特位；以及尾数或分数段（fraction），多个比特位。如图7-1<br> 所示。<br><img src="'+m+'" alt="figure7-1" loading="lazy"></p></li><li><p>为了确保跨平台计算的一致性，IEEE——754定义了32位和64位浮点格式，它们分别<br> 对应C语言数据类型的float和double，它们的位长度不同，如图7-2所示。<br><img src="'+v+'" alt="figure7-2" loading="lazy"></p></li><li><p>给定一个32位的浮点变量，其中标志位s占1位，指数e为8位，尾数v为23位，这个浮<br> 点变量可以表示成图7-3所示的格式。<br><img src="'+_+`" alt="figure7-3" loading="lazy"></p></li><li><p>因为浮点变量相较于整型变量来说能够更精确地表示一个数值，所以这个浮点变量表<br> 达式在应用中非常重要。然而数值的精确度是有限的，并且用浮点类型存储的数据是离散<br> 且有限的。例如下面的代码段：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">3.1415927f</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">3.1415928f</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a is equal to b\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a does not equal b\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因为a和b的最后一个数字不同，所以预期输出为：<code>a does not equal b</code></p></li><li><p>但是，在与IEEE——754标准兼容的体系结构中，其输出为：<code>a is equal to b</code></p></li><li><p>在这个例子中，这两个值都不能在浮点型变量a和b所在的有限比特位中存储。因此，<br> 两者的数值只能被近似存储，这样的话两者的值就恰好相等了。</p></li><li><p>浮点型数值不能精确存储，只能在四舍五入后再存储。例如，在前面例子中，使用默<br> 认的近似舍入，将不可精确表示的数值表示成最接近的数值。还有一些其他的舍入方式，<br> 例如，向零取舍（向绝对值最小的方向舍入）、向上取舍、向下取舍。</p></li><li><p>浮点编程中需要考虑的另一个方面是浮点数的粒度问题。像上面所讨论的，浮点数的<br> 粒度比整数来说要好。然而浮点数只能在离散的区间间隔内存储数据。随着浮点数值离零<br> 越来越远（在正负两个方向上），表示数值的区间也会随之增大（如图7-4所示）。<br><img src="`+f+'" alt="figure7-4" loading="lazy"></p></li><li><p>可以使用C语言中的数学函数nextaf-terf，从一个给定值找到下一个最高位浮点数。表<br> 7-1通过一些数字说明了一个浮点数和下一个最高位可表示数字的区别。值得注意的是，<br> 随着x值的增大，精度会大幅降低。浮点数之间的区间间隔意味着在任何可能产生极端数<br> 值的应用中，对数值进行四舍五入会对输出有很大的影响。<br><img src="'+h+'" alt="table7-1" loading="lazy"></p></li><li><p>在浮点数值上进行操作的指令被称为浮点指令。CUDA支持所有在浮点数上常见的算<br> 数运算，如加法、乘法、除法和减法。</p></li><li><p>就像之前提到过的，CUDA和其他遵循IEEE——754标准的编程模式支持两种浮点精<br> 度：32位和64位。这些不同的格式也分别被称为单精度和双精度。因为双精度浮点数的位<br> 数是单精度浮点数的两倍，所以双精度可以表示更多的数值。这意味着双精度浮点数既有<br> 更好的细粒度又有比单精度值更大的数值范围。例如，以之前所用的浮点精度为例，它使<br> 用的是双精度浮点数而不是单精度浮点数：</p></li></ul>',11),G={class:"hint-container details"},N=n("summary",null,"Click me to view the code!",-1),T=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[n("span",{class:"token keyword"},"double"),s(" a "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"3.1415927"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token keyword"},"double"),s(" b "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"3.1415928"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),s("a "),n("span",{class:"token operator"},"=="),s(" b"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token function"},"printf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"a is equal to b\\n"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(),n("span",{class:"token keyword"},"else"),s(),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token function"},"printf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"a does not equal b\\n"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token comment"},"//期望输出："),s(`
a does `),n("span",{class:"token operator"},"not"),s(` equal b
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),q=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[s("yarn add "),n("span",{class:"token operator"},"-"),s("D vuepress"),n("span",{class:"token operator"},"-"),s("theme"),n("span",{class:"token operator"},"-"),s(`hope
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"})])],-1),z=l(`<ul><li><p>而当用双精度变量存储时，a和b最近似的表示值是不同的。</p></li><li><p>注意尽管所有的NVIDIA GPU都支持单精度浮点运算，但还是需要在一个计算能力为<br> 1.3或更高版本的NVIDIA GPU上使用双精度值。</p></li><li><p>不过，即使是双精度值也有局限性。本章后面7.2.1节将详细介绍浮点编程的挑战以及<br> 单精度与双精度浮点之间的不同。</p></li></ul><h3 id="_7-1-2-内部函数和标准函数" tabindex="-1"><a class="header-anchor" href="#_7-1-2-内部函数和标准函数" aria-hidden="true">#</a> 7.1.2 内部函数和标准函数</h3><ul><li><p>除了单精度和双精度操作的区别，CUDA还将所有算数函数分成内部函数和标准函<br> 数。标准函数用于支持可对主机和设备进行访问并标准化主机和设备的操作。标准函数包<br> 含来自于C标准数学库的数学运算，如sqrt、exp和sin。单指令运算如乘法和加法，也包含<br> 在标准函数中。</p></li><li><p>CUDA内置函数只能对设备代码进行访问。在编程中，如果一个函数是内部函数或是<br> 内置函数，那么在编译时对它的行为会有特殊响应，从而产生更积极的优化和更专业化的<br> 指令生成。这对CUDA内部函数来说是真实可信的。事实上，许多三角函数是直接在GPU<br> 硬件上实现的，因为它们中的大部分是用图形应用计算的（变换、旋转和其他在3D可视<br> 化应用上的操作）。</p></li><li><p>在CUDA中，许多内部函数与标准函数是有关联的，这意味着存在与内部函数功能相<br> 同的标准函数。举个例子，标准函数中的双精度浮点平方根函数也就是sqrt。有相同功能<br> 的内部函数是__dsqrt_rn。还有执行单精度浮点除法运算的内部函数：__fdividef。</p></li><li><p>内部函数分解成了比与它们等价的标准函数更少的指令。这会导致内部函数比等价的<br> 标准函数更快，但数值精确度却更低。因此可以在同一应用中交替使用标准函数和内部函<br> 数，但是它们在性能和数值精确度上会有所不同。</p></li><li><p>标准函数和内部函数大大增加了CUDA应用程序的灵活性。它们作为细粒度旋钮，可<br> 以在运行操作基础上调整性能和数值精确度。在本章后面的7.2.2节中，通过调整这些旋钮<br> 来观察它们的执行效果。</p></li></ul><h3 id="_7-1-3-原子操作指令" tabindex="-1"><a class="header-anchor" href="#_7-1-3-原子操作指令" aria-hidden="true">#</a> 7.1.3 原子操作指令</h3><ul><li><p>一条原子操作指令用来执行一个数学运算，此操作是一个独立不间断的操作，且没有<br> 其他线程的干扰。当一个线程在一个变量上成功完成一个原子操作时，那么不管有多少线<br> 程正在访问这个变量，这个变量的状态都已经发生了改变。因为原子操作指令阻止了多个<br> 线程之间互相干扰，它们可以对跨线程共享数据进行“读-改-写”操作（例如，读取当前<br> 值，增大它的值，然后写入新的值）。在GPU这样的高并发执行环境中，保证“读-改-<br> 写”操作的完整性尤为重要。CUDA提供了在32位或64位全局内存或共享内存上执行“读-<br> 改-写”操作的原子函数。</p></li><li><p>所有计算能力为1.1或以上的设备都支持原子操作，Kepler型全局原子内存操作比<br> Fermi型操作更快，吞吐量也显著提高了。这可能会使之前因高度依赖原子操作而被认为<br> 不适合GPU执行的CUDA型应用能够有更好的性能表现。</p></li><li><p>与标准函数和内部函数类似，每个原子函数都能实现一个基本的数学运算，如加法、<br> 乘法或减法。不同于目前介绍过的其他指令类型，当原子操作指令在两个竞争线程共享的<br> 内存空间进行操作时，会有一个定义好的行为。</p></li><li><p>用下面这个核函数来帮助理解这个概念：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
  temp <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>ptr <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这个内核从一个内存位置上读取一个数据，同时将其值加一，然后将得到的值写回到<br> 相同位置。注意，这里没有使用线程ID来改变正在被访问的内存位置，内核启动时每个线<br> 程都会从相同地址读写。如果启用一个含32个线程的线程块来运行这个核函数，那么会得<br> 到什么样的输出？你可能会说对于32个线程，每个线程都会增加1。事实上，结果是不确<br> 定的。这是因为不止一个线程对同一个内存位置进行写操作，这叫作数据竞争，或者称为<br> 对内存的不安全访问。数据竞争的定义是两个或者多个独立的正在执行的线程访问同一个<br> 地址，并且至少其中一个访问会修改该地址。直到程序真正被执行时，才能知道在这个过<br> 程中哪一个线程赢得了胜利。因此，对于这个例子或任何会发生数据竞争的应用程序来<br> 说，其结果是不能事先确定的。</p></li><li><p>幸好，使用原子操作指令可以避免这种事情的发生。原子操作指令是通过CUDA API<br> 访问的函数。例如：<code>int atomicAdd(int *M, int V);</code></p></li><li><p>大多数的原子函数是二进制函数，能够在两个操作数上进行操作。它们把一个内存位<br> 置M和一个数值V作为输入。与原子函数相关的操作在V上执行，数值V早已存储在内存地<br> 址*M中了，然后将运算结果写到同样的内存位置中。</p></li><li><p>原子运算函数分为3种：算术运算函数、按位运算函数和替换函数。原子算术函数在<br> 目标内存位置上执行简单的算术运算，包括加、减、最大、最小、自增和自减等操作。原<br> 子位运算函数在目标内存位置上执行按位操作，包括按位与、按位或、按位异或。原子替<br> 换函数可以用一个新值来替换内存位置上原有的值，它可以是有条件的也可以是无条件<br> 的。不管替换是否成功，原子替换函数总是会返回最初存储在目标位置上的值。<br> atomicExch可以无条件地替换已有的值。如果当前存储的值与由GPU线程调用指定的值相<br> 同，那么atomicCAS可以有条件地替换已有的值。</p></li><li><p>如下所示，回调前面的自增核函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
  temp <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>ptr <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以使用atomicAdd函数来重写自增内核程序。atomicAdd在原子级使数值V与存储在<br> 内存位置M中的数值相加。更新后的自增内核使用以下语句来增大存储在地址ptr上的数<br> 值，并在增大之前返回存储在ptr上的数值。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">incr</span><span class="token punctuation">(</span>__global__ <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token function">atomicAdd</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>随着这些变化的发生，此内核的行为已经有了明确的定义。如果启动32个线程，存储<br> 在*ptr所指位置中的值应该是32。</p></li><li><p>另一方面，如果你的应用程序不需要所有线程都成功地增大数值，那么会怎样？如果<br> 我们只关心位于同一线程束中的一个或者几个线程能否成功运行呢？观察以下内核代码：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">check_threshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> threshold<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这里，每一个线程都在将数值与阈值进行比较。如果该值在阈值以上，则设置全局标<br> 志。假设所有的线程都在同一个全局标志上运行，如果多个数值在阈值之上，那么给标志<br> 位赋值的操作就是不安全的。</p></li><li><p>可以使用atomicExch来消除这种不安全访问：<code>int atomicExch(int *M, int V);</code></p></li><li><p>atomicExch无条件地用V替换存储在M中的值，并返回原来存储在M中的值。用<br> atomicExch重写check_threshold内核来去除对标志位的不安全访问。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">check_threshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> threshold<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">atomicExch</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在这个例子中，真的有必要使用atomicExch吗？在这种情况下，如果使用了不安全的<br> 访问，仍然可以保证至少有一个线程会成功写入*flag。使用atomicexch实际上并没有修改<br> 这个内核的行为。对一个应用程序来说，在check_threshold中简单地使用不安全的访问且<br> 能正确执行是有可能的。事实上，使用atomicexch等原子操作可能会显著降低其性能。当<br> 使用这种优化时必须非常小心，因为这种运算并不依赖于每个线程可见的运算结果。如果<br> 用check_threshold来统计高于阈值的数值数量，那么这种不安全访问将是无效的。</p></li><li><p>原子操作指令在高并行运行环境如GPU中是很强大的。它们提供了一种安全的方法，<br> 来操作被成百上千个线程所共享的数据。虽然原子函数没有精确度上的顾虑（而内部函数<br> 需要考虑精确度），但是它们的使用可能会严重降低性能。本章后面的7.2.3节中将探讨其<br> 原因。</p></li></ul><h2 id="_7-2-程序优化指令" tabindex="-1"><a class="header-anchor" href="#_7-2-程序优化指令" aria-hidden="true">#</a> 7.2 程序优化指令</h2><ul><li><p>用于优化程序的指令，有很多的选择：单精度或双精度浮点值、标准或内部函数、原<br> 子函数或不安全访问。一般情况下，每一个选择在性能、精确度和正确性上都有不同表<br> 现。对于所有应用程序来说并没有最佳的选择，最佳决策取决于应用程序的要求。</p></li><li><p>本节涵盖了体现每一类指令不同优缺点的例子。</p></li></ul><h3 id="_7-2-1-单精度与双精度的比较" tabindex="-1"><a class="header-anchor" href="#_7-2-1-单精度与双精度的比较" aria-hidden="true">#</a> 7.2.1 单精度与双精度的比较</h3><ul><li>正如前面所讨论的，用于存储单精度和双精度数的位数是不同的。因此，双精度变量<br> 相较于单精度变量来说，可以在一个更精细的粒度和更广泛的范围上表示不同的数值。为<br> 了证明这一点，可以从Wrox.com下载floating-point-accuracy.cu来创建和运行相关程序。这<br> 个程序在主机和设备端将数值12.1分别存储为单精度变量和双精度变量，然后将按20个小<br> 数位存储的实际值进行输出。以下为输出示例：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Host single<span class="token operator">-</span>precision representation of <span class="token number">12.1</span> <span class="token operator">=</span> <span class="token number">12.10000038146972656250</span>
Host <span class="token keyword">double</span><span class="token operator">-</span>precision representation of <span class="token number">12.1</span> <span class="token operator">=</span> <span class="token number">12.09999999999999964473</span>
Device single<span class="token operator">-</span>precision representation of <span class="token number">12.1</span> <span class="token operator">=</span> <span class="token number">12.10000038146972656250</span>
Device <span class="token keyword">double</span><span class="token operator">-</span>precision representation of <span class="token number">12.1</span> <span class="token operator">=</span> <span class="token number">12.09999999999999964473</span>
Device <span class="token operator">and</span> host single<span class="token operator">-</span>precision representation equal<span class="token operator">?</span> yes
Device <span class="token operator">and</span> host <span class="token keyword">double</span><span class="token operator">-</span>precision representation equal<span class="token operator">?</span> yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>虽然主机和设备上的数值都与12.1近似，但都不是精确值。在这个特殊的例子中，双<br> 精度数值比单精度数值稍微更接近于真实数值。</p></li><li><p>双精度数值的精确性是以空间和性能消耗为代价的。来自于Wrox.com上的floatingpoint-perf.cu程序随机产生了一个浮点输入向量，<br> 将该向量复制到GPU中，在GPU上重复执<br> 行大量的数学运算，然后再将结果复制回主机。使用单精度向量和双精度向量执行同样的<br> 操作，并对传输和内核所需时间进行测量。整个过程是反复运行的，以减少执行时间中随<br> 机变动造成的测量误差。该程序的输出示例如下：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Running <span class="token number">65535</span> blocks with <span class="token number">256</span> threads<span class="token operator">/</span>block over <span class="token number">154990080</span> elements
Input Diff Between Single<span class="token operator">-</span> <span class="token operator">and</span> Double<span class="token operator">-</span>Precision
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token number">0</span> <span class="token number">1.16110611328622326255e-01</span>
<span class="token number">1</span> <span class="token number">1.42341757498797960579e-01</span>
<span class="token number">2</span> <span class="token number">1.45135404032771475613e-01</span>
<span class="token number">3</span> <span class="token number">1.47929050144739449024e-01</span>
<span class="token number">4</span> <span class="token number">1.03847696445882320404e-01</span>
<span class="token number">5</span> <span class="token number">1.84766342732473276556e-01</span>
<span class="token number">6</span> <span class="token number">1.48497488888096995652e-01</span>
<span class="token number">7</span> <span class="token number">1.20041135203791782260e-01</span>
<span class="token number">8</span> <span class="token number">1.38459781592246145010e-01</span>
<span class="token number">9</span> <span class="token number">1.49065927878837101161e-01</span>
For single<span class="token operator">-</span>precision floating point<span class="token punctuation">,</span> mean times <span class="token keyword">for</span><span class="token operator">:</span>
 Copy to device<span class="token operator">:</span> <span class="token number">129</span> ms
 Kernel execution<span class="token operator">:</span> <span class="token number">574</span> ms
 Copy from device<span class="token operator">:</span> <span class="token number">201</span> ms
For <span class="token keyword">double</span><span class="token operator">-</span>precision floating point<span class="token punctuation">,</span> mean times <span class="token keyword">for</span><span class="token operator">:</span>
 Copy to device<span class="token operator">:</span> <span class="token number">258</span> <span class="token function">ms</span> <span class="token punctuation">(</span><span class="token number">2.00</span>x slower than single<span class="token operator">-</span>precision<span class="token punctuation">)</span>
 Kernel execution<span class="token operator">:</span> <span class="token number">890</span> <span class="token function">ms</span> <span class="token punctuation">(</span><span class="token number">1.55</span>x slower than single<span class="token operator">-</span>precision<span class="token punctuation">)</span>
 Copy from device<span class="token operator">:</span> <span class="token number">401</span> <span class="token function">ms</span> <span class="token punctuation">(</span><span class="token number">2.00</span>x slower than single<span class="token operator">-</span>precision<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这个例子说明了两点。首先，单精度和双精度浮点运算在通信和计算上的性能差异是<br> 不可忽略的。在这种情况下，使用双精度数值能够使总的程序运行时间增加近一倍（虽然<br> 这个结果可能取决于应用程序是计算密集型还是I/O密集型）。在设备端进行数据通信的<br> 时间也是使用单精度数值的两倍，这是由双精度数值长度是单精度数值长度的两倍造成<br> 的。随着全局内存输入/输出数量和每条指令执行的位操作数量的增加，设备上的计算时<br> 间也会增加。</p></li><li><p>这个程序也说明了单精度与双精度的结果有较大的数值差异，这些结果可能在迭代过<br> 程中不断被积累，即第一次迭代产生的不精确的结果作为下一次迭代的输入继续参与运<br> 算，导致最终结果偏差很大。因此，考虑到数值精确度，在迭代应用中可能更需要使用双<br> 精度变量。</p></li><li><p>还需要注意的是，由于双精度数值所占空间是单精度数值的两倍，所以当在寄存器中<br> 存储一个双精度数值（在内核中已被声明）时，一个线程块总的共享寄存器区域会比使用<br> 浮点数小得多。在声明单精度浮点数值时必须非常谨慎（例如，pi＝3.14i59f；）。任何<br> 不正确的省略尾数f的声明（pi＝3.14i59）都会自动地被NVCC编译器转换成双精度数。</p></li></ul><br><ul><li><p><mark>小结</mark></p></li><li><p>浮点运算对应用程序的性能和数值精确度上的影响并不是只在GPU上才会产生，使用<br> 其他架构时，会面对同样的问题。以下是CUDA和GPU独有的特点：</p><ul><li>使用双精度数值增加主机与设备之间的通信</li><li>使用双精度数值增加全局内存的输入/输出</li><li>数值精度的损失是由CUDA编译器强制浮点数值优化导致的</li></ul></li><li><p>一般情况下，如果应用程序对精确度要求很高的话，那么必须使用双精度数值。否<br> 则，使用单精度数值可以获得性能提升。表7-2总结了在CUDA中使用浮点数运算的一些<br> 经验。<br><img src="`+g+'" alt="table7-2" loading="lazy"></p></li></ul><h3 id="_7-2-2-标准函数与内部函数的比较" tabindex="-1"><a class="header-anchor" href="#_7-2-2-标准函数与内部函数的比较" aria-hidden="true">#</a> 7.2.2 标准函数与内部函数的比较</h3><ul><li>标准函数和内部函数在数值精确度和性能上的表现是不同的。标准函数支持大部分的<br> 数学运算。但是，许多等效的内部函数能够使用较少的指令、改进的性能和更低的数值精<br> 确度，实现相同的功能。</li></ul><h4 id="_7-2-2-1-标准函数和内部函数可视化" tabindex="-1"><a class="header-anchor" href="#_7-2-2-1-标准函数和内部函数可视化" aria-hidden="true">#</a> 7.2.2.1 标准函数和内部函数可视化</h4><ul><li><p>通过学习由CUDA编译器产生的针对每个函数的指令，可以将标准函数和内部函数差<br> 异可视化。使用nvcc的--ptx标志能够让编译器在并行线程执行（PTX）和指令集架构<br> （ISA）中生成程序的中间表达式，而不是生成一个最终的可执行文件。PTX类似于x86编<br> 程里面的程序集，它提供了一个你所编写的内核代码之间的中间表达式，该指令在GPU上<br> 执行。因此，它对于深入了解内核的低级别执行路径是很有用的。</p></li><li><p>例如，你可以为以下两个CUDA函数生成一个PTX来直观地比较标准函数和内部函<br> 数。为此，将这些核函数存储到一个命名为foo.cu的文件中：</p></li></ul>',29),B={class:"hint-container details"},L=n("summary",null,"Click me to view the code!",-1),W=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[s(" __global__ "),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"intrinsic"),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"float"),s(),n("span",{class:"token operator"},"*"),s("ptr"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token operator"},"*"),s("ptr "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"__powf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token operator"},"*"),s("ptr"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token number"},"2.0f"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
__global__ `),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"standard"),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"float"),s(),n("span",{class:"token operator"},"*"),s("ptr"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token operator"},"*"),s("ptr "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"powf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token operator"},"*"),s("ptr"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token number"},"2.0f"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),$=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[n("span",{class:"token comment"},"//接下来使用以下命令生成一个PTX文件并命名为foo.ptx："),s(`
$ nvcc `),n("span",{class:"token operator"},"--"),s("ptx "),n("span",{class:"token operator"},"-"),s("o foo"),n("span",{class:"token punctuation"},"."),s("ptx foo"),n("span",{class:"token punctuation"},"."),s(`cu
nvcc编译器会为这些设备函数生成一个包含PTX指令的文件。可以用文本编辑器打开
foo`),n("span",{class:"token punctuation"},"."),s(`ptx。


如果你之前没有读过原指令，foo`),n("span",{class:"token punctuation"},"."),s(`ptx的内容对你来说可能比较难懂。首先要介绍的是
special`),n("span",{class:"token operator"},"-"),s("purpose"),n("span",{class:"token punctuation"},"."),s("entry指令，这个指令标志了一个函数定义的开始。由于在foo"),n("span",{class:"token punctuation"},"."),s(`cu中有两个核
函数，所以在生成的PTX文件中会有两个`),n("span",{class:"token punctuation"},"."),s("entry指令。在CUDA "),n("span",{class:"token number"},"5.0"),s(`中，标准函数的函数签
名是：

`),n("span",{class:"token punctuation"},"."),s("entry "),n("span",{class:"token function"},"_Z8standardPf"),s(),n("span",{class:"token punctuation"},"("),s(`
 `),n("span",{class:"token punctuation"},"."),s("param "),n("span",{class:"token punctuation"},"."),s("u64 __cudaparm__Z8standardPf_ptr"),n("span",{class:"token punctuation"},")"),s(`
 `),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token punctuation"},"."),n("span",{class:"token punctuation"},"."),n("span",{class:"token punctuation"},"."),s(`
 `),n("span",{class:"token punctuation"},"}"),s(`


对于instrinsic函数是：
 `),n("span",{class:"token punctuation"},"."),s("entry "),n("span",{class:"token function"},"_Z9intrinsicPf"),s(),n("span",{class:"token punctuation"},"("),s(`
 `),n("span",{class:"token punctuation"},"."),s("param "),n("span",{class:"token punctuation"},"."),s("u64 __cudaparm__Z9intrinsicPf_ptr"),n("span",{class:"token punctuation"},")"),s(`
 `),n("span",{class:"token punctuation"},"{"),s(`
 `),n("span",{class:"token punctuation"},"."),n("span",{class:"token punctuation"},"."),n("span",{class:"token punctuation"},"."),s(`
 `),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),F=l(`<ul><li>函数名可能会因编译器版本的不同而不同。.entry后的开括号以及随后文件中相应的<br> 闭括号之间的内容对你来说并不陌生。和C语言一样，这些括号括起来的是每个函数逻辑<br> 指令的定义。例如，foo.ptx文件中定义的第一个函数是内部函数，并且类似于以下代码：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">.</span>entry <span class="token function">_Z9intrinsicPf</span> <span class="token punctuation">(</span>
 <span class="token punctuation">.</span>param <span class="token punctuation">.</span>u64 __cudaparm__Z9intrinsicPf_ptr<span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 <span class="token punctuation">.</span>reg <span class="token punctuation">.</span>u64 <span class="token operator">%</span>rd<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
 <span class="token punctuation">.</span>reg <span class="token punctuation">.</span>f32 <span class="token operator">%</span>f<span class="token operator">&lt;</span><span class="token number">7</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
 <span class="token punctuation">.</span>loc <span class="token number">14</span> <span class="token number">4</span> <span class="token number">0</span>
$LDWbegin__Z9intrinsicPf<span class="token operator">:</span>
 <span class="token punctuation">.</span>loc <span class="token number">14</span> <span class="token number">5</span> <span class="token number">0</span>
 ld<span class="token punctuation">.</span>param<span class="token punctuation">.</span>u64 <span class="token operator">%</span>rd1<span class="token punctuation">,</span> <span class="token punctuation">[</span>__cudaparm__Z9intrinsicPf_ptr<span class="token punctuation">]</span><span class="token punctuation">;</span>
 ld<span class="token punctuation">.</span>global<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">%</span>rd1<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 lg2<span class="token punctuation">.</span>approx<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f2<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">;</span>
 mov<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f3<span class="token punctuation">,</span> <span class="token number">0f</span>40000000<span class="token punctuation">;</span> <span class="token comment">// 2</span>
 mul<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f4<span class="token punctuation">,</span> <span class="token operator">%</span>f2<span class="token punctuation">,</span> <span class="token operator">%</span>f3<span class="token punctuation">;</span>
 ex2<span class="token punctuation">.</span>approx<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f5<span class="token punctuation">,</span> <span class="token operator">%</span>f4<span class="token punctuation">;</span>
 st<span class="token punctuation">.</span>global<span class="token punctuation">.</span>f32 <span class="token punctuation">[</span><span class="token operator">%</span>rd1<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">%</span>f5<span class="token punctuation">;</span>
 <span class="token punctuation">.</span>loc <span class="token number">14</span> <span class="token number">6</span> <span class="token number">0</span>
 exit<span class="token punctuation">;</span>
$LDWend__Z9intrinsicPf<span class="token operator">:</span>
 <span class="token punctuation">}</span> <span class="token comment">// _Z9intrinsicPf</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>内部函数_powf实现需要17行代码，并且只有7条指令执行浮点数运算。看一下foo.ptx<br> 文件中的标准函数powf，它实现的代码要长得多（在CUDA 5.0开发工具包中使用了344<br> 行）。这些代码行数并不直接转化为指令或者循环，所以性能上的区别仍很重要。</p></li><li><p>然而，区分标准函数和内部函数的不仅有性能，它们的计算精度也是不同的。为了测<br> 试性能和精确度的不同，可以从Wrox.com中下载intrinsic-standard-comp.cu这个例子，创建<br> 并运行相关应用程序。在该程序中的核函数中，先使用标准函数powf，再使用内部函数<br> __powf，利用它们反复计算输入值的平方根。这个例子也使用主机上的C标准数学库来执<br> 行相同的计算，并使用主机上的结果作为基准值。intrinsic-standard-comp.cu的示例输出如<br> 下所示：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Host calculated <span class="token number">66932852.000000</span>
Standard Device calculated <span class="token number">66932848.000000</span>
Intrinsic Device calculated <span class="token number">66932804.000000</span>
Host equals Standard<span class="token operator">?</span> No diff<span class="token operator">=</span><span class="token number">4.000000e+00</span>
Host equals Intrinsic<span class="token operator">?</span> No diff<span class="token operator">=</span><span class="token number">4.800000e+01</span>
Standard equals Intrinsic<span class="token operator">?</span> No diff<span class="token operator">=</span><span class="token number">4.400000e+01</span>
Mean execution time <span class="token keyword">for</span> standard function powf<span class="token operator">:</span> <span class="token number">47</span> ms
Mean execution time <span class="token keyword">for</span> intrinsic function __powf<span class="token operator">:</span> <span class="token number">2</span> ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不出所料，使用内部函数相较于标准函数来说，速度提升了将近24倍，获得了巨大的<br> 性能提升。CUDA标准函数和内部函数不仅输出结果不同，它们与主机标准数学库计算的<br> 结果也不同。但是，当比较内部函数和标准函数的计算结果时，内在结果比主机结果相差<br> 一个数量级。</li></ul><h4 id="cpu到gpu的移植" tabindex="-1"><a class="header-anchor" href="#cpu到gpu的移植" aria-hidden="true">#</a> CPU到GPU的移植</h4><ul><li><p>使用CUDA来执行科学仿真、金融算法和其他要求高精度和高保真度的应用程序通常<br> 需要两个步骤：将传统应用从只有CPU的系统移植到CUDA系统中，接着通过比较传统应<br> 用结果与使用CUDA的执行结果，来验证程序移植的数值精确性。</p></li><li><p>即使使用数值稳定的CUDA函数，GPU上的运算结果仍与传统的只在CPU上运行的应<br> 用结果不同。由于主机和设备上的浮点运算都存在固有的不精确性，有时很难指出一个输<br> 出结果与另一个输出结果哪个更精确。因此，必须考虑数值差异并做出恰当的移植计划，<br> 而且有必要的话需要设置允许的误差范围。</p></li></ul><h4 id="_7-2-2-2-操纵指令生成" tabindex="-1"><a class="header-anchor" href="#_7-2-2-2-操纵指令生成" aria-hidden="true">#</a> 7.2.2.2 操纵指令生成</h4><ul><li><p>在大多数情况下，将程序员编写的内核代码转换为GPU指令集这一过程是由CUDA编<br> 译器完成的。程序员很少会有检查或手动修改指令的想法。但是，这并不意味着你无法引<br> 导编译器倾向于实现良好的性能或准确性或者达到两者的平衡。CUDA编译器中有两种方<br> 法可以控制指令级优化类型：编译器标志、内部或标准函数调用。</p></li><li><p>例如，内部函数__fdividef与运算符“/”相比，在执行浮点数除法时速度更快但数值精<br> 确度相对较低。假设有下面的核函数foo：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> c <span class="token operator">=</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//可以用功能上等价的__fdividef来替换“/”，并测试性能：</span>
__global__ <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> c <span class="token operator">=</span> <span class="token function">__fdividef</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>一个个手动调整内核操作的工作量太大了。编译器标志提供了一个更自动、全局化的<br> 方式来操纵编译器指令的生成。例如，你可能想要通过CUDA编译器控制浮点数<br> MAD（FMAD）指令的生成。MAD是一个简单的编译器优化指令，它能将乘法和加法融<br> 合到一个指令中，从而使运算时间比使用两个指令缩短一半。但是，这个优化需要以数值<br> 精度为代价。所以，一些应用程序会明确限制FMAD指令的使用。</p></li><li><p>nvcc的--fmad选项可全局性地启用或禁用FMAD整个编译单元的优化。默认情况下，<br> nvcc使用“--fmad=true”以启用FMAD指令来优化性能。“--fmad=false”的意思是阻止编译器<br> 混合任何乘法和加法，这虽然有损性能但可能提高应用程序的数值精度。</p></li><li><p>例如，给出以下核函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//用“--fmad=true”为foo函数生成PTX，也就是为内核产生一个算术指令：</span>
mad<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f2<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">;</span>


正如预期所料，在这里你能看到一个应用于<span class="token number">3</span>个<span class="token number">32</span>位浮点值的MAD乘<span class="token operator">-</span>加指令。如果
这个内核用“<span class="token operator">--</span>fmad<span class="token operator">=</span><span class="token boolean">false</span>”进行编译，在MAD指令的位置会出现一对指令，如下所示：
mul<span class="token punctuation">.</span>rn<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f2<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">;</span>
add<span class="token punctuation">.</span>rn<span class="token punctuation">.</span>f32 <span class="token operator">%</span>f3<span class="token punctuation">,</span> <span class="token operator">%</span>f2<span class="token punctuation">,</span> <span class="token operator">%</span>f1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>编译器标志按预期运行，可以看到nvcc没有将乘法和加法融合为一个MAD指令。</p></li><li><p>注意，除了--fmad，还有许多CUDA编译器标志会影响算法指令的生成。完整的列表<br> 可在nvcc的--help选项中找到，表7-3中列出了这些编译器标志。<br><img src="`+A+`" alt="table7-3" loading="lazy"></p></li><li><p>除了--fmad选项，CUDA还包含一对用于控制FMAD指令生成的内部函数：__fmul和<br> __dmul，这些函数用于实现单精度浮点型和双精度浮点型乘法。然而这些函数不会影响乘<br> 法运算的性能，在有“*”运算符的地方调用它们可阻止nvcc将乘法作为乘加优化的一部分<br> 来使用。例如，在之前的核函数foo中，--fmad=false就阻止生成一个mad.f32指令。通过插<br> 入一个__fmul函数调用可以实现相同效果。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 ptr <span class="token operator">=</span> <span class="token function">__fmul_rn</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),X=n("li",null,[n("p",null,[s("需要注意的是，不论是指定--fmad=true还是--fmad=false，__fmul和__dmul都阻止MAD"),n("br"),s(" 指令的生成。因此，当通过有选择地调用__fmul或者__dmul的计算来提升某些数值的健壮"),n("br"),s(" 性时，可启用MAD编译器优化全局。")])],-1),Z=n("li",null,[n("p",null,[s("你可能已经注意到在foo中调用__fmul时，实际上调用的是一个函数__fmul_rn。许多"),n("br"),s(" 浮点型内部函数（包括__fadd，__fsub，__fmul等）在函数名中都使用两个后缀字符，这"),n("br"),s(" 明确指出了浮点四舍五入的模式（在表7-4中已列出）。回想一下，由于浮点变量只能表"),n("br"),s(" 示离散的细粒度值，任何不能表示的值必须被舍入为可表示的值。浮点运算的舍入模式决"),n("br"),s(" 定了如何将不可表示的值转化成可表示的值。")])],-1),R=n("br",null,null,-1),O=n("br",null,null,-1),H=n("br",null,null,-1),K={href:"http://fmad.cu",target:"_blank",rel:"noopener noreferrer"},j=n("br",null,null,-1),J=n("img",{src:y,alt:"table7-4",loading:"lazy"},null,-1),Q={class:"hint-container details"},Y=n("summary",null,"Click me to view the code!",-1),nn=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[s("首先，尝试启用MAD CUDA优化来编译fmad"),n("span",{class:"token punctuation"},"."),s("cu。注意，你也可以省略参数"),n("span",{class:"token operator"},"--"),s("fmad"),n("span",{class:"token operator"},"="),n("span",{class:"token boolean"},"true"),s("，因为它的默认值即为"),n("span",{class:"token boolean"},"true"),s(`。
$ nvcc –arch`),n("span",{class:"token operator"},"="),s("sm_20 "),n("span",{class:"token operator"},"--"),s("fmad"),n("span",{class:"token operator"},"="),n("span",{class:"token boolean"},"true"),s(" fmad"),n("span",{class:"token punctuation"},"."),s(`cu –o fmad


运行程序产生如下输出：
$ `),n("span",{class:"token punctuation"},"."),n("span",{class:"token operator"},"/"),s(`fmad
The device output a different value than the host`),n("span",{class:"token punctuation"},","),s(" diff"),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"8.88e-16"),s(`


正如预期的那样，使用MAD优化在设备上导致出现了一些小的数值误差。fmad`),n("span",{class:"token punctuation"},"."),s(`cu也
可以在禁用MAD编译优化时执行编译：
$ nvcc –arch`),n("span",{class:"token operator"},"="),s("sm_20 "),n("span",{class:"token operator"},"--"),s("fmad"),n("span",{class:"token operator"},"="),n("span",{class:"token boolean"},"false"),s(" fmad"),n("span",{class:"token punctuation"},"."),s(`cu –o fmad


运行禁用MAD的应用程序产生如下输出：
$ `),n("span",{class:"token punctuation"},"."),n("span",{class:"token operator"},"/"),s(`fmad
The device output the same value as the host`),n("span",{class:"token punctuation"},"."),s(`


禁用FMAD后，主机和设备上产生的值是相同的。但是，设备内核需要更多的指令去
执行这个计算。
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),sn=n("div",{class:"language-cpp line-numbers-mode","data-ext":"cpp"},[n("pre",{class:"language-cpp"},[n("code",null,[s("yarn add "),n("span",{class:"token operator"},"-"),s("D vuepress"),n("span",{class:"token operator"},"-"),s("theme"),n("span",{class:"token operator"},"-"),s(`hope
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"})])],-1),an=l('<h4 id="_7-2-2-3-小结" tabindex="-1"><a class="header-anchor" href="#_7-2-2-3-小结" aria-hidden="true">#</a> 7.2.2.3 小结</h4><ul><li>本节证明了标准函数和内部函数对程序行为有很大的影响（见表7-5中的总结）。在<br> 许多情况下，你可以控制编译器如何生成指令，这对于调控应用程序的性能和精度是十分<br> 有帮助的。<br><img src="'+x+`" alt="table7-5" loading="lazy"></li></ul><h3 id="_7-2-3-了解原子指令" tabindex="-1"><a class="header-anchor" href="#_7-2-3-了解原子指令" aria-hidden="true">#</a> 7.2.3 了解原子指令</h3><ul><li>在本节中，你将学习如何使用原子操作，并学习在高并发环境下的共享数据上如何执<br> 行正确的操作。注意，不同计算能力的GPU支持不同的原子函数。需要在计算能力为1.0<br> 或以上的GPU上来运行本节的示例。</li></ul><h4 id="_7-2-3-1-从头开始" tabindex="-1"><a class="header-anchor" href="#_7-2-3-1-从头开始" aria-hidden="true">#</a> 7.2.3.1 从头开始</h4><ul><li><p>通过使用一个原子函数，每个由CUDA提供的原子函数可以重复被执行：原子级比较<br> 并交换（CAS）运算符。原子级CAS是一个很重要的操作，不仅可以使你在CUDA中定义<br> 你自己的原子函数，还能帮助你更深层次地理解原子操作。</p></li><li><p>CAS将3个内容作为输入：内存地址、存储在此地址中的期望值，以及实际想要存储<br> 在此位置的新值，然后执行以下几步：<br> 1.读取目标地址并将该处地址的存储值与预期值进行比较。<br> a.如果存储值与预期值相等，那么新值将存入目标位置。<br> b.如果存储值与预期值不等，那么目标位置不会发生变化。<br> 2.不论发生什么情况，一个CAS操作总是返回目标地址中的值。注意，使用返回值可<br> 以用来检查一个数值是否被替换成功。如果返回值等于传入的预期值，那么CAS操作一定<br> 成功了。</p></li><li><p>这只是CAS操作。一个原子CAS意味着整个CAS进程是在没有其他任何线程的干扰下<br> 完成的。因为这是一个原子运算符，如果CAS操作返回值显示写操作成功，那么所执行的<br> 数值交换必须对其他所有线程也可见。</p></li><li><p>想要学习更多关于原子操作的知识，可以使用CUDA的atomicCAS设备函数从头开始<br> 去实现一个原子函数。在这个例子中，你可以进行原子级32位整型加法运算。atomicCAS<br> 相关变体的函数签名为：<code>int atomicCAS(int *address, int compare, int val);</code></p></li><li><p>其中“address”是目标内存地址，“compare”是预期值，“val”是实际想写入的新值。</p></li><li><p>所以，你会怎样利用atomicCAS执行一个原子加法呢？首先需要分解加法运算并把它<br> 定义成CAS操作。当执行自定义原子操作时，定义目标的起始和结束状态是很有帮助的。<br> 在原子加法中，起始状态是递增运算的基值。结束状态值是起始状态和增量的总和。这个<br> 定义直接转换为atomicCAS：预期值是起始状态，实际写入的新值是完成状态。</p></li><li><p>若想实现一个自定义的原子加法函数，需要从函数签名开始，它需要一个目的地址存<br> 储到该地址的值。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__device__ <span class="token keyword">int</span> <span class="token function">myAtomicAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token keyword">int</span> incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以通过读取目标内存的地址，计算出存放在目标地址中的预期值。将读取到的值以<br> 及传递给myAtomicAdd的incr值定义实际值。使用这些预期值和实际值，可以调用<br> atomicCAS来实现加法运算：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__device__ <span class="token keyword">int</span> <span class="token function">myAtomicAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token keyword">int</span> incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// Create an initial guess for the value stored at *address.</span>
 <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token operator">*</span>address<span class="token punctuation">;</span>
 <span class="token keyword">int</span> oldValue <span class="token operator">=</span> <span class="token function">atomicCAS</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> expected<span class="token punctuation">,</span> expected <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这个myAtomicAdd函数可以实现原子加法。但是，只有当执行atomicCAS后，读<br> 入“expected”的值与存入“address”的值相同时操作才成功。因为目标位置是由多线程共享<br> 的（否则不需要原子操作），所以另一个线程修改“address”的值是有可能的，这个值处于<br> 被“expected”读入和atomicCAS修改之间。如果发生这种情况，atomicCAS的执行会因<br> 在“address”中的值和“expected”中的值不同而失败。</p></li><li><p>回忆一下可知，如果“atomicCAS”的返回值与预期值不同则程序会失败。因此，<br> myAtomicAdd可以用来检查失败并在一个循环中重试CAS直到atomicCAS成功。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>__device__ <span class="token keyword">int</span> <span class="token function">myAtomicAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token keyword">int</span> incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// Create an initial guess for the value stored at *address.</span>
 <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token operator">*</span>address<span class="token punctuation">;</span>
 <span class="token keyword">int</span> oldValue <span class="token operator">=</span> <span class="token function">atomicCAS</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> expected<span class="token punctuation">,</span> expected <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// Loop while expected is incorrect.</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 expected <span class="token operator">=</span> oldValue<span class="token punctuation">;</span>
 oldValue <span class="token operator">=</span> <span class="token function">atomicCAS</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> expected<span class="token punctuation">,</span> expected <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>该函数的前三行和之前的相同。如果第一个atomicCAS失败了，那么myAtomicAdd就<br> 会循环执行直到atomicCAS最后的返回值与预期值不同。一旦条件失败，交换必须已经成<br> 功，并且myAtomicAdd退出循环。另一方面，预期值重置为最近读取的值并重试。为了匹<br> 配其他CUDA原子函数的语义，通过atomicCAS最近的返回值，myAtomicAdd也返回目标地<br> 址中的数值。</p></li><li><p>你可以从Wrox.com中下载my-atomic-add.cu程序，创建并运行这个程序的副本。如下<br> 建立：<code>$ nvcc –arch=sm_11 my-atomic-add.cu</code></p></li><li><p>下一节将会涵盖CUDA支持的原子函数，但不应局限于它们的使用，这是非常重要<br> 的。有了atomicCAS，你可以通过特定的应用程序执行所需的范围更广的原子操作。</p></li></ul><h4 id="_7-2-3-2-内置的cuda原子函数" tabindex="-1"><a class="header-anchor" href="#_7-2-3-2-内置的cuda原子函数" aria-hidden="true">#</a> 7.2.3.2 内置的CUDA原子函数</h4><ul><li><p>CUDA支持原子函数的集合。你可以使用何种子集取决于设备的计算能力。</p></li><li><p>原子函数支持始于计算能力1.1的设备。在这个级别，你将有对全局内存中32位数值<br> 操作函数访问的权限。</p></li><li><p>对共享内存中32位数值的操作和全局内存中64位数值的操作支持始于计算能力1.2的<br> 设备。对共享内存中64位数值的操作支持始于计算能力2.0的设备。</p></li><li><p>表7-6列出了CUDA支持的原子函数的原子操作，包括相关的CUDA设备函数和支持的<br> 数值类型。<br><img src="`+C+'" alt="table7-6" loading="lazy"></p></li></ul><h4 id="_7-2-3-3-原子操作的成本" tabindex="-1"><a class="header-anchor" href="#_7-2-3-3-原子操作的成本" aria-hidden="true">#</a> 7.2.3.3 原子操作的成本</h4>',15),en=l("<li><p>原子函数在一些应用中很有帮助且很有必要，但可能要付出很高的性能代价。导致这<br> 种局面的原因有如下几个方面：</p></li><li><p>1.当在全局或共享内存中执行原子操作时，能保证所有的数值变化对所有线程都是立<br> 即可见的。因此，在最低限度下，一个原子操作指令将通过任何方式进入到全局或共享内<br> 存中读取当前存储的数值而不需要缓存。如果原子指令操作成功，那么必须把实际需要的<br> 值写入到全局或共享内存中。</p></li><li><p>2.共享地址冲突的原子访问可能要求发生冲突的线程不断地进行重试，类似于运行多<br> 个myAtomicAdd循环的迭代。尽管内置原子函数建立过程的可见性是有限的，但对你所实<br> 现的任何自定义原子操作来说都是真实的。如果你的应用程序反复循环而致使I/O开销较<br> 大，相应地性能会降低。</p></li><li><p>3.当线程在同一个线程束中时必须执行不同的指令，线程束执行是序列化的。如果一<br> 个线程束中的多个线程在相同的内存地址发出一个原子操作，就会产生类似于线程冲突的<br> 问题。因为只有一个线程的原子操作可以成功，所以所有其他的线程必须重试。如果一个<br> 原子指令需要n个循环，并且需要同一线程束中的t个线程在相同的内存地址上执行该原子<br> 指令，那么运行的时间将会是t×n，因为每次重试时只有一个线程会成功。记住，线程束<br> 中剩下的那些线程会等待所有原子操作的完成，并且一个原子操作也意味着一个全局的读<br> 取和写入。</p></li>",4),pn=n("br",null,null,-1),tn={href:"http://xn--Wrox-z25fveu9a00y.xn--comatomic-ordering-m512aotr680i.cu",target:"_blank",rel:"noopener noreferrer"},on=n("br",null,null,-1),ln=n("br",null,null,-1),cn=n("br",null,null,-1),rn=n("code",null,"values_read[tid] = atomicAdd(shared_var, 1);",-1),un=n("li",null,[n("p",null,"在相同的共享变量上，unsafe核函数执行相同的加法，但并不使用原子函数。")],-1),dn=l(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>shared_var<span class="token punctuation">;</span>
<span class="token operator">*</span>shared_var <span class="token operator">=</span> old <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
values_read<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">=</span> old<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这意味着运行内核unsafe的线程正执行全局读取和写入并且没有任何机制来阻止线程<br> 之间的重写。因为两个核函数都存储目标地址中原来存储的数值，所以线程冲突可以被视<br> 为复制原来的值。一个示例的输出如下所示：</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>In total<span class="token punctuation">,</span> <span class="token number">30</span> runs <span class="token keyword">using</span> atomic operations took <span class="token number">3704</span> ms
 Using atomic operations also produced an output of <span class="token number">6400064</span>
In total<span class="token punctuation">,</span> <span class="token number">30</span> runs <span class="token keyword">using</span> unsafe operations took <span class="token number">11</span> ms
 Using unsafe operations also produced an output of <span class="token number">100001</span>
Threads performing atomic operations read values <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">17</span> <span class="token number">19</span> <span class="token number">21</span> <span class="token number">23</span> <span class="token number">33</span> <span class="token number">35</span>
Threads performing unsafe operations read values <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>性能上的差异很明显：使用atomics版本的运行时间是unsafe运行时间的300倍还要<br> 多。最终的输出说明不是所有在unsafe中执行的加法都会写入到全局内存中，许多是重写<br> 的并且永远不会被其他线程所读取。这些冲突在输出值的最后两行中表现得更明显。<br> atomics核函数中的线程有独有的增量值，而在unsafe核函数的前十个线程中每一个线程都<br> 是从0开始增大并全部写入相同的值：1。需要注意的是，一些在unsafe核函数中的加法结<br> 束了，因为最后的输出不是1，所以一些线程将结果成功地写入全局内存并将内存中原来<br> 的数值读回。</p></li><li><p>这个例子说明了当原子操作是必要的而不安全访问是一个选择项时，这将在很大程度<br> 上降低性能和正确性。当做这个决定时必须非常小心，并不推荐使用不安全访问，应当只<br> 有在能保证正确性的情况下才尝试使用不安全访问。</p></li></ul><h4 id="_7-2-3-4-限制原子操作的性能成本" tabindex="-1"><a class="header-anchor" href="#_7-2-3-4-限制原子操作的性能成本" aria-hidden="true">#</a> 7.2.3.4 限制原子操作的性能成本</h4><ul><li>幸运的是，当必须执行原子操作时，使用有些方法可以减少性能损失。你可以使用局<br> 部操作来增强全局原子操作，这些局部操作能从同一线程块的线程中产生一个中间结果。<br> 这需要使用本地较低延迟的资源，如shuffle指令或共享内存，在使用原子操作把局部结果<br> 结合到最终全局结果之前，需要先从每个线程块产生局部结果。当然，为使其有效，这些<br> 操作必须是可替换的（也就是说操作的顺序不能影响最后的结果）。图7-5展示了局部还<br> 原产生部分结果，然后是原子操作去计算最终的输出。<br><img src="`+D+`" alt="figure7-5" loading="lazy"></li></ul><h4 id="_7-2-3-5-原子级浮点支持" tabindex="-1"><a class="header-anchor" href="#_7-2-3-5-原子级浮点支持" aria-hidden="true">#</a> 7.2.3.5 原子级浮点支持</h4><ul><li><p>原子函数中要注意的一点是它们大多被声明在整型数值上操作，如int、unsigned int或<br> unsigned long long int。纵观所有原子函数，只有atomicExch和atomicAdd支持单精度浮点<br> 数。所有原子函数都不支持双精度数值的运算。所幸，如果你的应用程序需要管理多个线<br> 程访问共享浮点变量，那么有些方法可以让你实现自己的浮点原子操作。在高级别上，有<br> 一个办法是用一个变量中支持的类型存储浮点数的原始比特位，并使用所支持的类型执行<br> 原子CAS操作。</p></li><li><p>通过一个例子可以更直观地说明这一点。下面是一个用单精度浮点数实现的myAtomicAdd核函数：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>e<span class="token operator">-</span>precision fl oating<span class="token operator">-</span>point numbers<span class="token operator">:</span>
__device__ <span class="token keyword">float</span> <span class="token function">myAtomicAdd</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token keyword">float</span> incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// Convert address to point to a supported type of the same size</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>typedAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>address<span class="token punctuation">;</span>
 <span class="token comment">// Stored the expected and desired float values as an unsigned int</span>
 <span class="token keyword">float</span> currentVal <span class="token operator">=</span> <span class="token operator">*</span>address<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token function">__float2uint_rn</span><span class="token punctuation">(</span>currentVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> desired <span class="token operator">=</span> <span class="token function">__float2uint_rn</span><span class="token punctuation">(</span>currentVale <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> oldIntValue <span class="token operator">=</span> <span class="token function">atomicCAS</span><span class="token punctuation">(</span>typedAddress<span class="token punctuation">,</span> expected<span class="token punctuation">,</span> desired<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span> <span class="token punctuation">(</span>oldIntValue <span class="token operator">!=</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 expected <span class="token operator">=</span> oldIntValue<span class="token punctuation">;</span>
 <span class="token comment">/* 
 * Convert the value read from typedAddress to a float, increment,
 * and then convert back to an unsigned int
 */</span>
 desired <span class="token operator">=</span> <span class="token function">__float2uint_rn</span><span class="token punctuation">(</span><span class="token function">__uint2float_rn</span><span class="token punctuation">(</span>oldIntValue<span class="token punctuation">)</span> <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 oldIntValue <span class="token operator">=</span> <span class="token function">atomicCAS</span><span class="token punctuation">(</span>typedAddress<span class="token punctuation">,</span> expected<span class="token punctuation">,</span> desired<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> <span class="token function">__uint2float_rn</span><span class="token punctuation">(</span>oldIntValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这段代码中的大部分内容与之前的myAtomicAdd示例类似。主要的不同是atomicCAS<br> 数值转换的传入和传出，这个过程使用的是CUDA提供的各种类型的转换函数。这个特例<br> 使用了：<br> 1.一个cast改变了address指针的类型，使其从float型到unsigned int型。<br> 2.使用__float2uint_rn将期望值、<em>address、期望值以及</em>address＋incr的类型转换为包<br> 含相同比特位的unsigned int类型。<br> 3.如果操作失败了，使用__uint2float_rn检索一个从atomicCAS返回的unsigned int浮点<br> 数并计算新的期望值。</p></li><li><p>所有这些类型转换都是必要的，因为应用程序要求的类型（float）和atomicCAS函数<br> 要求的类型（unsigned int）是不同的。CUDA提供了一个有很大范围的有其他特定类型转<br> 换的函数，包括__double_as_longlong、__longlong_as_double、__double-2float_rn等。这些<br> 函数对实现CUDA中大范围的自定义浮点原子函数是很有用的。完整的列表可以在CUDA<br> Math API文档中找到。</p></li></ul><h4 id="_7-2-3-6-小结" tabindex="-1"><a class="header-anchor" href="#_7-2-3-6-小结" aria-hidden="true">#</a> 7.2.3.6 小结</h4><ul><li>本节对CUDA中原子操作的作用进行了深入的研究。其中包含原子操作在CUDA中的<br> 工作背景，CUDA中可用的各种原子操作，限制原子操作性能影响的方式和CUDA原子函<br> 数中所支持的浮点类型。表7-7总结了本节内容。<br><img src="`+w+'" alt="figure7-7" loading="lazy"></li></ul><h3 id="_7-2-4-综合范例" tabindex="-1"><a class="header-anchor" href="#_7-2-4-综合范例" aria-hidden="true">#</a> 7.2.4 综合范例</h3><ul><li><p>本节使用一个简单且有实际意义的例子：NBody，来将本章学习到的内容应用到一个<br> 简单的示例中。nbody.cu的代码可以从Wrox.com中下载。</p></li><li><p>如果你对NBody不是很熟悉的话，我可以告诉你的是，它就是一个普通的仿真基准。<br> 它模拟了一系列的粒子和它们之间的相互操作，如图7-6所示。NBody特别适用于GPU，<br> 并且有大量可用于较高版本GPU的NBody的文献介绍。所提供的示例代码不是基于这些研<br> 究的，而是用作一个例子来帮助你理解的。在仿真过程中NBody基于其他粒子所赋予的加<br> 速度，迭代更新每一个粒子的速度，随后基于新的速度更新每个粒子的位置。</p></li></ul><figure><img src="'+U+`" alt="figure7-6" tabindex="0" loading="lazy"><figcaption>figure7-6</figcaption></figure><ul><li><p>首先，考虑NBody.cu对原子操作的作用。NBody实现要进行两个全局统计：是否有任<br> 何粒子已经超过了相对于原点的某个距离，有多少粒子移动的速度比指定速度快。由于需<br> 要对超过阈值速度的粒子进行精确计数，所以应用程序必须利用原子操作以确保计数完全<br> 正确。但是，因为应用程序只需要知道是否有粒子与原点的距离超过了指定半径，所以可<br> 以用不安全访问来设立一个布尔类型的标志。</p></li><li><p>配置好nbody.cu以支持单精度和双精度浮点数值的使用，使它们可以存储粒子位置、<br> 速度和加速度。决定使用单精度还是双精度取决于编译时是否使用了预处理器宏。由于<br> nbody.cu默认使用单精度，所以在编译时，你可以通过在命令行添加-DSINGLE_PREC或<br> 者-DDOUBLE_PREC来显式地进行选择。例如，下面的示例是使用单精度浮点数NBody的<br> 编译和执行：</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>$ nvcc <span class="token operator">-</span>arch<span class="token operator">=</span>sm_20 <span class="token operator">-</span>DSINGLE_PREC –DVALIDATE nbody<span class="token punctuation">.</span>cu <span class="token operator">-</span>o nbody
$ <span class="token punctuation">.</span><span class="token operator">/</span>nbody
Using single<span class="token operator">-</span>precision floating<span class="token operator">-</span>point values
Running host simulation<span class="token punctuation">.</span> WARNING<span class="token punctuation">,</span> <span class="token keyword">this</span> might take a <span class="token keyword">while</span><span class="token punctuation">.</span>
Any points beyond bounds<span class="token operator">?</span> <span class="token boolean">true</span><span class="token punctuation">,</span> # points exceeded velocity <span class="token number">30262</span><span class="token operator">/</span><span class="token number">30720</span>
Total execution time <span class="token number">10569</span>
Error <span class="token operator">=</span> <span class="token number">5.48078840035512282469e+00</span>


双精度值可以使用以下命令配置和测试：
$ nvcc <span class="token operator">-</span>arch<span class="token operator">=</span>sm_20 <span class="token operator">-</span>DDOUBLE_PREC <span class="token operator">-</span>DVALIDATE nbody<span class="token punctuation">.</span>cu <span class="token operator">-</span>o nbody
$ <span class="token punctuation">.</span><span class="token operator">/</span>nbody
Using <span class="token keyword">double</span><span class="token operator">-</span>precision floating<span class="token operator">-</span>point values
Running host simulation<span class="token punctuation">.</span> WARNING<span class="token punctuation">,</span> <span class="token keyword">this</span> might take a <span class="token keyword">while</span><span class="token punctuation">.</span>
Any points beyond bounds<span class="token operator">?</span> <span class="token boolean">true</span><span class="token punctuation">,</span> # points exceeded velocity <span class="token number">30251</span><span class="token operator">/</span><span class="token number">30720</span>
Total execution time <span class="token number">60688</span>
Error <span class="token operator">=</span> <span class="token number">3.66473952850002815396e+00</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17),kn=n("br",null,null,-1),bn={href:"http://xn--floating-point-perf-9e93a973cvnbf11d3j9cnt8axi0f.cu",target:"_blank",rel:"noopener noreferrer"},mn=n("br",null,null,-1),vn=l('<p>1.由于双精度类型的长度是单精度类型的两倍，所以导致了双倍的主机-设备通信开销。<br> 2.由于从全局内存加载了两次数据，所以增加了设备上的I/O消耗。<br> 3.由于双精度浮点数相较于单精度来说，能存入寄存器的更少，同时每个线程块中每<br> 个线程可用资源的减少，潜在地导致了全局内存中有更多溢出变量。<br> 4.在两倍比特位上执行算术运算增加了计算成本。</p><ul><li><p>注意，上面的编译包含一个-DVALIDATE标志。在NBody中，这增加了一个针对结果<br> 数值精度的测试，它是通过比较CUDA输出和一个主机端的输出实现的。输出的错误结果<br> 是主机和设备端计算的粒子位置之间的平均差。双精度浮点数值的使用使精度有了一个明<br> 显的提高，但是，通过把默认标志传给CUDA编译器，CUDA和主机计算的数值之间仍然<br> 有很大的差异。</p></li><li><p>最后，还需要研究的一点是，当使用我们之前讨论过的编译器标志时，标准函数和内<br> 部函数的性能是如何变化的。回想表7-3中的--ftz，--prec-div，--prec-sqrt，以及——<br> fmad，每一个都可以影响性能和精度，并且当自动选择内部函数代替标准函数时，--<br> use_fast_math设置了所有最大化性能的选项。表7-8显示了在使用不同标志下的执行时间和<br> 数值错误，其中这些标志被设置用来最大化性能或精度。这些程序都使用了单精度数值参<br> 与执行。<br><img src="'+P+`" alt="table7-8" loading="lazy"></p></li><li><p>这些结果与预期的结果完全相吻合，并且证明了编译器标志使用的重要性。对于用来<br> 最大化性能的标志，总的执行时间提高了2.25倍。对于用来最大化精度的标志来说，它消<br> 除了主机实现时的数值偏差。</p></li></ul><h2 id="_7-3-总结" tabindex="-1"><a class="header-anchor" href="#_7-3-总结" aria-hidden="true">#</a> 7.3 总结</h2><ul><li><p>当建立一个CUDA应用程序时，你必须明白以下几点对性能和数值精度的影响：浮点<br> 型运算，标准和内部函数以及原子操作。【三大部分】</p></li><li><p>在本章中，对于怎样引导编译器指令生成核函数有了更详细的介绍。CUDA编译器和<br> 函数库通常隐藏了底层细节，这对于程序员来说是把双刃剑。自动编译器的优化减少了一<br> 些优化负担，但可能会导致内核中数据转化变为不可见。这种不透明性会导致数值问题调<br> 试困难。此外，如果对这些性能调节方案了解的不够全面，那么在程序优化时你可能想不<br> 出合适的方法。</p></li><li><p>通过本章描述的理论方法，你将对优化应用程序的性能、精度和正确性有了更好的准<br> 备。NBody例子说明了与以下内容相关的性能提升：</p><ul><li>单精度和双精度浮点数运算</li><li>内部函数和标准函数</li><li>原子级访问和不安全访问</li></ul></li><li><p>这些内容可以帮助你充分利用GPU的计算吞吐量，且不以牺牲应用程序的正确性为代<br> 价。接下来，你将要学习如何通过CUDA加速库和基于OpenACC指令的编译器来提高编程<br> 效率。</p></li></ul><h2 id="_7-4-习题" tabindex="-1"><a class="header-anchor" href="#_7-4-习题" aria-hidden="true">#</a> 7.4 习题</h2><ul><li><p>1.将下列运算转化为调用双精度内部函数__fma_rn。然后试着使用相同的操作调用<br> __dmul_rn和__dmul_rn：：<br><code>a * b + c * d + e * f * g</code></p></li><li><p>2.写一个程序，给定一个单精度浮点值，计算下一个最大和最小的单精度浮点值，使<br> 其可以使用相同的存储类型来正确表示。使用单精度和双精度类型执行相同的操作并比较<br> 结果。你能列出一些单精度表示更准确数值的示例吗？如果不能，你仍然认为它们是存在<br> 的吗？</p></li><li><p>3.你已经知道了来自多个线程的不安全访问会导致不可预知的结果。你也已经知道了<br> 不安全访问需要有一些保证（如果每一个线程执行写一个1的操作，那么最后的数值不会<br> 变为其他内容）。考虑以下代码片段：</p><ul><li>如果一个线程运行这个应用程序，期望输出结果为5，那么，如果5个线程并行地<br> 执行相同的循环呢？n的最大值和最小值是什么？很明显最大值是：25，通过5个线程的5<br> 个增量。关于可能的最小值推理起来较难。提示：n可以小于5，但你需要弄清楚原因。后<br> 续，当并行运行时，你将如何使用原子指令和局部归约来优化这段代码的性能？</li></ul></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> tmp <span class="token operator">=</span> n<span class="token punctuation">;</span>
 tmp <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
 n <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>4.基于myAtomicAdd实例，基于atomicCAS实现一个自定义myAtomiMin设备函数。</p></li><li><p>5.基于单精度浮点型myAtomicAdd示例，通过使用atomicCAS实现原子双精度浮点型<br> 加法。</p></li><li><p>6.本章中的示例都使用了位于全局内存位置上的原子操作。对计算能力为1.2以上的<br> GPU来说，共享内存空间支持CUDA 32位原子操作。根据你在第5章学到的关于共享内存<br> 冲突的内容，在共享内存中使用原子指令的时候你还发现了哪些问题？</p></li><li><p>7.试着在有无--use_fast_math编译器标志的情况下，编译nbody.cu到PTX，生成的指令<br> 数有什么变化？</p></li><li><p>8.在nbody.cu中，用第5章中基于reduceSmemShfl的优化并行归约函数来代替atomicAdd<br> 的使用。值得注意的是你仍然要使用atomicAdd来操作聚集结果，这会影响性能吗？为什<br> 么会或为什么不会？</p></li><li><p>9.在创建nbody.cu时，试着切换编译器标志。你能找到比示例中所提供的性能更好的<br> 方法吗？为什么性能会提高？你能在平衡性能和数值精度的优化标志位中，找到一个中间<br> 点吗？</p></li><li><p>10.重写nbody.cu使其直接调用内部函数，无须指定--use_fast_math。你所写的显式调用<br> 内部函数的程序和所提供的设置了--use_fast_math代码相比，由nbody.cu生成的PTX有什么<br> 不同？记住其他由--use_fast_math产生的优化。你能手动编写一个与使用--use_fast_math功<br> 能相同的nbody.cu程序吗？如果不能，比较一下PTX指令的数量，思考你能做到什么程度。</p></li></ul>`,8);function _n(fn,hn){const p=r("router-link"),i=r("CodeTabs"),c=r("ExternalLinkIcon");return d(),k("div",null,[I,M,b(" more "),n("nav",E,[n("ul",null,[n("li",null,[e(p,{to:"#简单介绍主要是基础"},{default:a(()=>[s("简单介绍主要是基础")]),_:1})]),n("li",null,[e(p,{to:"#第7章-调整指令级原语"},{default:a(()=>[s("第7章 调整指令级原语")]),_:1})]),n("li",null,[e(p,{to:"#_7-1-cuda指令概述"},{default:a(()=>[s("7.1 CUDA指令概述")]),_:1}),n("ul",null,[n("li",null,[e(p,{to:"#_7-1-1-浮点指令"},{default:a(()=>[s("7.1.1 浮点指令")]),_:1})]),n("li",null,[e(p,{to:"#_7-1-2-内部函数和标准函数"},{default:a(()=>[s("7.1.2 内部函数和标准函数")]),_:1})]),n("li",null,[e(p,{to:"#_7-1-3-原子操作指令"},{default:a(()=>[s("7.1.3 原子操作指令")]),_:1})])])]),n("li",null,[e(p,{to:"#_7-2-程序优化指令"},{default:a(()=>[s("7.2 程序优化指令")]),_:1}),n("ul",null,[n("li",null,[e(p,{to:"#_7-2-1-单精度与双精度的比较"},{default:a(()=>[s("7.2.1 单精度与双精度的比较")]),_:1})]),n("li",null,[e(p,{to:"#_7-2-2-标准函数与内部函数的比较"},{default:a(()=>[s("7.2.2 标准函数与内部函数的比较")]),_:1})]),n("li",null,[e(p,{to:"#_7-2-3-了解原子指令"},{default:a(()=>[s("7.2.3 了解原子指令")]),_:1})]),n("li",null,[e(p,{to:"#_7-2-4-综合范例"},{default:a(()=>[s("7.2.4 综合范例")]),_:1})])])]),n("li",null,[e(p,{to:"#_7-3-总结"},{default:a(()=>[s("7.3 总结")]),_:1})]),n("li",null,[e(p,{to:"#_7-4-习题"},{default:a(()=>[s("7.4 习题")]),_:1})])])]),V,n("details",G,[N,e(i,{id:"186",data:[{id:"demo1"},{id:"demo2"}],"tab-id":"shell"},{title0:a(({value:t,isActive:o})=>[s("demo1")]),title1:a(({value:t,isActive:o})=>[s("demo2")]),tab0:a(({value:t,isActive:o})=>[T]),tab1:a(({value:t,isActive:o})=>[q]),_:1})]),z,n("details",B,[L,e(i,{id:"464",data:[{id:"demo1"},{id:"demo2"}],"tab-id":"shell"},{title0:a(({value:t,isActive:o})=>[s("demo1")]),title1:a(({value:t,isActive:o})=>[s("demo2")]),tab0:a(({value:t,isActive:o})=>[W]),tab1:a(({value:t,isActive:o})=>[$]),_:1})]),F,n("ul",null,[X,Z,n("li",null,[n("p",null,[s("既然已经知道了启用或禁用FMAD优化给指令级带来的变化，你就可以观察到这些变"),R,s(" 化对数值精度的影响。你可以从Wrox.com下载fmad.cu示例，创建并运行相关程序。这个"),O,s(" 示例使用标准函数在主机和设备上各运行一个MAD操作。用不同的--fmad标志值编译"),H,n("a",K,[s("fmad.cu"),e(c)]),s("，可以将是否有MAD优化的CUDA内核运行结果和主机的基准值进行对比。"),j,J])])]),n("details",Q,[Y,e(i,{id:"586",data:[{id:"demo1"},{id:"demo2"}],"tab-id":"shell"},{title0:a(({value:t,isActive:o})=>[s("demo1")]),title1:a(({value:t,isActive:o})=>[s("demo2")]),tab0:a(({value:t,isActive:o})=>[nn]),tab1:a(({value:t,isActive:o})=>[sn]),_:1})]),an,n("ul",null,[en,n("li",null,[n("p",null,[s("为了探索原子操作指令，需要研究一些简单的例子。首先，对原子操作与不安全访问"),pn,s(" 间的行为和性能的比较是很有趣的。"),n("a",tn,[s("你可以从Wrox.com中下载atomic-ordering.cu"),e(c)]),s("，创建并"),on,s(" 运行相关程序。这个小应用程序包含了两个核函数，分别叫作atomics和unsafe。在一个共"),ln,s(" 享变量上，atomics核函数在每个线程上执行原子加法，保存目标地址中原来存储的数值。"),cn,rn])]),un]),dn,n("ul",null,[n("li",null,[s("注意，当使用双精度浮点值时，总的执行时间减少到1/6。这对于提高精度来说是一"),kn,s(" 个很高的代价，但是在很多应用程序中这是必需的。"),n("a",bn,[s("回想之前分析的floating-point-perf.cu"),e(c)]),mn,s(" 例子可知，造成这种速度减慢的原因主要有以下几个方面：")])]),vn])}const yn=u(S,[["render",_n],["__file","G-第七章.html.vue"]]);export{yn as default};
