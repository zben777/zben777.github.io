import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as t,c as o,d as r,a as l,e as i,w as a,b as e,f as S}from"./app-2a2d189a.js";const c={},u=l("h1",{id:"a-第1章shell概述",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#a-第1章shell概述","aria-hidden":"true"},"#"),e(" A-第1章Shell概述")],-1),p=l("p",null,"A-第1章Shell概述",-1),d=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),_={class:"table-of-contents"},b=S('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="a-第1章shell概述-1" tabindex="-1"><a class="header-anchor" href="#a-第1章shell概述-1" aria-hidden="true">#</a> A-第1章Shell概述</h2><ul><li><p>接下来要介绍的是 Linux 学习中非常重要的一个扩展，即所谓的 Shell 编程。</p></li><li><p>关于 Shell 这一概念，在之前的学习过程中已反复接触到。之前介绍的各种 Linux 命令，其实都是在当前 Shell 的命令行控制台里执行的。所以，之前已经了解过 Shell 的用法，接下来还是重新回顾一下基本概念，以深刻理解 Shell 到底是什么。</p></li><li><p>可以借助经典的图来回顾 Shell 的概念。首先，计算机系统最底层是一些硬件，如 CPU、内存、IO 设备。本质上，进行编程和操作的过程最终都要转化为对硬件的操作指令。真正能够操作硬件的是操作系统，操作系统的核心部分，即李纳斯大神发布的 Linux 版本，就是所谓的 Linux 内核，这是整个操作系统的核心，可直接操作硬件。但内核对用户不太友好，一般用户使用的是外层应用程序，包括文本编辑器、浏览器、数据库以及图形化桌面（如 GNOME ）等，这些都可视为操作系统的一部分，不过属于较外层的部分。</p></li><li><p>会发现，外层的应用程序，用户可直接操作，比如在桌面点击文件夹查看内容，此操作 Linux 内核无法直接理解，甚至像底层的“LS”命令，内核也无法理解，因为内核能理解的是对计算机底层硬件（如 CPU 、内存）的操作。所以，两者语言不通，需要一个“翻译官”搭建交流桥梁。</p></li><li><p>谁来充当这个“翻译官”呢？中间有一个解释层，即所谓的 Shell 。这个词本身有“外壳”之意，这里的“外壳”相当于包在内核外面的一层壳，是底层操作系统核心与外部应用的接口，有了它就能进行翻译和解释，将外部操作的命令解释为内核可执行的指令。所以，本质上得出结论，Shell 是一个命令行解释器，并且提供了一个交互式的文本命令行界面（控制台），打开控制台后，可远程连接，一行一行输入命令。Shell 终端控制台接收命令后，会进行各种解释，调用相应程序，然后向操作系统内核发起请求，由操作系统内核执行。整个过程中，Shell 起到的是连接桥梁和翻译官的作用。</p></li><li><p>大部分情况下，如果要在 Linux 系统上执行操作，会发现都是基于 Shell 。即便使用应用程序，本质上也是通过 Shell 翻译。所以，用户一般可使用 Shell ，打开命令行，一行一行输入命令，输入一行就解释一行，再由操作系统内核执行。</p></li><li><p>已知在 Linux 系统中，不仅能在控制台一句一句执行，还能把很多命令串起来写入一个文件，然后将这个文件交给 Linux 系统直接执行，最后也是交给 Shell 执行。这样的可执行文件，也是一行一行解释执行的，可称之为脚本。平常所说的脚本语言、脚本编程，就是这种方式，本质上是一行一行解释执行。</p></li><li><p>既然如此，会想到 Shell 不仅有一堆能在控制台一行一行输入的命令，还能撰写复杂流程，写成脚本文件，甚至有各种语法定义，能进行复杂的流程控制，就像一门编程语言。接下来要学习的扩展内容，就是把 Shell 当成功能强大的编程语言进行系统性学习。作为编程语言，灵活性很强。</p></li><li><p>要知道，如果从事 Linux 运维工作，运维工程师经常需要编写 Shell 脚本进行服务器管理和维护。如果是普通开发人员，有时也面临维护服务器或管理数据库的需求，比如定时往数据库备份或写入数据。数据库通常在服务器上，服务器操作系统是 Linux ，此时就必须了解在 Linux 上进行 Shell 编程，执行定时操作的流程。之前讲过 cronTab ，可用 Linux 基本命令和定时命令操作，流程更复杂时，单独的命令无法解决，就需要写脚本。对于大数据应用场景更是如此，机器多构成集群，管理集群往往需要写脚本维护。所以，Shell 编程在实际应用中非常有用。</p></li><li><p>其实，对于 Linux 而言，Shell 有多种实现。可在当前配置文件中查看当前系统支持的 Shell 解析器，切换查看“cat /etc/shells ”，能看到当前支持的 Shell ，有“sh ”（明显是 Shell 的前两个字母），还有“bash ”，另外还有“/usr/bin ”目录下的“sh ”和“bash ”，它们明显是指向“/usr/bin ”下的链接。此外，还有“tcsh ”“csh ”，这也是常见的 Shell 解析器，可将其视为 Shell 的具体实现。</p></li><li><p>这里要介绍的是，最初的 Shell 版本来源于 Unix ，叫“Bourne Shell （Bourne sh ）”，此版本能进行灵活编程操作，但与用户交互稍差。后来基于此发展出了“bash ”（Bourne Again Shell ），在之前基础上扩展了很多功能。目前大部分 Linux 发行版默认的 Shell 都是“bash Shell ”。当前的红帽系就是“bash Shell ”，而 Debian 系（比如 Ubuntu ），默认的 Shell 不是“bash ”也不是“csh ”，而是“Dash ”，有时可能会看到这种 Shell 解析器的具体实现。其实它们大同小异，就像不同的 Linux 发行版。</p></li><li><p>在系统里也能直接查看当前默认的 Shell 是什么，比如“ls -l ”查看“/bin ”目录下的内容，然后“grep ”一下“Shell ”，或者直接“grep ”“bash ”，能看得很明显，会看到“sh ”默认连接到“bash ”，所以很显然，CentOS 7 红帽系默认的解析器是“bash ”。另外，也可直接“echo ”一个当前的环境变量“$SHELL ”，默认就是“/bin/bash ”。</p></li><li><p>无论从哪个角度看，当前学习的 Shell 编程以及在命令行输入命令执行时，基于的都是“bash ”。查看进程，也是一个“bash ”进程。这是对 Shell 的整体介绍，更多的是知识回顾。有了这个基础，接下来就可以真正使用 Shell 进行编程了。</p></li></ul>',4);function x(L,f){const h=s("router-link");return t(),o("div",null,[u,p,r(" more "),d,l("nav",_,[l("ul",null,[l("li",null,[i(h,{to:"#概述框架"},{default:a(()=>[e("概述框架")]),_:1})]),l("li",null,[i(h,{to:"#a-第1章shell概述-1"},{default:a(()=>[e("A-第1章Shell概述")]),_:1})])])]),b])}const B=n(c,[["render",x],["__file","A-第1章Shell概述.html.vue"]]);export{B as default};
