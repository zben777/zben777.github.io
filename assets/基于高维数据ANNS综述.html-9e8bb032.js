import{_ as m}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as h,d as c,a as s,b as a,e as t,w as n,f as l}from"./app-2a2d189a.js";const p="/assets/figure1-d4ac6fd7.png",g="/assets/table1-5f76488a.png",u="/assets/figure2-1a585182.png",d="/assets/table2-04c3c7d6.png",y="/assets/figure3-b91ec295.png",x="/assets/figure4-6d4f9606.png",w="/assets/table3-93430cb8.png",v="/assets/figure5-b58ba33f.png",f="/assets/figure6-c2896d87.png",b="/assets/table4-7d742f5a.png",N="/assets/figure7-40e4d7fa.png",S="/assets/figure8-ad32c6bb.png",G="/assets/table5-bdbd6ec5.png",k="/assets/figure10-74394819.png",M="/assets/table6-75fbf1ba.png",_="/assets/figure9-357ab457.png",z="/assets/table7-5cb92480.png",A={},C=s("h1",{id:"基于高维数据anns综述",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#基于高维数据anns综述","aria-hidden":"true"},"#"),a(" 基于高维数据ANNS综述")],-1),T=s("p",null,"基于高维数据ANNS综述",-1),L={class:"hint-container info"},D=s("p",{class:"hint-container-title"},"相关信息",-1),H=s("li",null,"可能这里要有一些 关于 其它的对于这篇文章的解读",-1),E=s("li",null,"我们需要一些链接？",-1),q=s("li",null,"blog:",-1),P={href:"https://zhuanlan.zhihu.com/p/610454162",target:"_blank",rel:"noopener noreferrer"},I={class:"table-of-contents"},K=l('<h2 id="一、简单介绍" tabindex="-1"><a class="header-anchor" href="#一、简单介绍" aria-hidden="true">#</a> 一、简单介绍</h2><ul><li><mark>总结</mark></li><li></li></ul><h2 id="no-0-abstract" tabindex="-1"><a class="header-anchor" href="#no-0-abstract" aria-hidden="true">#</a> No.0 <strong>ABSTRACT</strong></h2><ul><li><p>近似最近邻搜索（ANNS）在许多应用程序中构成了一个重要的操作，包括推荐系统、信息检索和模式识别。在过去的十年中，基于图的ANNS算法一直是这个领域的领先范式，并提出了数十种基于图的ANNS算法。这些算法旨在为给定查询检索最近邻提供有效、高效的解决方案。然而，这些努力的重点是用不同的方法来开发和优化算法，因此确实需要对这些方法的相对性能、优势和缺陷进行全面的调查。因此，在这里，我们通过一个新的分类法和<mark>精细的流程(fine-grained pipeline)</mark>，对13种具有代表性的基于图的ANNS算法进行了全面的比较分析和实验评估。我们在8个真实数据集和12个不同大小和特征的合成数据集的统一测试环境中比较了每种算法。我们的研究产生了新颖的发现，提供了几个有用的原则来改进算法，从而设计出一种优于最先进算法的优化方法。。这项努力也帮助我们精确定位了算法的有效工作部分，以及关于有前景的研究方向和适合不同领域的从业者的算法的经验法则建议。</p></li><li><p>Approximate nearest neighbor search (ANNS) constitutes an important operation in a multitude of applications, including recommendation systems, information retrieval, and pattern recognition.</p></li><li><p>In the past decade, graph-based ANNS algorithms have been the leading paradigm in this domain, with dozens of graph-based ANNS algorithms proposed. Such algorithms aim to provide effective, efficient solutions for retrieving the nearest neighbors for a given query.</p></li><li><p>Nevertheless, these efforts focus on developing and optimizing algorithms with different approaches, so there is a real need for a comprehensive survey about the approaches’ relative performance, strengths, and pitfalls.</p></li><li><p>Thus here we provide a thorough comparative analysis and experimental evaluation of 13 representative graph-based ANNS algorithms via a new taxonomy and fine-grained pipeline. 一个新的分类方法和 精细的流程</p></li><li><p>We compared each algorithm in a uniform test environment on eight real-world datasets and 12 synthetic datasets with varying sizes and characteristics. Our study yields novel discoveries, offerings several useful principles to improve algorithms, thus designing an optimized method that outperforms the state-of-the-art algorithms. This effort also helped us pinpoint algorithms’ working portions, along with rule-of-thumb recommen dations about promising research directions and suitable algorithms for practitioners in different fields.</p></li></ul><h2 id="no-1-introduction" tabindex="-1"><a class="header-anchor" href="#no-1-introduction" aria-hidden="true">#</a> No.1 <strong>INTRODUCTION</strong></h2><ul><li></li><li><p>最近邻搜索（NNS）是各种应用领域（如信息检索[34, 118]、模式识别[29, 57]、数据挖掘[44, 47]、机器学习[24, 28]和推荐系统[69, 82]）中的一个基本构建模块[7, 8, 38, 67, 70, 80, 108, 117]。随着数据集规模的爆炸式增长以及不可避免的维度诅咒，准确的 NNS 无法满足效率和成本方面的实际要求[61]。因此，大量文献都集中在研究近似最近邻搜索（ANNS）并找到一种能在大幅提高效率的同时适度放宽精度约束的算法（一种准确性与效率的权衡[59]）。</p></li><li><p>Nearest Neighbor Search (NNS) is a fundamental building block in various application domains [7, 8, 38, 67, 70, 80, 108, 117], such as information retrieval [34, 118], pattern recognition [29, 57], data mining [44, 47], machine learning [24, 28], and recommendation systems [69, 82].</p></li><li><p>With the explosive growth of datasets’ scale and the inevitable <em>curse of dimensionality</em>, accurate NNS cannot meet actual requirements for efficiency and cost [61]. Thus, much of the literature has focused on efforts to research approximate NNS (ANNS) and find an algorithm that improves efficiency substantially while mildly relaxing accuracy constraints (an accuracy-versus efficiency tradeoff [59]).</p></li><li><p>近似最近邻搜索（ANNS）是一项任务，什么任务呢？就是通过精心设计的索引然后在高维数据集中为查询找到近似最近邻的任务(设计索引然后为query找到在高纬数据集上的最近邻的任务)。根据所采用的设计的索引，现有的近似最近邻搜索算法可以分为四大类：基于哈希的[40, 45]；基于树的[8, 86]；基于量化的[52, 74]；以及基于图的[38, 67]算法。最近，基于图的算法已成为近似最近邻搜索的一种非常有效高效的选择[6, 10, 41, 75]。由于基于图的近似最近邻搜索算法在表达邻域邻居关系方面具有非凡的能力[38, 103]，它们只需要评估数据集中较少的点就能获得更准确的结果[38, 61, 67, 72, 112]。(???/???)</p></li><li><p>ANNS is a task that finds the approximate nearest neighbors among a high-dimensional dataset for a query via a well-designed index. According to the index adopted, the existing ANNS algorithms can be divided into four major types: hashing-based [40, 45]; tree-based [8, 86]; quantization-based [52, 74]; and graph-based [38,67] algorithms.</p></li><li><p>Recently, graph-based algorithms have emerged as a highly effective option for ANNS [6, 10, 41, 75]. Thanks to graph based ANNS algorithms’ extraordinary ability to express neighbor relationships [38, 103], they only need to evaluate fewer points of dataset to receive more accurate results [38, 61, 67, 72, 112].</p></li><li><p>如图 1 所示，基于图的近似最近邻搜索算法在原始数据集（图 1(a)）上构建一个图索引（图 1(b)），图中的顶点对应于原始数据集中的点，相邻顶点（标记为 x、y）通过评估它们的距离 δ(x,y)用边关联，其中 δ 是一个距离函数。在图 1(b)中，与黑色顶点相连的四个顶点（编号 1 到 4）是它的邻居，黑色顶点可以沿着这些边访问其邻居。给定这个图索引和一个查询 q（红色星号），近似最近邻搜索目的是得到一组接近 q 的顶点。</p></li><li><p>我们以返回 q 的最近邻为例来展示近似最近邻搜索的一般过程：最初，选择一个种子顶点（黑色顶点，可以随机抽样或通过其他方法获得[47, 67]）作为结果顶点 r，我们可以从这个种子顶点进行近似最近邻搜索。具体来说，如果 δ(n,q) &lt; δ(r,q)，其中 n 是 r 的一个邻居，r 将被 n 替换。我们重复这个过程直到满足终止条件（例如，对于所有的 n，δ(n,q)≥δ(r,q)），最终的 r（绿色顶点）就是 q 的最近邻。与其他索引结构相比，基于图的算法在准确性与效率方面被证明是一种优越的权衡[10, 38, 61, 65, 67]，这可能就是为什么它们如今在高科技公司中得到广泛应用（例如，微软[98, 100]、阿里巴巴[38, 112]和雅虎[47, 48, 89]）。</p></li><li><p>As Figure 1 shows, graph-based ANNS algorithms build a graph index (Figure 1(b)) on the original dataset (Figure 1(a)), the vertices in the graph correspond to the points of the original dataset, and neighboring vertices (marked as <em>𝑥</em>, <em>𝑦</em>) are associated with an edge by evaluating their distance <em>𝛿</em> (<em>𝑥, 𝑦</em>), where <em>𝛿</em> is a distance function. In Figure 1(b), the four vertices (numbered 1–4) connected to the black vertex are its neighbors, and the black vertex can visit its neighbors along these edges. Given this graph index and a query <em>𝑞</em> (the red star), ANNS aims to get a set of vertices that are close to <em>𝑞</em>.</p></li><li><p>We take the case of returning <em>𝑞</em>’s nearest neighbor as an example to show ANNS’ general procedure:</p><ul><li>Initially, a seed vertex (the black vertex, it can be randomly sampled or obtained by additional approaches [47, 67]) is selected as the result vertex <em>𝑟</em>, and we can conduct ANNS from this seed vertex.</li><li>Specifically, if <em>𝛿</em> (<em>𝑛, 𝑞</em>) <em>&lt;</em> <em>𝛿</em> (<em>𝑟, 𝑞</em>), where <em>𝑛</em> is one of the neighbors of <em>𝑟</em>, <em>𝑟</em> will be replaced by <em>𝑛</em>. We repeat this process until the termination condition (e.g., ∀<em>𝑛, 𝛿</em> (<em>𝑛, 𝑞</em>) ≥ <em>𝛿</em> (<em>𝑟, 𝑞</em>)) is met, and the final <em>𝑟</em> (the green vertex) is <em>𝑞</em>’s nearest neighbor.</li><li>Compared with other index structures, graph-based algorithms are a proven superior tradeoff in terms of accuracy versus efficiency [10, 38, 61, 65, 67], which is probably why they enjoy widespread use among high-tech companies nowadays (e.g., Microsoft [98, 100], Alibaba [38, 112], and Yahoo [47, 48, 89]).</li></ul></li></ul><figure><img src="'+p+'" alt="figure1" tabindex="0" loading="lazy"><figcaption>figure1</figcaption></figure><h3 id="_1-1-motivation" tabindex="-1"><a class="header-anchor" href="#_1-1-motivation" aria-hidden="true">#</a> 1.1 Motivation</h3><ul><li><p>在文献中，高维大规模数据上(高纬+大规模)基于图的近似最近邻搜索问题已经得到了深入研究[38]。已经有数十种算法从不同的优化角度被提出以解决这个问题[36, 37, 43, 54, 65, 67, 72]。对于这些算法，现有的综述[10, 61, 85]提供了一些有意义的探索。然而，它们局限于关于算法、数据集和度量的一小部分，并且是从宏观角度研究算法，而对算法内部组件的分析和评估被忽略了。例如，[61]包含了一些基于图的算法（仅有三个），[10]侧重于效率与准确性的权衡，[85]只考虑了几个经典的图。这促使我们通过一种新的分类法和微观角度（即一些细粒度的组件）对现有的基于图的算法进行全面的比较分析和实验评估。我们详细说明了随之而来的现有工作的问题。</p></li><li><p>The problem of graph-based ANNS on high-dimensional and large scale data has been studied intensively across the literature [38]. Dozens of algorithms have been proposed to solve this problem from different optimizations [36, 37, 43, 54, 65, 67, 72]. For these algorithms, existing surveys [10, 61, 85] provide some meaningful explorations. However, they are limited to a small subset about algorithms, datasets, and metrics, as well as studying algorithms from a macro perspective, and the analysis and evaluation of intraalgorithm components are ignored. 算法内部的组件给忽略了？</p></li><li><p>For example, [61] includes a few graph-based algorithms (only three), [10] focuses on efficiency vs accuracy tradeoff, [85] only considers several classic graphs. This motivates us to carry out a thorough comparative analysis and experimental evaluation of existing graph-based algorithms via a new taxonomy and micro perspective (i.e., some fine-grained components). We detail the issues of existing work that ensued.新的分类方法。和 微观的角度 即从。fine-grained components;</p></li></ul><br><ul><li><p><mark>问题 1：缺乏合理的算法间分类法和比较分析</mark></p></li><li><p>其他领域的许多研究表明，有见地的分类法可以作为该领域有前途研究的指导方针[99,102,105]。因此，需要建立一个合理的分类法，以指出基于图的算法的不同方向（第 3 节）(???/???)。现有的基于图的近似最近邻搜索算法的“索引”通常是从不同角度对四个经典基本图的衍生，即德劳内图（DG）[35]、相对邻域图（RNG）[92]、k 最近邻图（KNNG）[75]和最小生成树（MST）[58]。一些有代表性的近似最近邻搜索算法，如 KGraph[31]、HNSW[67]、DPG[61]、SPTAG[27]，可以分为基于 KNNG（KGraph 和 SPTAG）和基于 RNG（DPG 和 HNSW）的两类，它们基于所依赖的基本图进行工作。在这种分类下，我们可以指出同一类别或不同类别算法之间的差异，从而提供全面的算法间分析。</p></li><li><p>Many studies in other fields show that an insightful taxonomy can serve as a guideline for promising research in this domain[99, 102, 105]. Thus, a reasonable taxonomy needs to be established, to point to the different directions of graph-based algorithms (<strong>§3</strong>).</p></li><li><p>The index of existing graph-based ANNS algorithms are generally derivatives of four classic base graphs from different perspectives, i.e., Delaunay Graph (DG) [35], Relative Neighborhood Graph (RNG) [92], K-Nearest Neighbor Graph (KNNG) [75], and Minimum Spanning Tree (MST) [58].</p></li><li><p>Some representative ANNS algorithms, such as KGraph [31], HNSW [67], DPG [61], SPTAG [27] can be categorized into KNNG-based (KGraph and SPTAG) and RNG-based (DPG and HNSW) groups working off the base graphs upon which they rely.</p></li><li><p>Under this classification, we can pinpoint differences between algorithms of the same category or different categories, to provide a comprehensive inter-algorithm analysis</p></li><li><p><mark>问题 2：算法内部细粒度组件的分析和评估缺失</mark></p></li><li><p>许多研究仅从两个粗粒度(coarse-grained)组件，即构建和搜索(construction and search)[79,85]对基于图的近似最近邻搜索算法进行比较和分析，这阻碍了对关键组件的深入了解。然而，构建和搜索可以分为许多细粒度(fine-grained)组件，如候选邻居获取(candidate neighbor acquisition)、邻居选择(neighbor selection) [37 , 38 ]、种子获取(seed acquisition) [ 9, 36 ] 和路由选择(routing)[14,94]（我们在第 4 节中讨论这些组件的细节）。对这些细粒度组件的评估（第 5 节）导致了一些有趣的现象。例如，一些算法的性能提升对于它们在论文中声称的主要贡献（对一个组件的优化）并不那么显著，而是通过对另一个组件的另一个小优化（例如 NSSG[37]）。此外，完全不同的算法的关键性能可能由同一个细粒度组件主导（例如 NSG[38]和 HNSW[67]的邻居选择）。通过详细分析这些组件来明确算法的哪一部分在实践中起主要起作用，从而会出现这种不寻常但关键的发现，这有助于研究人员进一步确定优化目标。</p></li><li><p>Many studies only compare and analyze graph-based ANNS algorithms from two coarse-grained components, i.e., construction and search [79, 85], which hinders in sight into the key components. Construction and search, however, can be divided into many fine-grained components such as</p><ul><li><em>candidate neighbor acquisition</em>,</li><li><em>neighbor selection</em> [37, 38],</li><li><em>seed acquisition</em> [9, 36], and</li><li><em>routing</em> [14, 94] (we discuss the details of these components in <strong>§4</strong>).</li></ul></li><li><p>Evaluating these fine-grained components (<strong>§5</strong>) led to some interesting phenomena.</p></li><li><p>For example, some algorithms’ performance improvements are not so remarkable for their claimed major contribution (optimization on one component) in the paper, but instead by another small optimization for another component (e.g., NSSG [37]).</p></li><li><p>Additionally, the key performance of completely different algorithms may be dominated by the same fine-grained component (e.g., the <em>neighbor selection</em> of NSG [38] and HNSW [67]).</p></li><li><p>Such unusual but key discoveries occur by analyzing the components in detail to clarify which part of an algorithm mainly works in practice, thereby assisting researchers’ further optimization goals.</p></li><li><p><mark>问题 3：评估基于图的近似最近邻搜索算法的整体性能需要更丰富的指标</mark></p></li><li><p>许多对基于图的算法的评估主要集中在准确性与效率的权衡上[43,64,65]，这主要反映了相关算法的搜索性能[59]。随着数据规模的爆炸式增长以及更新需求的日益频繁，索引构建效率(时间)和算法的索引规模大小(存储)受到了越来越多的关注[112]。相关指标如图的质量（可以通过图上与最近邻相连的顶点百分比来衡量==指的是GT？）[21]、平均出度等等间接影响索引构建效率和索引大小，因此它们对于索引性能的全面分析至关重要。从我们大量的实验（详情见第 5 节）中，我们有了一个新的发现：更高的图质量并不一定能实现更好的搜索性能。例如，在 GIST1M 数据集[1]上，HNSW[67]和 DPG[61]的搜索性能相似。然而，就图质量而言，HNSW（63.3%）显著低于 DPG（99.2%）（第 5 节）。请注意，DPG 在索引构建过程中花费了大量时间来提高图质量，但这是不必要的；这种情况并不少见，我们在[31,36-38]中也看到了类似情况。</p></li><li><p>Many evaluations of graph-based algorithms focus on the tradeoff of accuracy vs efficiency [43, 64, 65], which primarily reflects related algorithms’ search performance [59]. With the explosion of data scale and increasingly frequent requirements to update, the index construction efficiency and algorithm’s index size have received more and more attention [112]. 构建时间和内存</p></li><li><p>Related metrics such as graph quality (it can be measured by the percentage of vertices that are linked to their nearest neighbor on the graph) [21], average out-degree, and so on indirectly affect the index construction efficiency and index size, so they are vital for comprehensive analysis of the index performance. 这个说的各种情景，</p></li><li><p>From our abundance of experiments (see <strong>§5</strong> for details), we gain a novel discovery: higher graph quality does not necessarily achieve better search performance. For instance, HNSW [67] and DPG [61] yield similar search performances on the GIST1M dataset [1]. However, in terms of graph quality, HNSW (63.3%) is significantly lower than DPG (99.2%) (<strong>§5</strong>).</p></li><li><p>Note that DPG spends a lot of time improving graph quality during index construction, but it is unnecessary; this is not uncommon, as we also see it in [31, 36–38].</p></li></ul><br><ul><li><p><mark>问题 4：多样化的数据集对于基于图的近似最近邻搜索算法的可扩展性评估至关重要</mark></p></li><li><p>一些基于图的近似最近邻搜索算法仅在少数数据集上进行评估，这限制了对它们在不同数据集上的扩展性分析。查看在各种数据集上的评估结果（详情见第 5 节），我们发现许多算法在不同数据集上的性能方面存在显著差异。也就是说，一种算法在某些数据集上的优势可能难以扩展到其他数据集。例如，当搜索准确率达到 0.99 时，在 Msong 数据集上，NSG 每次查询的加速比比 HNSW 高 125 倍[2]。然而，在 Crawl 数据集上，当达到相同的 0.99 搜索准确率时，NSG 的加速比比 HNSW 低 80 倍。这表明算法的优势取决于数据集，而不是其性能固定不变。评估和分析不同场景下的数据集，有助于更好地理解基于图的近似最近邻搜索算法在不同场景下的性能差异，这为不同领域的从业者选择最合适的算法提供了依据。</p></li><li><p>Some graph-based ANNS algorithms are evaluated only on a small number of datasets, which limits analysis on how well they scale on different datasets. Looking at the evaluation results on various datasets (see <strong>§5</strong> for details), we find that many algorithms have significant discrepancies in terms of performance on different datasets.</p></li><li><p>That is, the advantages of an algorithm on some datasets may be difficult to extend to other datasets. For example, when the search accuracy reaches 0.99, NSG’s speedup is 125× more than that of HNSW for each query on Msong [2]. However, on Crawl [3], NSG’s speedup is 80× lower than that of HNSW when it achieves the same search accuracy of 0.99.</p></li><li><p>This shows that an algorithm’s superiority is contingent on the dataset rather than being fixed in its performance. Evaluating and analyzing different scenarios’ datasets leads to understanding performance differences better for graph-based ANNS algorithms in diverse scenarios, which provides a basis for practitioners in different fields to choose the most suitable algorithm.</p></li></ul><h3 id="_1-2-our-contributions" tabindex="-1"><a class="header-anchor" href="#_1-2-our-contributions" aria-hidden="true">#</a> 1.2 Our Contributions</h3><ul><li><p>受上述问题的驱动，我们在精心挑选的具有不同特征的数据集上对具有代表性的基于图的算法进行了全面的比较分析和实验评估。值得注意的是，我们尽最大努力使用相同的设计模式、编程语言和技巧以及实验设置来重新实现所有算法，这使得比较更加公平。我们的主要贡献总结如下。</p></li><li><p>Driven by the aforementioned issues, we provide a comprehensive comparative analysis and experimental evaluation of representative graph-based algorithms on carefully selected datasets of varying characteristics. It is worth noting that we try our best to reimplement all algorithms using the same design pattern, programming language and tricks, and experimental setup, which makes the comparison fairer. Our key contributions are summarized as follows.</p></li><li><p><mark>(1) 我们基于四个基本图提供了一种基于图的近似最近邻搜索算法的新分类法</mark></p></li><li><p>对于 问题1，我们基于四个基本图对基于图的算法进行分类（第 3 节），这为理解现有工作带来了一个新视角。在此基础上，我们比较和分析算法间的特征，如果不同算法使用类似技术则建立联系，并详细阐述相关算法的继承和改进，从而展示出多样化的发展路线图（表 2 和图 3）。</p></li><li><p>For <strong>I1</strong>, we classify graph-based algorithms based on four base graphs (<strong>§3</strong>), which brings a new perspective to understanding existing work. On this basis, we compare and analyze the features of inter-algorithms, make connections if different algorithms use similar techniques, and elaborate upon the inheritance and improvement of relevant algorithms, thus exhibiting diversified development roadmaps (Table 2 and Figure 3).</p></li><li><p><mark>(2) 我们提出了一个用于分析基于图的近似最近邻搜索算法的具有七个细粒度组件的统一流程</mark></p></li><li><p>至于 问题2，我们在一个统一流程中将所有基于图的近似最近邻搜索算法分解为七个细粒度(fine-grained)组件（图 4）：我们将构建(<em>construction</em>)分为初始化(<em>initialization</em>)、候选邻居获取(<em>candidate neighbor acquisition</em>)、邻居选择(<em>neighbor selection</em>)、连接性(<em>connectivity</em>)和种子预处理(<em>seed preprocessing</em>)组件，并且将搜索(<em>search</em>)分为种子获取(<em>seed acquisition</em>)和路由(<em>routing</em>)组件（第 4 节）。这不仅使我们能够对算法有更深入的理解，而且通过控制流程中其他组件的一致性来实现对一个组件的公平评估（第 5 节）。</p></li><li><p>As for <strong>I2</strong>, we break all graph-based ANNS algorithms down to seven fine-grained components in an unified pipeline (Figure 4):</p></li><li><p>We divide <em>construction</em> into</p><ul><li><em>initialization</em>,</li><li><em>candidate neighbor acquisition</em>,</li><li><em>neighbor selection</em>,</li><li><em>connectivity</em>, and</li><li><em>seed preprocessing</em> components,</li></ul></li><li><p>and divide <em>search</em> into</p><ul><li><em>seed acquisition</em> and</li><li><em>routing</em> components (<strong>§4</strong>).</li></ul></li><li><p>This not only allows us to have a deeper understanding of the algorithm, but also to achieve a fair evaluation of a component by controlling other components’ consistency in the pipeline (<strong>§5</strong>).</p></li><li><p><mark>(3) 我们使用更多指标和不同数据集对具有代表性的基于图的近似最近邻搜索算法进行全面评估</mark></p></li><li><p>就 问题3 而言，我们在第 5 节中对算法和组件进行了全面评估，涉及索引构建和搜索的丰富指标。对于 问题4，我们研究了不同算法在不同数据集（8 个真实世界数据集和 12 个合成数据集）上的可扩展性，涵盖了视频、语音、图像和文本等多媒体数据。</p></li><li><p>In terms of <strong>I3</strong>, we perform a thorough evaluation of algorithms and components in <strong>§5</strong>, with abundant metrics involved in index construction and search. For <strong>I4</strong>, we investigate different algorithms’ scalability over different datasets (eight real world and 12 synthetic datasets), covering multimedia data such as video, voice, image, and text.</p></li></ul><br><ul><li><mark>(4) 我们讨论了关于基于图的近似最近邻搜索算法的建议、指导方针、改进、趋势和挑战</mark></li><li>基于我们的调查，我们为每个单一算法提供了一些关于最适合场景的经验性建议，以及优化算法的有用指导方针，从而设计一个算法以获得最先进的性能。然后我们分析了基于图的近似最近邻搜索算法有前途的研究方向和突出的挑战（第 6 节）。</li><li>Based on our investigation, we provide some rule of-thumb recommendations about the most suitable scenario for each single algorithm, along with useful guidelines to optimize algorithms, thus designing an algorithm obtains the state-of-the art performance. Then we analyze graph-based ANNS algorithms’ promising research directions and outstanding challenges (<strong>§6</strong>).</li></ul><h2 id="_2-preliminaries" tabindex="-1"><a class="header-anchor" href="#_2-preliminaries" aria-hidden="true">#</a> 2 PRELIMINARIES</h2>',18),W=s("ul",null,[s("li",null,[s("p",null,[s("mark",null,"Notations符号说明")])]),s("li",null,[s("p",null,"除非另有明确说明，否则本文中相对应的符号默认按照表 1 中所描述的那样出现。")]),s("li",null,[s("figure",null,[s("img",{src:g,alt:"image-20240609214630830",tabindex:"0",loading:"lazy"}),s("figcaption",null,"image-20240609214630830")])]),s("li",null,[s("p",null,[s("mark",null,"Modeling建模")])]),s("li",null,[s("p",null,[a("对于一个包含 n 个点的数据集 S = {"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"s"),s("mn",null,"0")])]),s("annotation",{encoding:"application/x-tex"},"s_0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"s"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"s"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"s_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"s"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", ···, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"s"),s("mrow",null,[s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"s_{n-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6389em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"s"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"n"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),a("}，S 中的每个元素 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"s"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"s_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"s"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a("（表示为 x）由一个维度为 d 的向量 x = ["),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mn",null,"0")])]),s("annotation",{encoding:"application/x-tex"},"x_0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"x_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", ···, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mrow",null,[s("mi",null,"d"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"x_{d-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6389em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"d"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),a("]表示。通过在 S 上使用一个相似性函数对向量进行相似性计算，我们可以实现对相应数据的分析和检索[25, 70]。")])]),s("li",null,[s("p",null,[s("mark",null,"Similarity function相似性函数")])]),s("li",null,[s("p",null,[a("对于数据集 S 上的两个点 x 和 y，各种应用程序采用距离函数来计算这两个点 x 和 y 之间的相似性[107]。最常用的距离函数是欧几里得距离 δ(x,y)（l2 norm）[85]，其在等式 1 中给出。其中 x 和 y 分别对应向量 x = ["),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mn",null,"0")])]),s("annotation",{encoding:"application/x-tex"},"x_0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"x_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", ···, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"x"),s("mrow",null,[s("mi",null,"d"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"x_{d-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6389em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"d"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),a("] 和 y = ["),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"y"),s("mn",null,"0")])]),s("annotation",{encoding:"application/x-tex"},"y_0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"y"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"y_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", ···, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"y"),s("mrow",null,[s("mi",null,"d"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"y_{d-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6389em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"d"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),a("]，这里的 d 表示向量的维度。δ(x,y)越大，x 和 y 越不相似，越接近零，它们就越相似[107]。")]),s("ul",null,[s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("msqrt",null,[s("mrow",null,[s("msubsup",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"="),s("mn",null,"0")]),s("mrow",null,[s("mi",null,"d"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"x"),s("mi",null,"i")]),s("mo",null,"−"),s("msub",null,[s("mi",null,"y"),s("mi",null,"i")]),s("msup",null,[s("mo",{stretchy:"false"},")"),s("mn",null,"2")])])])]),s("annotation",{encoding:"application/x-tex"},"\\delta (x,y) = \\sqrt{\\sum_{i=0}^{d-1} (x_i - y_i)^2}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.84em","vertical-align":"-0.5104em"}}),s("span",{class:"mord sqrt"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.3296em"}},[s("span",{class:"svg-align",style:{top:"-3.8em"}},[s("span",{class:"pstrut",style:{height:"3.8em"}}),s("span",{class:"mord",style:{"padding-left":"1em"}},[s("span",{class:"mop"},[s("span",{class:"mop op-symbol small-op",style:{position:"relative",top:"0em"}},"∑"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.989em"}},[s("span",{style:{top:"-2.4003em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"0")])])]),s("span",{style:{top:"-3.2029em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"d"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2997em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},[s("span",{class:"mclose"},")"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7401em"}},[s("span",{style:{top:"-2.989em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])])])]),s("span",{style:{top:"-3.2896em"}},[s("span",{class:"pstrut",style:{height:"3.8em"}}),s("span",{class:"hide-tail",style:{"min-width":"1.02em",height:"1.88em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"400em",height:"1.88em",viewBox:"0 0 400000 1944",preserveAspectRatio:"xMinYMin slice"},[s("path",{d:`M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z`})])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.5104em"}},[s("span")])])])])])])])])])])],-1),R=s("h3",{id:"_2-1-problem-definition",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2-1-problem-definition","aria-hidden":"true"},"#"),a(" 2.1 Problem Definition")],-1),F=s("ul",null,[s("li",null,"在正式描述近似最近邻搜索（ANNS）之前，我们首先定义最近邻搜索（NNS）。"),s("li",null,[a("定义 2.1. "),s("mark",null,"最近邻搜索（NNS）"),a("。给定欧几里得空间"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a(" 中的一个有限数据集 𝑆 以及一个查询点 𝑞，最近邻搜索通过评估 𝛿 (𝑥, 𝑞)（其中 𝑥 属于 𝑆）来获得 𝑞 的 𝑘 个最近邻 𝑅。 𝑅 描述如下： "),s("ul",null,[s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"R"),s("mo",null,"="),s("mi",null,"arg"),s("mo",null,"⁡"),s("munder",null,[s("mrow",null,[s("mi",null,"min"),s("mo",null,"⁡")]),s("mrow",null,[s("mi",null,"R"),s("mo",null,"⊂"),s("mi",null,"S"),s("mo",{separator:"true"},","),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"R"),s("mi",{mathvariant:"normal"},"∣"),s("mo",null,"="),s("mi",null,"k")])]),s("msub",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"x"),s("mo",null,"∈"),s("mi",null,"R")])]),s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"q"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"R = \\arg\\min\\limits_{R \\subset S, |R|=k} \\sum_{x \\in R} \\delta(x,q)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.716em","vertical-align":"-0.966em"}}),s("span",{class:"mop"},[a("ar"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop op-limits"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6679em"}},[s("span",{style:{top:"-2.309em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mrel mtight"},"⊂"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mpunct mtight"},","),s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mord mtight"},"∣"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])]),s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",null,[s("span",{class:"mop"},"min")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.966em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[s("span",{class:"mop op-symbol small-op",style:{position:"relative",top:"0em"}},"∑"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1786em"}},[s("span",{style:{top:"-2.4003em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"x"),s("span",{class:"mrel mtight"},"∈"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3271em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mclose"},")")])])]),a(" (2)")])])]),s("li",null,"随着数据量的增长，|𝑆|变得极其庞大（规模从数百万到数十亿不等），这使得在大规模数据上执行最近邻搜索变得不切实际，因为计算成本很高[116]。代替最近邻搜索，已经提出了大量用于近似最近邻搜索的实际技术，这些技术通过评估 𝑆 的一个小子集来放宽对准确性的保证以提高效率[101]。近似最近邻搜索问题定义如下："),s("li",null,[a("定义 2.2. "),s("mark",null,"近似最近邻搜索（ANNS）"),a(".给定欧几里得空间 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a(" 中的一个有限数据集 𝑆 以及一个查询点 𝑞，近似最近邻搜索在 𝑆 上构建一个索引 𝐼。然后通过 𝐼 得到 𝑆 的一个子集 𝐶，并评估 𝛿 (𝑥, 𝑞) 以获得 𝑞 的近似 𝑘 个最近邻 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"R"),s("mo",{stretchy:"true"},"~")])]),s("annotation",{encoding:"application/x-tex"},"\\widetilde{R}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9433em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9433em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")]),s("span",{class:"svg-align",style:{width:"calc(100% - 0.1667em)","margin-left":"0.1667em",top:"-3.6833em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{style:{height:"0.26em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"100%",height:"0.26em",viewBox:"0 0 600 260",preserveAspectRatio:"none"},[s("path",{d:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`})])])])])])])])])])]),a("，其中 𝑥 属于 𝐶。")]),s("li",null,[a("通常，我们使用召回率 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"𝑅"),s("mi",null,"𝑒"),s("mi",null,"𝑐"),s("mi",null,"𝑎"),s("mi",null,"𝑙"),s("mi",null,"𝑙"),s("mi",{mathvariant:"normal"},"@"),s("mi",null,"𝑘"),s("mo",null,"="),s("mfrac",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"R"),s("mo",null,"∩"),s("mover",{accent:"true"},[s("mi",null,"R"),s("mo",{stretchy:"true"},"~")]),s("mi",{mathvariant:"normal"},"∣")]),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"𝑅𝑒𝑐𝑎𝑙𝑙@𝑘 = \\frac{|R \\cap \\widetilde{R}|}{k}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mord mathnormal"},"ec"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"ll"),s("span",{class:"mord"},"@"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.4903em","vertical-align":"-0.345em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.1453em"}},[s("span",{style:{top:"-2.655em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.485em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mbin mtight"},"∩"),s("span",{class:"mord accent mtight"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9433em"}},[s("span",{style:{top:"-2.7em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R")]),s("span",{class:"svg-align",style:{width:"calc(100% - 0.1667em)","margin-left":"0.1667em",top:"-3.3833em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"mtight",style:{height:"0.26em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"100%",height:"0.26em",viewBox:"0 0 600 260",preserveAspectRatio:"none"},[s("path",{d:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`})])])])])])])]),s("span",{class:"mord mtight"},"∣")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.345em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})])])])]),a(" 来评估搜索结果的准确性。近似最近邻搜索（ANNS）算法旨在最大化 𝑅𝑒𝑐𝑎𝑙𝑙@𝑘，同时尽可能使 C 变小（例如，在 SIFT1M [1] 数据集上，当 |𝑆 | 为几百万时，|C| 仅为几千）。如前所述，基于图的 ANNS 算法因其在准确性与效率方面的优势而变得突出。我们对基于图的 ANNS 定义如下。")]),s("li",null,[a("定义 2.3. "),s("mark",null,[a("基于图的近似最近邻搜索("),s("strong",null,"Graph-based ANNS"),a(")")]),a("。给定在欧几里得空间 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a(" 中的有限数据集 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G(V,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a(" 表示在 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a(" 上构建的一个图（定义 2.2 中的索引 𝐼），对于 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"V")]),s("annotation",{encoding:"application/x-tex"},"V")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a(" 中的所有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"v")]),s("annotation",{encoding:"application/x-tex"},"v")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v")])])]),a("，它唯一对应于 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a(" 中的一个点 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("。这里对于所有的 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"u"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",{stretchy:"false"},")"),s("mo",null,"∈"),s("mi",null,"E")]),s("annotation",{encoding:"application/x-tex"},"(u,v)\\in E")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a(" 表示 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"u")]),s("annotation",{encoding:"application/x-tex"},"u")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"u")])])]),a(" 和 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"v")]),s("annotation",{encoding:"application/x-tex"},"v")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v")])])]),a(" 之间的邻域关系，且 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"u"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",null,"∈"),s("mi",null,"V")]),s("annotation",{encoding:"application/x-tex"},"u,v\\in V")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7335em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a("。给定一个查询 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"q")]),s("annotation",{encoding:"application/x-tex"},"q")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])])]),a("、种子集 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",null,"^")])]),s("annotation",{encoding:"application/x-tex"},"\\hat{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9468em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9468em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")]),s("span",{style:{top:"-3.2523em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"accent-body",style:{left:"-0.1667em"}},[s("span",{class:"mord"},"^")])])])])])])])])]),a("、路由策略和终止条件，基于图的近似最近邻搜索首先用种子集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",null,"^")])]),s("annotation",{encoding:"application/x-tex"},"\\hat{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9468em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9468em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")]),s("span",{style:{top:"-3.2523em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"accent-body",style:{left:"-0.1667em"}},[s("span",{class:"mord"},"^")])])])])])])])])]),a(" 初始化查询 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"q")]),s("annotation",{encoding:"application/x-tex"},"q")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])])]),a(" 的近似 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"k")]),s("annotation",{encoding:"application/x-tex"},"k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k")])])]),a(" 个最近邻 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"R"),s("mo",{stretchy:"true"},"~")])]),s("annotation",{encoding:"application/x-tex"},"\\widetilde{R}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9433em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9433em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")]),s("span",{class:"svg-align",style:{width:"calc(100% - 0.1667em)","margin-left":"0.1667em",top:"-3.6833em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{style:{height:"0.26em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"100%",height:"0.26em",viewBox:"0 0 600 260",preserveAspectRatio:"none"},[s("path",{d:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`})])])])])])])])])])]),a("，然后从 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",null,"^")])]),s("annotation",{encoding:"application/x-tex"},"\\hat{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9468em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9468em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")]),s("span",{style:{top:"-3.2523em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"accent-body",style:{left:"-0.1667em"}},[s("span",{class:"mord"},"^")])])])])])])])])]),a(" 开始通过路由策略进行搜索并更新 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"R"),s("mo",{stretchy:"true"},"~")])]),s("annotation",{encoding:"application/x-tex"},"\\widetilde{R}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9433em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9433em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")]),s("span",{class:"svg-align",style:{width:"calc(100% - 0.1667em)","margin-left":"0.1667em",top:"-3.6833em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{style:{height:"0.26em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"100%",height:"0.26em",viewBox:"0 0 600 260",preserveAspectRatio:"none"},[s("path",{d:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`})])])])])])])])])])]),a("。最后，一旦满足终止条件，它就返回查询结果 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"R"),s("mo",{stretchy:"true"},"~")])]),s("annotation",{encoding:"application/x-tex"},"\\widetilde{R}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9433em"}}),s("span",{class:"mord accent"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9433em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"R")]),s("span",{class:"svg-align",style:{width:"calc(100% - 0.1667em)","margin-left":"0.1667em",top:"-3.6833em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{style:{height:"0.26em"}},[s("svg",{xmlns:"http://www.w3.org/2000/svg",width:"100%",height:"0.26em",viewBox:"0 0 600 260",preserveAspectRatio:"none"},[s("path",{d:`M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`})])])])])])])])])])]),a("。")])],-1),V=s("h3",{id:"_2-2-scope-illustration",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2-2-scope-illustration","aria-hidden":"true"},"#"),a(" 2.2 Scope Illustration")],-1),B=s("ul",null,[s("li",null,[s("p",null,"为了使我们的调查和比较既集中又全面，我们采用了一些必要的限制条件。")]),s("li",null,[s("p",null,[s("mark",null,"Graph-based ANNS")]),s("ul",null,[s("li",null,"我们只考虑那些其索引结构是基于图来进行近似最近邻搜索的算法。尽管存在一些基于其他结构的有效算法，但这些方法的搜索性能远远不如基于图的算法。随着时间的推移，基于图的算法已经成为学术界和工业界研究和实践的主流。")])]),s("li",null,[s("p",null,[s("mark",null,"Dataset")])]),s("li",null,[s("p",null,[a("近似最近邻搜索技术已被用于各种多媒体领域。为了全面评估比较算法的性能，我们选择了各种多媒体数据，包括视频、图像、语音和文本（详情见第 5 节中的表 3）。基础数据和查询数据包括通过深度学习技术（如用于图像的 VGG[87]）提取的高维特征向量，而基准数据包括通过线性扫描在"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a("中计算出的查询的 20 或 100 个最近邻。")])]),s("li",null,[s("p",null,[s("mark",null,"Core algorithms")])]),s("li",null,[s("p",null,"本文主要关注内存(in-memory )核心算法。对于某些硬件（例如 GPU[113]和 SSD[88]）、异构（例如分布式部署[30]）以及基于机器学习（ML）的优化[14,59,78]（关于一些基于 ML 的优化的评估见第 5.5 节），我们不详细讨论这些，要记住核心算法是这些优化的基础。在未来的工作中，我们将专注于比较基于图的近似最近邻搜索算法与 GPU、SSD、ML 等。")])],-1),O=l('<h2 id="_3-overview-of-graph-based-anns" tabindex="-1"><a class="header-anchor" href="#_3-overview-of-graph-based-anns" aria-hidden="true">#</a> 3 OVERVIEW OF GRAPH-BASED ANNS</h2><ul><li>在本节中，我们将从一个新的角度对基于图的 ANNS 算法进行分类和总体分析。为此，我们首先剖析了几种经典的基础图[20, 91]，包括Delaunay Graph[ 12 , 35 ]、Relative Neighborhood Graph[ 50 , 92 ]、K-Nearest Neighbor Graph[ 9, 75 ]和Minimum Spanning Tree 最小生成树[ 58, 83 ]。之后，我们回顾了 13 种具有代表性的基于图的 ANNS 算法，这些算法对这些基础图进行了不同的优化。</li><li><img src="'+u+'" alt="figure2" tabindex="0" loading="lazy"><figcaption>figure2</figcaption></li></ul><h3 id="_3-1-base-graphs-for-anns" tabindex="-1"><a class="header-anchor" href="#_3-1-base-graphs-for-anns" aria-hidden="true">#</a> 3.1 Base Graphs for ANNS</h3>',3),Q=s("ul",null,[s("li",null,[s("p",null,"基于图的近似最近邻搜索算法所依赖的这四个基础图是分析这些算法的基础。接下来，我们将对每个基础图进行正式描述，并通过图 2 中的一个简单示例直观地展示它们的差异。")]),s("li",null,[s("p",null,[s("mark",null,"Delaunay Graph (DG)")])]),s("li",null,[s("p",null,[a("在欧几里得空间"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a("中，在数据集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("上构建的德劳内图"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G(V,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a("满足以下条件：对于任意"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"e"),s("mo",null,"∈"),s("mi",null,"E")]),s("annotation",{encoding:"application/x-tex"},"e\\in E")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a("（例如图 2(a)中的黄色线），其对应的两个顶点是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，存在一个通过"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("的圆（图 2(a)中的红色圆），圆内没有其他顶点，并且同时在圆上最多有三个顶点（即"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),a("）（关于德劳内图的标准定义见[35]）。德劳内图确保近似最近邻搜索总是返回精确结果[67]，但缺点是当维度"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"d")]),s("annotation",{encoding:"application/x-tex"},"d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"d")])])]),a("极高时，德劳内图几乎是完全连接的，这导致搜索空间很大[38,43]。")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Relative Neighborhood Graph (RNG)")])])]),s("li",null,[s("p",null,[a("在欧几里得空间"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a("中，在数据集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("上构建的相对邻域图"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G(V,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a("具有以下属性：对于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"V")]),s("annotation",{encoding:"application/x-tex"},"V")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a("中的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，如果"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("通过边"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"e"),s("mo",null,"∈"),s("mi",null,"E")]),s("annotation",{encoding:"application/x-tex"},"e\\in E")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a("连接，那么对于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"V")]),s("annotation",{encoding:"application/x-tex"},"V")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a("中的任意"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),a("，有"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"<"),s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"z"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\delta(x,y)<\\delta(x,z)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mclose"},")")])])]),a("，或者"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"<"),s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"z"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\delta(x,y)<\\delta(z,y)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])]),a("。换句话说，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),a("不在图 2(b)中的红色月牙区域内（关于相对邻域图的标准定义，请参考[92]）。与德劳内图相比，相对邻域图切断了一些违反上述属性的冗余邻居（彼此靠近），并使剩余的邻居全方位分布，从而减少了近似最近邻搜索的距离计算[67]。然而，在"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("上构建相对邻域图的时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"S"),s("msup",null,[s("mi",{mathvariant:"normal"},"∣"),s("mn",null,"3")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(|S|^3)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord"},[s("span",{class:"mord"},"∣"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"3")])])])])])])]),s("span",{class:"mclose"},")")])])]),a("[49]。")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"K-Nearest Neighbor Graph (KNNG)")])])]),s("li",null,[s("p",null,[a("在数据集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("中的每个点都与其最近的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("个点相连，以在欧几里得空间"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a("中形成一个"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("近邻图"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G(V,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a("。如图 2(c)（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K"),s("mo",null,"="),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"K=2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),a("）所示，对于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"V")]),s("annotation",{encoding:"application/x-tex"},"V")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V")])])]),a("中的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("属于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("的邻居集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"N"),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mo",{stretchy:"false"},"{"),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"u"),s("mo",{stretchy:"false"},"}")]),s("annotation",{encoding:"application/x-tex"},"N(y)=\\{x,u\\}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"{"),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mclose"},"}")])])]),a("，但"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("不属于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("的邻居集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"N"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mo",{stretchy:"false"},"{"),s("mi",null,"z"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",{stretchy:"false"},"}")]),s("annotation",{encoding:"application/x-tex"},"N(x)=\\{z,v\\}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"{"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mclose"},"}")])])]),a("，其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"N"),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"N(y)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"N"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"N(x)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")")])])]),a("分别是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("的邻居集。因此，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("之间的边是有向边，所以"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("近邻图是有向图。"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("近邻图将每个顶点的邻居数量最多限制为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("，从而避免了邻居数量的激增，这在内存有限且对效率要求较高的情况下效果很好。可以看出，在图 2(c)中，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"K")]),s("annotation",{encoding:"application/x-tex"},"K")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K")])])]),a("近邻图不能保证全局连通性，这对近似最近邻搜索是不利的。")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Minimum Spanning Tree (MST)")])])]),s("li",null,[s("p",null,[a("在欧几里得空间"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"E"),s("mi",null,"d")])]),s("annotation",{encoding:"application/x-tex"},"E^d")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"d")])])])])])])])])])]),a("中，最小生成树（MST）是在数据集"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"S")]),s("annotation",{encoding:"application/x-tex"},"S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("上具有最小的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msubsup",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"="),s("mn",null,"1")]),s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣")])]),s("mi",null,"w"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"e"),s("mi",null,"i")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\sum_{i=1}^{|E|}w(e_i)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.3276em","vertical-align":"-0.2997em"}}),s("span",{class:"mop"},[s("span",{class:"mop op-symbol small-op",style:{position:"relative",top:"0em"}},"∑"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.0279em"}},[s("span",{style:{top:"-2.4003em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"1")])])]),s("span",{style:{top:"-3.2029em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord mtight"},"∣")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2997em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},")")])])]),a("的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G(V,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a("，其中与"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"e"),s("mi",null,"i")]),s("mo",null,"∈"),s("mi",null,"E")]),s("annotation",{encoding:"application/x-tex"},"e_i\\in E")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6891em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a("相关联的两个顶点是"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a("和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"w"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"e"),s("mi",null,"i")]),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"δ"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"w(e_i)=\\delta(x,y)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03785em"}},"δ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])]),a("。如果存在"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"e"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"e_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"e"),s("mi",null,"j")]),s("mo",null,"∈"),s("mi",null,"E")]),s("annotation",{encoding:"application/x-tex"},"e_j\\in E")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8252em","vertical-align":"-0.2861em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05724em"}},"j")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∈"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E")])])]),a("且"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"w"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"e"),s("mi",null,"i")]),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"w"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mi",null,"e"),s("mi",null,"j")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"w(e_i)=w(e_j)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0361em","vertical-align":"-0.2861em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05724em"}},"j")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])]),s("span",{class:"mclose"},")")])])]),a("，那么最小生成树不是唯一的[68]。尽管大多数当前基于图的近似最近邻搜索算法没有采用最小生成树，但混合紧致近邻图（HCNNG）[72]证实了最小生成树作为近似最近邻搜索的邻居选择策略的有效性。使用最小生成树作为基础图的主要优势在于，最小生成树使用最少的边来确保图的全局连通性，从而保持顶点的低度，并且任何两个顶点都是可达的。然而，由于缺乏捷径，在最小生成树上进行搜索时可能会迂回。例如，在图 2(d)中，当从"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"s")]),s("annotation",{encoding:"application/x-tex"},"s")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"s")])])]),a("到"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"r")]),s("annotation",{encoding:"application/x-tex"},"r")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])])]),a("进行搜索时，必须迂回经过"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"s"),s("mo",null,"→"),s("mi",null,"x"),s("mo",null,"→"),s("mi",null,"y"),s("mo",null,"→"),s("mi",null,"u"),s("mo",null,"→"),s("mi",null,"r")]),s("annotation",{encoding:"application/x-tex"},"s→x→y→u→r")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"s"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"→"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"→"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"→"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"→"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])])]),a("。如果"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"s")]),s("annotation",{encoding:"application/x-tex"},"s")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"s")])])]),a("和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"r")]),s("annotation",{encoding:"application/x-tex"},"r")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])])]),a("之间有一条边，这种情况就可以避免。")])])],-1),j=s("h3",{id:"_3-2-graph-based-anns-algorithms",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_3-2-graph-based-anns-algorithms","aria-hidden":"true"},"#"),a(),s("strong",null,"3.2 Graph-Based ANNS Algorithms")],-1),U=s("ul",null,[s("li",null,[s("p",null,"尽管基础图的形式定义有助于理论分析，但它们直接应用于近似最近邻搜索是不切实际的[38]。显然，它们的高构建复杂度很难扩展到大规模数据集。随着频繁更新的数据库的出现，这一点变得更加真实[60]。此外，在高维场景中，基础图很难实现高搜索效率[38,43,77]。因此，许多基于图的近似最近邻搜索算法从一个或几个方面着手改进基础图。接下来，我们基于上述四个基础图及其发展路线图（图 3）概述了 13 个具有代表性的基于图的近似最近邻搜索算法（A1-A13）。表 2 总结了关于算法的一些重要属性。")]),s("li",null,[s("figure",null,[s("img",{src:d,alt:"table2",tabindex:"0",loading:"lazy"}),s("figcaption",null,"table2")])]),s("li",null,[s("figure",null,[s("img",{src:y,alt:"figure3",tabindex:"0",loading:"lazy"}),s("figcaption",null,"figure3")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"DG-based and RNG-based ANNS algorithms (NSW, HNSW,FANNG, NGT)")])])]),s("li",null,[s("p",null,"为了解决高维度中 DG 的高度(degree)问题，已经提出了一些细微的改进方法[15,16,56]。然而，它们在很大程度上依赖于 DG 的质量，并且存在维度诅咒[65]。所以，有些算法在 DG 上添加一个 RNG 近似来使邻居的分布多样化[67]。")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A1: Navigable Small World graph (NSW)")])])]),s("li",null,[s("p",null,"NSW[65]通过连续插入元素来构建一个无向图，并确保全局连通性（近似的 DG）。其直觉是贪婪遍历（随机种子）的结果总是 DG 上最近的邻居[67]。在构建初期形成的长边具有小世界导航性能以确保搜索效率，而稍后插入的顶点形成短程边，这确保了搜索准确性。NSW 在最大内积搜索中也取得了出色的结果[63,71]。然而，根据[77]的评估，与非基于图的索引相比，NSW 在效率和有效性之间提供的最佳权衡有限，因为它的搜索复杂度是多项式对数级的[73]。此外，NSW 使用无向边来连接顶点，这导致密集区域的顶点充当“交通枢纽”（高出度），从而损害了搜索效率。")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A2: Hierarchical Navigable Small World graphs (HNSW)")])])]),s("li",null,[s("p",null,"[19,66]提出了一个改进方向以克服NSW算法的多项式对数级搜索复杂度。受此启发，（HNSW）[67]生成了一个分层图并固定每个顶点邻居数量的上限，从而实现了搜索的对数复杂度缩放。它的基本思想是根据距离尺度将邻居分离到不同层次，搜索是一个从上到下的迭代过程。对于一个插入点，HNSW 不仅选择其最近邻（近似 DG），还考虑邻居的分布（近似 RNG）。由于其前所未有的优越性，HNSW 已在各种应用中得到部署[17,22,57]。然而，它的多层结构显著增加了内存使用量，并使其难以扩展到更大的数据集[38]。同时，[62]通过实验验证，随着内在维度增加（>32），分层结构的优势逐渐消失。因此，最近的工作试图通过硬件或异构实现来优化 HNSW 以缓解这些问题[30,109]。")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A3: Fast Approximate Nearest Neighbor Graph (FANNG)")])])]),s("li",null,[s("p",null,"FANNG [43]提出了一个遮挡规则(occlusion rule)来切断冗余邻居（近似 RNG）。与 HNSW 对 RNG 的近似（HNSW 只考虑贪婪搜索返回的少量顶点）不同，FANNG 的遮挡规则应用于数据集中除目标点之外的所有其他点，这导致了较高的构建复杂度。因此，[43]提出了两种关于候选邻居获取的直观优化来缓解这个问题。为了提高准确性，FANNG 回溯到第二近的顶点并考虑其尚未被探索的边。")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A4: Neighborhood Graph and Tree (NGT)")])])]),s("li",null,[s("p",null,"NGT [46]是雅虎日本公司发布的用于执行高速ANNS的一个库。它包含两种构建方法。一种是将 KNNG 转换为双向 KNNG（BKNNG），即在 KNNG 上的每条有向边添加反向边[47]。另一种像NSW算法（近似于 DG）那样增量构建[47]。与NSW算法的不同之处在于构建过程中使用的范围搜索（贪婪搜索的一种变体）。上述两种方法都会使某些中心顶点具有很高的出度，这将严重影响搜索效率。因此，NGT 使用三种度调整方法来缓解这个问题，并且在更有效的路径调整中是对 RNG 的近似（证明见附录 B）[48]。这降低了内存开销并提高了搜索效率。NGT 通过 VP 树[48]获取种子顶点，然后使用范围搜索进行路由。有趣的是，[7]中的 k-DR 算法也使用了类似 NGT 的路径调整和范围搜索（详见附录 N）。")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"KNNG-based ANNS algorithms (SPTAG, KGraph, EFANNA,IEH)")])])]),s("li",null,[s("p",null,"K 近邻图（KNNG）的一种简单构造方法是详尽地[exhaustively]比较所有点对，这非常耗时且不适用于大型数据集(S)。一些早期的解决方案构建一个额外的索引（例如树[76]或哈希[93,111]），然后通过近似最近邻搜索（ANNS）找到每个点的邻居。然而，这类方法通常遭受高索引构建复杂度之苦(复杂度太高了)[26]。这是因为它们忽略了这个事实：在图构建过程中查询属于(S)，但近似最近邻搜索的查询通常不属于[100]。因此，没有必要确保在额外索引上对一般查询给出良好结果[100]。有两类具有代表性的解决方案，它们只专注于图的构建。")]),s("li",null,[s("p",null,[a("A naive construction for KNNG is exhaustively comparing all pairs of points, which is prohibitively slow and unsuitable for large dataset "),s("em",null,"𝑆"),a(". Some early solutions construct an additional index (such as tree [76] or hash [93, 111]), and then find the neighbors of each point through ANNS. However, such methods generally suffer from high index construction complexity [26]. This is because they ignore this fact: the queries belong to "),s("em",null,"𝑆"),a(" in the graph construction process, but the queries of ANNS generally do not [100]. Thus, it is unnecessary to ensure a good result is given for general queries on additional index [100]. There are two types of representative solutions, which only focus on graph construction.")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A5: Space Partition Tree and Graph (SPTAG)")])])]),s("li",null,[s("p",null,"一种是基于分治的方法，其代表是微软发布的库 SPTAG [27]。SPTAG 将数据集(S)分层划分为子集（通过三元投影树[101]），并在每个子集上构建精确的 K 近邻图。这个过程重复多次，以便在(S)上生成更准确的 K 近邻图。此外，SPTAG 通过执行邻域传播[100]进一步提高了 K 近邻图的准确性。早期版本的 SPTAG 在(S)上添加多个 KD 树，以迭代地获得更接近查询的种子[98]。然而，在极高维度的(S)上，KD 树会产生不准确的距离边界估计。作为回应，构建平衡 k 均值树来取代 KD 树[27]。受到随机近邻图（RNG）带来的普遍优势的启发，SPTAG 最近在项目中增加了近似 RNG 的选项[27]。")]),s("li",null,[s("p",null,[a("One is based on divide and conquer, and its representative is SPTAG [27], a library released by Microsoft. SPTAG hierarchically divides dataset "),s("em",null,"𝑆"),a(" into subsets (through Trinary-Projection Trees [101]) and builds an exact KNNG over each subset. This process repeats multiple times to produce a more accurate KNNG on "),s("em",null,"𝑆"),a(".")])]),s("li",null,[s("p",null,[a("Moreover, SPTAG further improves KNNG’s accuracy by performing neighborhood propagation [100]. The early version of SPTAG added multiple KD-trees on "),s("em",null,"𝑆"),a(" to iteratively obtain the seeds closer to the query [98]. However, on extremely high-dimensional "),s("em",null,"𝑆"),a(", the KD-trees will produce an inaccurate distance bound estimation. In response, the balanced k-means trees are constructed to replace the KD-trees [27]. Inspired by the universal superiority brought about by RNG, SPTAG has recently added the option of approximating RNG in the project [27]")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A6: KGraph.")])])]),s("li",null,[s("p",null,"另一种是基于 NN-Descent（最近邻下降算法）[32]；其基本思想是邻居更有可能彼此也是邻居[36]。KGraph [31]首先采用这个思想，将数据集(S)上的 K 近邻图的构建复杂度降低到(O(|S|^{1.14}))。它比 NSW（Navigable Small World Graph，可导航小世界图）[18]实现了更好的搜索性能。因此，一些基于 NN-Descent 的衍生算法被开发出来以挖掘其潜力[23,114,115]。")]),s("li",null,[s("p",null,[a("The other is based on NN-Descent [32]; its basic idea is "),s("em",null,"neighbors are more likely to be neighbors of each other"),a(" [36]. KGraph [31] first adopts this idea to reduce KNNG’s construction complexity to "),s("em",null,"𝑂"),a("("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"S"),s("msup",null,[s("mi",{mathvariant:"normal"},"∣"),s("mn",null,"1.14")])]),s("annotation",{encoding:"application/x-tex"},"|S|^{1.14}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord"},[s("span",{class:"mord"},"∣"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"1.14")])])])])])])])])])])]),a(") on dataset "),s("em",null,"𝑆"),a(". It achieves better search performance than NSW [18]. Therefore, some NN-Descent-based derivatives are developed to explore its potential [23, 114, 115].")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A7: EFANNA and A8: IEH.")])])]),s("li",null,[s("p",null,"与在构建过程中进行随机初始化（如 KGraph）不同，极速近似最近邻搜索算法（EFANNA）[36]首先在(S)上构建多个 KD 树，并通过在这些 KD 树上进行近似最近邻搜索更好地初始化每个顶点的邻居，然后执行 NN-Descent。在搜索阶段，EFANNA 也使用这些 KD 树来获得更接近查询的种子。通过额外结构初始化种子的想法受到迭代扩展哈希（IEH）[54]的启发，IEH 使用哈希桶来获得更好的种子。然而，在[54]中，IEH 的 K 近邻图是通过暴力方法构建的。")]),s("li",null,[s("p",null,[a("Instead of random initialization during construction (such as KGraph), Extremely Fast Approximate Nearest Neighbor Search Algorithm ("),s("strong",null,"EFANNA"),a(") [36] first builds multiple KD-trees on "),s("em",null,"𝑆"),a(", and better initializes the neighbors of each vertex through ANNS on these KD-trees, then executes NN-Descent. At the search stage, EFANNA also uses these KD-trees to obtain seeds that are closer to the query. The idea of initializing seeds through additional structures is inspired by Iterative Expanding Hashing ("),s("strong",null,"IEH"),a(") [54], which uses hash buckets to obtain better seeds. However, IEH’s KNNG is constructed by brute force in [54].")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"KNNG-based and RNG-based ANNS algorithms (DPG, NSG,NSSG, Vamana).")])])]),s("li",null,[s("p",null,"早期对 KGraph 的优化仅限于提高图的质量[36,114]。他们的直觉是更高的图质量会带来更好的搜索性能。因此，每个顶点仅连接到(K)个最近邻，而不考虑邻居的分布。根据[62]的对比分析，如果一个访问顶点的邻居彼此接近，它将引导搜索到相同的位置。也就是说，将查询与所有彼此接近的邻居进行比较是冗余的[43,67]。")]),s("li",null,[s("p",null,[a("The early optimization of KGraph was limited to improving graph quality [36, 114]. Their intuition is that higher graph quality leads to better search performance. Hence, each vertex is only connected to "),s("em",null,"𝐾"),a(" nearest neighbors without considering the distribution of neighbors. According to the comparative analysis of [62], if neighbors of a visiting vertex are close to each other, it will guide the search to the same location. That is, it is redundant to compare the query to all neighbors close to each other [43, 67].")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A9: Diversified Proximity Graph (DPG)")])])]),s("li",null,[s("p",null,"为了克服上述问题，DPG（Dense Proximity Graph，密集近邻图）[61]进行优化以控制 KGraph 上邻居的分布。它设置一个顶点的邻居之间角度的阈值，以使邻居在顶点的所有方向上均匀分布。这只是从另一个方面对 RNG（Relative Neighborhood Graph，相对近邻图）的近似实现（证明见附录 C）。此外，为了处理具有大量聚类的数据集(S)，DPG 在图上保留双向边。")]),s("li",null,[s("p",null,[a("To overcome the aforementioned issue, DPG [61] practices optimization to control neighbors’ distribution on KGraph. It sets the threshold of the angle between the neighbors of a vertex to make the neighbors evenly distributed in all directions of the vertex. This is only an approximate implementation of RNG from another aspect (see Appendix C for the proof). In addition, to deal with "),s("em",null,"𝑆"),a(" with a large number of clusters, DPG keeps bi-directed edges on the graph.")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A10: Navigating Spreading-out Graph (NSG)")])])]),s("li",null,[s("p",null,"尽管 DPG 的搜索性能可与 HNSW 相媲美，但它的索引较大[38]。为了解决这个问题并进一步提高搜索性能，NSG（Navigable Small World Graph，可导航小世界图）[38]提出了一种基于单调 RNG（称为 MRNG）的边选择策略，实际上它与 HNSW 是等效的（证明见附录 A）。它的构建框架受到 DPG 的启发，即在 K 近邻图上修剪边。NSG 通过在 KGraph 上执行近似最近邻搜索以获得候选邻居，从而确保了高构建效率。NSG 已被集成到阿里巴巴的淘宝电子商务平台中，结合了卓越的索引构建和搜索性能[38]，并且其十亿规模的实现版本超过了当前最佳的 FAISS [55]。")]),s("li",null,[s("p",null,"Although DPG’s search performance is comparable to HNSW, it suffers from a large index [38]. To settle this problem and further improve search performance, NSG [38] proposes an edge selection strategy based on monotonic RNG (called MRNG), which is actually equivalent to HNSW’s (see Appendix A for the proof). Its construction framework is inspired by DPG; that is, to prune edges on KNNG. NSG ensures high construction efficiency by executing ANNS on KGraph to obtain candidate neighbors. NSG has been integrated into Alibaba’s Taobao e-commerce platform to combine superior index construction and search performance [38], and its billion-scale implementation version exceeds the current best FAISS [55].")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A11: Navigating Satellite System Graph (NSSG).")])])]),s("li",null,[s("p",null,"NSSG（New Searchable Small World Graph，新型可搜索小世界图）继续探索在 K 近邻图上修剪边的潜力，并提出了一种基于 SSG（Simplified Small World Graph，简化小世界图）的边选择策略。在获取顶点的候选邻居时，它不像 NSG 那样进行近似最近邻搜索，而是在 K 近邻图上获取该顶点的邻居以及邻居的邻居，这显著提高了构建效率。SSG 和 MRNG 都是对 RNG 的近似，但在切除冗余邻居时，SSG 相对较为宽松。因此，NSSG 具有更大的出度。尽管[37]认为 SSG 比 MRNG 对近似最近邻搜索更有利，但我们通过更公平的评估得出了相反的结论（详情见§5.4）。")]),s("li",null,[s("p",null,"NSSG continues to explore the potential of pruning edges on KNNG, and proposes an edge selection strategy based on SSG [37]. When obtaining a vertex’s candidate neighbors, instead of conducting the ANNS like NSG, it gets the neighbors and neighbors’ neighbors of the vertex on KNNG, which significantly improves construction efficiency. Both SSG and MRNG are approximations to RNG, but SSG is relatively relaxed when cutting redundant neighbors. Therefore, NSSG has a larger out-degree. Although [37] believes that SSG is more beneficial to ANNS than MRNG, we reach the opposite conclusion through a fairer evaluation (see §5.4 for details).")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A12: Vamana")])])]),s("li",null,[s("p",null,"微软最近提出了 Vamana [88]，用于与固态硬盘（SSD）结合处理数十亿的数据。它分析了 HNSW 和 NSG 的构建细节，提取并结合了其中更好的部分。它的构建框架受到 NSG 的启发。与 NSG 不同，Vamana 不是使用 KGraph 进行初始化，而是随机初始化。在选择邻居时，Vamana 通过添加一个参数(\\alpha)来改进 HNSW 的策略，以增加边选择的灵活性，并使用不同的(\\alpha)进行两次遍历。实验表明，其结果图在搜索时具有更短的平均路径长度，与 SSD 配合良好。")]),s("li",null,[s("p",null,[a("Microsoft recently proposed Vamana [88] to combine with solid-state drives (SSD) for billions of data. It analyzes the construction details of HNSW and NSG to extract and combine the better parts. Its construction framework is motivated by NSG. Instead of using KGraph to initialize like NSG, Vamana initializes randomly. When selecting neighbors, Vamana improves the HNSW’s strategy by adding a parameter "),s("em",null,"𝛼"),a(" to increase the edge selection’s flexibility and executing two passes with different "),s("em",null,"𝛼"),a(". Experiments show that its result graph has a shorter average path length when searching, which works well with SSD.")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"MST-based ANNS algorithms (HCNNG).")])])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"A13: HCNNG")])])]),s("li",null,[s("p",null,"与上述技术不同，最近一种名为基于层次聚类的最近邻图（Hierarchical Clustering-based Nearest Neighbor Graph，HCNNG）的方法[72]使用最小生成树（MST）来连接数据集(S)上的点。它使用与 SPTAG 相同的分治框架。不同之处在于，HCNNG 通过多个层次聚类对(S)进行划分，并且每个聚类中的所有点都通过最小生成树连接。HCNNG 使用多个全局 KD 树来获取种子（如 SPTAG 和 EFANNA）。然后，为了提高搜索效率，它执行高效的引导搜索，而不是使用传统的贪心搜索。")]),s("li",null,[s("p",null,[a("Different from the aforementioned techniques, a recent method called Hierarchical Clustering-based Nearest Neighbor Graph (HCNNG) [72] uses MST to connect the points on dataset "),s("em",null,"𝑆"),a(". It uses the same divide-and-conquer framework as SPTAG. The difference is that HCNNG divides "),s("em",null,"𝑆"),a(" through multiple hierarchical clusters, and all points in each cluster are connected through MST. HCNNG uses multiple global KD-trees to get seeds (like SPTAG and EFANNA). Then to improve search efficiency, rather than using traditional greedy search, it performs an efficient guided search.")])])],-1),X=l('<h2 id="_4-components-analysis" tabindex="-1"><a class="header-anchor" href="#_4-components-analysis" aria-hidden="true">#</a> <strong>4 COMPONENTS’ ANALYSIS</strong></h2><ul><li><p>尽管基于图的近似最近邻搜索算法多种多样，但它们都遵循一个统一的处理流程。如图 4 所示，一个算法可以分为两个粗粒度的组件：索引构建（上）和搜索（下），目前大多数工作都采用这种方式来分析算法[43,61,65,72]。最近的研究努力更深入地研究一些细粒度的组件[37,38]，促使他们找出算法的哪个部分起着核心作用，然后提出更好的算法。受此启发，我们将索引构建和搜索细分为七个细粒度的组件（图 4 中的 C1-C7），并通过这些组件对本文讨论的所有 13 种基于图的算法进行比较。</p></li><li><p>Despite the diversity of graph-based ANNS algorithms, they all follow a unified processing pipeline. As Figure 4 shows, an algorithm can be divided into two coarse-grained components: index construction (top) and search (bottom), which are adopted by most of the current work to analyze algorithms [43, 61, 65, 72].</p></li><li><p>Recent research has endeavored to take a deeper look at some fine-grained components [37, 38], prompting them to find out which part of an algorithm plays a core role and then propose better algorithms. Motivated by this, we subdivide the index construction and search into seven fine-grained components (<strong>C1–C7</strong> in Figure 4), and compare all 13 graph-based algorithms discussed in this paper by them.</p></li><li><figure><img src="'+x+'" alt="figure4" tabindex="0" loading="lazy"><figcaption>figure4</figcaption></figure></li></ul><h3 id="_4-1-components-for-index-construction" tabindex="-1"><a class="header-anchor" href="#_4-1-components-for-index-construction" aria-hidden="true">#</a> <strong>4.1 Components for Index Construction</strong></h3><ul><li><p>索引构建的目的是用图来组织数据集(S)。现有的算法通常分为三种策略：分治策略[96]、细化策略[32]和增量策略[42]（见附录 E）。如图 4（上）所示，一个算法的索引构建可以分为五个详细的组件（C1 - C5）。其中，根据不同的构建策略，初始化可以分为三种方式。</p></li><li><p>The purpose of index construction is to organize the dataset <em>𝑆</em> with a graph. Existing algorithms are generally divided into three strategies: <strong>Divide-and-conquer</strong> [96], <strong>Refinement</strong> [32], and <strong>Increment</strong> [42] (see Appendix E). As Figure 4 (top) show, an algorithm’s index construction can be divided into five detailed components (<strong>C1–C5</strong>). Among them, <em>initialization</em> can be divided into three ways according to different construction strategies.</p></li></ul><br><h4 id="c1-initialization" tabindex="-1"><a class="header-anchor" href="#c1-initialization" aria-hidden="true">#</a> C1: Initialization.</h4><ul><li><mark><strong>Overview.</strong></mark></li><li>- 分治策略的“初始化”是“数据集划分”；它通过递归进行以生成许多子图，从而通过子图合并获得索引[26,84]。 - 对于细化策略，在“初始化”中，它执行“邻居初始化”以获得初始化的图，然后细化初始化的图以实现更好的搜索性能[36,38]。 - 而增量策略不断插入点，新进入的点被视为查询，然后它执行近似最近邻搜索以在由先前插入的点构建的子图上获得查询的邻居[65,67]；因此，它在“初始化”期间实现“种子获取”。</li><li>The <em>initialization</em> of <strong>Divide-and-conquer</strong> is <em>dataset</em> <em>division</em>; it is conducted recursively to generate many subgraphs so that the index is obtained by subgraph merging [26, 84].</li><li>For <strong>Refinement</strong>, in the <em>initialization</em>, it performs <em>neighbor initialization</em> to get the initialized graph, then refines the initialized graph to achieve better search performance [36, 38].</li><li>While the <strong>Increment</strong> inserts points continuously, the new incoming point is regarded as a query, then it executes ANNS to obtain the query’s neighbors on the subgraph constructed by the previously inserted points [65, 67]; it therefore implements <em>seed acquisition</em> during <em>initialization</em>.</li></ul><br><ul><li><p><mark><em>Definition 4.1.</em> <strong>Dataset Division.</strong></mark> Given dataset <em>𝑆</em>, the <em>dataset</em> <em>division</em> divides <em>𝑆</em> into <em>𝑚</em> small subsets—i.e., <em>𝑆</em>0*, 𝑆<em>1</em>,* · · · <em>, 𝑆𝑚</em>−1, and <em>𝑆</em>0 ∪ <em>𝑆</em>1 · · · ∪ <em>𝑆𝑚</em>−1 = <em>𝑆</em>.</p></li><li><p><mark><strong>Data division.</strong></mark></p></li><li><p>这是分治策略的一种独特初始化。SPTAG 先前采用随机划分方案，在从(S)中随机采样的点上生成主方向，然后进行随机划分以使每个子集的直径足够小[95,100]。为了实现更好的划分，SPTAG 转向 TP-tree[101]，其中通过几个坐标轴的线性组合形成划分超平面，权重为-1 或 1。HCNNG 通过迭代执行层次聚类来划分(S)。具体来说，它每次从待划分的集合中随机选取两个点，并通过计算其他点与这两个点之间的距离进行划分[72]。</p></li><li><p>This is a unique <em>initialization</em> of the <strong>Divide-and</strong> <strong>conquer</strong> strategy. SPTAG previously adopts a random division scheme, which generates the principal directions over points randomly sampled from <em>𝑆</em>, then performs random divisions to make each subset’s diameter small enough [95, 100]. To achieve better division, SPTAG turns to TP-tree [101], in which a partition hyperplane is formed by a linear combination of a few coordinate axes with weights being -1 or 1. HCNNG divides <em>𝑆</em> by iteratively performing hierarchical clustering. Specifically, it randomly takes two points from the set to be divided each time, and performs division by calculating the distance between other points and the two [72].</p></li></ul><br><ul><li><mark><em>Definition 4.2.</em> <strong>Neighbor Initialization.</strong></mark> Given dataset <em>𝑆</em>, for ∀<em>𝑝</em> ∈ <em>𝑆</em>, the <em>neighbor initialization</em> gets the subset <em>𝐶</em> from <em>𝑆</em> \\ {<em>𝑝</em>}, and initializes <em>𝑁</em> (<em>𝑝</em>) with <em>𝐶</em>.</li><li><mark><strong>Neighbor initialization.</strong></mark></li><li>只有“细化”策略的“初始化”需要这种实现。KGraph 和 Vamana 都通过随机选择邻居来实现这个过程[31,88]。这种方法效率高，但初始图的质量太低。解决方案是通过基于哈希的[93]或基于树的[36]方法的近似最近邻搜索来初始化邻居。EFANNA 采用后者；它在(S)上建立多个 KD 树。然后，每个点被视为一个查询，并通过在多个 KD 树上的近似最近邻搜索获得其邻居[36]。这种方法严重依赖额外的索引，增加了索引构建的成本。因此，NSG、DPG 和 NSSG 采用 NN-Descent[32]；它们首先为每个点随机选择邻居，然后通过邻域传播更新每个点的邻居。最后，通过少量迭代获得高质量的初始图。特别地，FANNG 和 IEH 通过线性扫描初始化邻居。</li><li>Only the <em>initialization</em> of the <strong>Refinement</strong> strategy requires this implementation. Both KGraph and Vamana implement this process by randomly selecting neighbors [31,88]. This method offers high efficiency but the initial graph quality is too low. The solution is to initialize neighbors through ANNS based on hash-based [93] or tree-based [36] approaches. EFANNA deploys the latter; it establishes multiple KD-trees on <em>𝑆</em>. Then, each point is treated as a query, and get its neighbors through ANNS on multiple KD-trees [36]. This approach relies heavily on extra index and increases the cost of index construction. Thus, NSG, DPG, and NSSG deploy the NN-Descent [32]; they first randomly select neighbors for each point, and then update each point’s neighbors with neighborhood propagation. Finally, they get a high-quality initial graph by a small number of iterations. Specially, FANNG and IEH initialize neighbors via linear scan.</li></ul><br>',12),Y=s("ul",null,[s("li",null,[s("mark",null,[s("em",null,"Definition 4.3."),a(),s("strong",null,"Seed Acquisition.")]),a(" Given the index "),s("em",null,"𝐺"),a("("),s("em",null,"𝑉 , 𝐸"),a("), the seed acquisition acquires a small subset "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8833em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8833em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])]),s("span",{style:{top:"-3.8033em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(" from "),s("em",null,"𝑉"),a(" as the seed set, and ANNS on "),s("em",null,"𝐺"),a(" starts from "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8833em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8833em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])]),s("span",{style:{top:"-3.8033em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(" .")]),s("li",null,[s("mark",null,[s("strong",null,"Seed acquisition.")])]),s("li",null,"索引构建的种子获取是增量策略的初始化。另外两种策略在获取候选邻居时也可能包括这个过程，并且这个过程对于搜索中的所有基于图的算法也是必要的。对于索引构建，NSW 和 NGT 都是随机获取种子[46,65]，而 HNSW 由于其独特的分层结构，使其种子点从顶层固定[67]。"),s("li",null,[a("The "),s("em",null,"seed acquisition"),a(" of the index construction is "),s("strong",null,"Increment"),a(" strategy’s "),s("em",null,"initialization"),a(". The other two strategies may also include this process when acquiring candidate neighbors, and this process also is necessary for all graph-based algorithms in the search. For index construction, both NSW and NGT obtain seeds randomly [46, 65], while HNSW makes its seed points fixed from the top layer because of its unique hierarchical structure [67].")])],-1),Z=l('<br><ul><li><mark><em>Definition 4.4.</em> <strong>Candidate Neighbor Acquisition</strong></mark> Given a finite dataset <em>𝑆</em>, point <em>𝑝</em> ∈ <em>𝑆</em>, the <em>candidate neighbor acquisition</em> gets a subset C from <em>𝑆</em> \\ {<em>𝑝</em>} as <em>𝑝</em>’s candidate neighbors, and <em>𝑝</em> get its neighbors <em>𝑁</em> (<em>𝑝</em>) from C—that is, <em>𝑁</em> (<em>𝑝</em>) ⊂ C.</li></ul><h4 id="c2-candidate-neighbor-acquisition" tabindex="-1"><a class="header-anchor" href="#c2-candidate-neighbor-acquisition" aria-hidden="true">#</a> <strong>C2: Candidate neighbor acquisition</strong></h4>',3),J=s("ul",null,[s("li",null,"分治策略构建的图通常从数据集划分后得到的一个小子集中产生候选邻居。对于一个子集(S_i⊂S)和一个点(p∈S_i)，SPTAG 和 HCNNG 直接将(S_i\\setminus{p})作为候选邻居[72,100]。虽然(\\vert S\\vert)可能很大，但通过划分得到的(\\vert S_i\\vert)通常很小。然而，细化和增量策略不涉及数据集划分的过程，这导致 IEH 和 FANNG 采用朴素方法获取候选邻居时索引构建效率较低[43,54]。为了解决这个问题，NGT、NSW、HNSW、NSG 和 Vamana 都通过近似最近邻搜索（ANNS）获取候选邻居。对于一个点(p∈S)，由先前插入的点形成的图(G_{sub})（增量策略）或初始化的图(G_{init})（细化策略），它们将(p)作为查询在(G_{sub})或(G_{init})上执行近似最近邻搜索，并最终将查询结果作为(p)的候选邻居返回。这种方法只需要访问(S)的一个小的子集。然而，根据[100]的分析，通过近似最近邻搜索获取候选邻居有些过头了，因为索引构建中的查询是在(S)中，但近似最近邻搜索的查询通常不属于(S)。相比之下，KGraph、EFANNA 和 NSSG 将(p)在(G_{init})上的邻居以及邻居的邻居作为其候选邻居[37]，这提高了索引构建效率。DPG 直接将(p)在(G_{init})上的邻居作为候选邻居，但为了获得足够的候选邻居，通常需要(G_{init})具有较大的出度[61]。"),s("li",null,[a("The graph constructed by the "),s("strong",null,"Divide-and-conquer"),a(" generally produce candidate neighbors from a small subset obtained after "),s("em",null,"dataset division"),a(". For a subset "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"S"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"S_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0576em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" ⊂ "),s("em",null,"𝑆"),a(" and a point "),s("em",null,"𝑝"),a(" ∈ "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"S"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"S_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0576em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" , SPTAG and HCNNG directly take "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"S"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"S_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0576em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" \\ {"),s("em",null,"𝑝"),a("} as candidate neighbors [72, 100]. Although |"),s("em",null,"𝑆"),a(" | may be large, the |"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"S"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"S_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0576em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" | obtained by the division is generally small.")]),s("li",null,[a("However, "),s("strong",null,"Refinement"),a(" and "),s("strong",null,"Increment"),a(" do not involve the process of "),s("em",null,"dataset"),a(),s("em",null,"division"),a(", which leads to low index construction efficiency for IEH and FANNG to adopt the naive method of obtaining candidate neighbors [43, 54]. To solve this problem, NGT, NSW, HNSW, NSG, and Vamana all obtain candidate neighbors through ANNS.")]),s("li",null,[a("For a point "),s("em",null,"𝑝"),a(" ∈ "),s("em",null,"𝑆"),a(", the graph "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"s"),s("mi",null,"u"),s("mi",null,"b")])])]),s("annotation",{encoding:"application/x-tex"},"G_{sub}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"s"),s("span",{class:"mord mathnormal mtight"},"u"),s("span",{class:"mord mathnormal mtight"},"b")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" ("),s("strong",null,"Increment"),a(") formed by the previously inserted points or the initialized graph "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" ("),s("strong",null,"Refinement"),a("), they consider "),s("em",null,"𝑝"),a(" as a query and execute ANNS on "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"s"),s("mi",null,"u"),s("mi",null,"b")])])]),s("annotation",{encoding:"application/x-tex"},"G_{sub}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"s"),s("span",{class:"mord mathnormal mtight"},"u"),s("span",{class:"mord mathnormal mtight"},"b")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" or "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(", and finally return the query result as candidate neighbors of "),s("em",null,"𝑝"),a(". This method only needs to access a small subset of "),s("em",null,"𝑆"),a(". However, according to the analysis of [100], obtaining candidate neighbors through ANNS is overkill, because the query is in "),s("em",null,"𝑆"),a(" for index construction, but the ANNS query generally does not belong to "),s("em",null,"𝑆"),a(". In contrast, KGraph, EFANNA, and NSSG use the neighbors of "),s("em",null,"𝑝"),a(" and neighbors’ neighbors on "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" as its candidate neighbors [37], which improves index-construction efficiency. DPG directly uses the neighbors of "),s("em",null,"𝑝"),a(" on "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" as candidate neighbors, but to obtain enough candidate neighbors, it generally requires "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" with a larger out-degree [61].")])],-1),$=l('<br><ul><li><mark><em>Definition 4.5.</em> <strong>Neighbor Selection.</strong></mark> Given a point <em>𝑝</em> and its candidate neighbors C, the <em>neighbor selection</em> obtains a subset of C to update <em>𝑁</em> (<em>𝑝</em>).</li></ul><h4 id="c3-neighbor-selection" tabindex="-1"><a class="header-anchor" href="#c3-neighbor-selection" aria-hidden="true">#</a> <strong>C3: Neighbor selection</strong></h4>',3),ss=s("ul",null,[s("li",null,[s("p",null,"当前基于图的近似最近邻搜索算法在这个组件中主要考虑两个因素：距离和空间分布。给定(p∈S)，距离因素确保选择的邻居尽可能接近(p)，而空间分布因素使邻居在(p)的各个方向上尽可能均匀分布。NSW、SPTAG1、NGT1、KGraph、EFANNA 和 IEH 仅考虑距离因素，旨在构建高质量的图索引[32,100]。HNSW2、FANNG、SPTAG3 和 NSG2 通过评估邻居之间的距离来考虑空间分布因素，形式上，对于(x∈C)，对于所有(y∈N(p))，如果(\\delta(x,y)>\\delta(y,p))，则(x)将加入(N(p))[38,43]。为了更灵活地选择邻居，Vamana 添加了参数(\\alpha)，使得对于(x∈C)，对于所有(y∈N(p))，如果(\\alpha·\\delta(x,y)>\\delta(y,p))（(\\alpha≥1)），则(x)将被添加到(N(p))中，因此它可以通过调整(\\alpha)很好地控制邻居的分布。DPG 获得(C)的一个子集以最小化任意两点之间的角度总和，从而分散邻居分布[61]。NSSG 通过设置角度阈值(\\theta)来考虑空间分布因素，对于(x∈C)，对于所有(y∈N(p))，如果(\\arccos(x,y)<\\theta)，则(x)将加入(N(p))。NGT3 通过路径调整间接实现邻居的均匀分布，它通过判断点(p)与其在(G_{init})上的邻居之间是否存在替代路径来更新邻居[48]。HCNNG 通过在({p}∪C)上构建最小生成树来为(p)选择邻居[72]。最近，[13,110]通过学习进行邻居选择，但这些方法由于训练成本极高而难以在实际中应用。")]),s("li",null,[s("p",null,[a("The current graph-based ANNS algorithms mainly consider two factors for this component: distance and space distribution. Given "),s("em",null,"𝑝"),a(" ∈ "),s("em",null,"𝑆"),a(", the distance factor ensures that the selected neighbors are as close as possible to "),s("em",null,"𝑝"),a(", while the space distribution factor makes the neighbors distribute as evenly as possible in all directions of "),s("em",null,"𝑝"),a(".")])]),s("li",null,[s("p",null,[a("NSW, SPTAG , NGT, KGraph, EFANNA, and IEH only consider the distance factor and aim to build a high-quality graph index [32, 100]. HNSW , FANNG, SPTAG , and NSG consider the space distribution factor by evaluating the distance between neighbors, formally, for "),s("em",null,"𝑥"),a(" ∈ C, ∀"),s("em",null,"𝑦"),a(" ∈ "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a("), iff "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑥, 𝑦"),a(") "),s("em",null,">"),a(),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑦, 𝑝"),a("), "),s("em",null,"𝑥"),a(" will join "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a(") [38, 43]. To select neighbors more flexibly, Vamana adds the parameter "),s("em",null,"𝛼"),a(" so that for "),s("em",null,"𝑥"),a(" ∈ C, ∀"),s("em",null,"𝑦"),a(" ∈ "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a("), iff "),s("em",null,"𝛼"),a(" · "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑥, 𝑦"),a(") "),s("em",null,">"),a(),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑦, 𝑝"),a(")"),s("em",null,","),a(" ("),s("em",null,"𝛼"),a(" ≥ 1), "),s("em",null,"𝑥"),a(" will be added to "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a(") [88], so it can control the distribution of neighbors well by adjusting "),s("em",null,"𝛼"),a(".")])]),s("li",null,[s("p",null,[a("DPG obtains a subset of C to minimize the sum of angles between any two points, thereby dispersing the neighbor distribution [61]. NSSG considers the space distribution factor by setting an angle threshold "),s("em",null,"𝜃"),a(", for "),s("em",null,"𝑥"),a(" ∈ C, ∀"),s("em",null,"𝑦"),a(" ∈ "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a("), iff arccos("),s("em",null,"𝑥, 𝑦"),a(") "),s("em",null,"<"),a(),s("em",null,"𝜃"),a(", "),s("em",null,"𝑥"),a(" will join "),s("em",null,"𝑁"),a(" ("),s("em",null,"𝑝"),a("). NGT indirectly attains the even distribution of neighbors with path adjustment [48], which updates neighbors by judging whether there is an alternative path between point "),s("em",null,"𝑝"),a(" and its neighbors on "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"G"),s("mrow",null,[s("mi",null,"i"),s("mi",null,"n"),s("mi",null,"i"),s("mi",null,"t")])])]),s("annotation",{encoding:"application/x-tex"},"G_{init}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"G"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ini"),s("span",{class:"mord mathnormal mtight"},"t")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(". HCNNG selects neighbors for "),s("em",null,"𝑝"),a(" by constructing an MST on {"),s("em",null,"𝑝"),a("} ∪ C [72]. Recently, [13, 110] perform neighbor selection through learning, but these methods are difficult to apply in practice because of their extremely high training costs.")])])],-1),as=l('<h4 id="c4-seed-preprocessing" tabindex="-1"><a class="header-anchor" href="#c4-seed-preprocessing" aria-hidden="true">#</a> <strong>C4: Seed preprocessing</strong></h4><ul><li>不同的算法在这个组件和连接性之间可能存在不同的执行顺序，例如 NSW[65]、NSG[38]。通常，基于图的近似最近邻搜索算法以静态或动态的方式实现这个组件。对于静态方法，典型代表是 HNSW、NSG、Vamana 和 NSSG。HNSW 将顶层顶点固定为种子，NSG 和 Vamana 使用(S)的近似质心作为种子，NSSG 的种子是随机选择的顶点。而对于动态方法，一种常见的做法是附加其他索引（即对于每个查询，通过一个额外的索引获得接近查询的种子）。SPTAG、EFANNA、HCNNG 和 NGT 构建额外的树，如 KD 树[27,36]、平衡 k 均值树[27]和 VP 树[46]。IEH 通过哈希[54]为种子获取做准备。然后[33]通过 OPQ[39]压缩原始向量，通过快速计算压缩向量来获得种子。KGraph、FANNG、NSW 和 DPG 采用随机种子获取，并且它们不需要实现种子预处理。</li><li>Different algorithms may exist with different execution sequences between this component and the <em>connectivity</em>, such as NSW [65], NSG [38]. Generally, graph-based ANNS algorithms implement this component in a static or dynamic manner.</li><li>For the static method, typical representatives are HNSW, NSG, Vamana, and NSSG. HNSW fixes the top vertices as the seeds, NSG and Vamana use the approximate centroid of <em>𝑆</em> as the seed, and the seeds of NSSG are randomly selected vertices.</li><li>While for the dynamic method, a common practice is to attach other indexes (i.e., for each query, the seeds close to the query are obtained through an additional index). SPTAG, EFANNA, HCNNG, and NGT build additional trees, such as KD-tree [27, 36], balanced k-means tree [27], and VP-tree [46]. IEH prepares for <em>seed acquisition</em> through hashing [54]. Then [33] compresses the original vector by OPQ [39] to obtain the seeds by quickly calculating the compressed vector.</li><li>Random <em>seed acquisition</em> is adopted by KGraph, FANNG, NSW, and DPG, and they don’t need to implement <em>seed preprocessing</em></li></ul><h4 id="c5-connectivity" tabindex="-1"><a class="header-anchor" href="#c5-connectivity" aria-hidden="true">#</a> <strong>C5: Connectivity.</strong></h4><ul><li>“增量”策略在内部确保连接性（例如 NSW）。“细化”通常附加深度优先遍历来实现这一点（例如 NSG）。“分治”通常通过多次执行“数据集划分”和子图构建来确保连接性（例如 SPTAG）。</li><li><strong>Incremental</strong> strategy internally ensures connectivity (e.g., NSW).</li><li><strong>Refinement</strong> generally attaches depth-first traversal to achieve this [38] (e.g., NSG).</li><li><strong>Divide-and-conquer</strong> generally ensures connectivity by multiply performing <em>dataset division</em> and subgraph construction (e.g., SPTAG).</li></ul><h3 id="_4-2-components-for-search" tabindex="-1"><a class="header-anchor" href="#_4-2-components-for-search" aria-hidden="true">#</a> <strong>4.2 Components for Search</strong></h3><ul><li>We subdivide the search into two fine-grained components (<strong>C6–C7</strong>): <em>seed acquisition</em> and <em>routing</em>.</li></ul><h4 id="c6-seed-acquisition" tabindex="-1"><a class="header-anchor" href="#c6-seed-acquisition" aria-hidden="true">#</a> <strong>C6: Seed acquisition</strong></h4>',7),ts=s("ul",null,[s("li",null,[s("p",null,"由于种子对搜索有重大影响，所以搜索过程的这个组件比“增量”策略的初始化更受关注。一些早期算法随机获取种子，而最先进的算法通常使用种子预处理。如果在预处理阶段生成固定的种子，那么在这个组件可以直接加载这些种子。如果在预处理阶段构建了其他索引结构，近似最近邻搜索会通过附加结构返回种子。")]),s("li",null,[s("p",null,[a("Because the seed has a significant impact on search, this component of the search process is more concerned than the "),s("em",null,"initialization"),a(" of "),s("strong",null,"Incremental"),a(" strategy. Some early algorithms obtain the seeds randomly, while state-of-the-art algorithms commonly use "),s("em",null,"seed preprocessing"),a(". If the fixed seeds are produced in the preprocessing stage, it can be loaded directly at this component. If other index structures are constructed in the preprocessing stage, ANNS returns the seeds with the additional structure.【附加结构进行获取 seed acquisition】")])]),s("li",null,[s("p",null,[s("mark",null,[s("em",null,"Definition 4.6."),a(),s("strong",null,"Routing")]),a(" Given "),s("em",null,"𝐺"),a("("),s("em",null,"𝑉 , 𝐸"),a("), query "),s("em",null,"𝑞"),a(", seed set "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8833em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8833em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])]),s("span",{style:{top:"-3.8033em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(", the "),s("em",null,"routing"),a(" starts from the vertices in "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8833em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8833em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])]),s("span",{style:{top:"-3.8033em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(",, and then converges to "),s("em",null,"𝑞"),a(" by neighbor propagation along the neighbor "),s("em",null,"𝑛"),a(" of the visited point with smaller "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑛, 𝑞"),a("), until the vertex "),s("em",null,"𝑟"),a(" so that "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑟, 𝑞"),a(") reaches a minimum.")])]),s("li",null,[s("p",null,[s("mark",null,[s("em",null,"Definition 4.7."),a(),s("strong",null,"Best First Search")])])]),s("li",null,[s("p",null,[a("Given "),s("em",null,"𝐺"),a("("),s("em",null,"𝑉 , 𝐸"),a("), query "),s("em",null,"𝑞"),a(", and vertices to be visited C, its maximum size is "),s("em",null,"𝑐"),a(" and the result set R. We initialize C and R with seed set "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"S"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{S}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8833em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8833em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])]),s("span",{style:{top:"-3.8033em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(". For "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(" = arg "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m"),s("mi",null,"i"),s("msub",null,[s("mi",null,"n"),s("mrow",null,[s("mi",null,"x"),s("mo",null,"∈"),s("mi",null,"C")])])]),s("annotation",{encoding:"application/x-tex"},"min_{x∈C}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8369em","vertical-align":"-0.1774em"}}),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"x"),s("span",{class:"mrel mtight"},"∈"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.07153em"}},"C")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1774em"}},[s("span")])])])])])])])]),a(),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑥, 𝑞"),a("), best first search access "),s("em",null,"𝑁"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("), then C \\ {"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("} and C ∪ "),s("em",null,"𝑁"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("). To keep |C| = "),s("em",null,"𝑐"),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"y"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{y}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.825em","vertical-align":"-0.1944em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1944em"}},[s("span")])])])])])])]),a(" = arg max"),s("em",null,"𝑦"),a("∈C "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑦, 𝑞"),a(") will be deleted. ∀"),s("em",null,"𝑛"),a(" ∈ "),s("em",null,"𝑁"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("), if "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑛, 𝑞"),a(") "),s("em",null,"<"),a(),s("em",null,"𝛿"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"z"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{z}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(", "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"q"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{q}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.825em","vertical-align":"-0.1944em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1944em"}},[s("span")])])])])])])]),a(" )*, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"z"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{z}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(" = arg "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m"),s("mi",null,"a"),s("msub",null,[s("mi",null,"x"),s("mrow",null,[s("mi",null,"z"),s("mo",null,"∈"),s("mi",null,"R")])])]),s("annotation",{encoding:"application/x-tex"},"max_{z∈R}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6079em","vertical-align":"-0.1774em"}}),s("span",{class:"mord mathnormal"},"ma"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mrel mtight"},"∈"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1774em"}},[s("span")])])])])])])])]),a(),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑧, 𝑞"),a("), then R \\ {"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"z"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{z}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("} and R ∪ {"),s("em",null,"𝑛"),a("}. The aforementioned process is performed iteratively until R is no longer updated. (see Appendix F for the pseudocode)【就是贪婪，C是候选队列】")])])],-1),es=s("h4",{id:"c7-routing",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#c7-routing","aria-hidden":"true"},"#"),a(),s("strong",null,"C7: Routing")],-1),ns=s("ul",null,[s("li",null,"几乎所有基于图的近似最近邻搜索算法都基于贪婪路由策略，包括最佳优先搜索（BFS）及其变体。NSW、HNSW、KGraph、IEH、EFANNA、DPG、NSG、NSSG 和 Vamana 使用原始的 BFS 进行路由。尽管这种方法便于部署，但它有两个缺点：易受局部最优影响（S1）[14]和路由效率低（S2）[72]。S1 会破坏搜索结果的准确性。对于这个问题，FANNG 在 BFS 中添加了回溯，这在稍微提高搜索准确性的同时显著增加了搜索时间[43]。NGT 通过添加参数(\\epsilon)来缓解 S1。在定义 4.7 的基础上，它取消了对 C 的大小限制，并将(\\delta(y,q^{\\wedge}))作为搜索半径(r)，对于(\\forall n\\in N(x^{\\wedge}))，如果(\\delta(n,q)<(1+\\epsilon)\\cdot r)，那么(n)被添加到 C 中。将(\\epsilon)设置为较大的值可以缓解 S1，但也会显著增加搜索时间[48]。SPTAG 通过迭代执行 BFS 来解决 S1。当某一次迭代陷入局部最优时，它将从 KD 树中选择新的种子重新开始搜索[98]。HCNNG 提出使用引导搜索来缓解 S2，而不是像 BFS 那样访问所有的(N(x^{\\wedge}))，所以引导搜索根据查询的位置避免了一些冗余的访问。最近，一些文献使用学习方法进行路由[14,59,94]。这些方法通常同时缓解 S1 和 S2，但不利影响是这需要额外的训练，并且额外的信息也增加了内存开销（见第 5.5 节）。"),s("li",null,[a("Almost all graph-based ANNS algorithms are based on a greedy "),s("em",null,"routing"),a(" strategy, including best first search (BFS) and its variants. NSW, HNSW, KGraph, IEH, EFANNA, DPG, NSG, NSSG, and Vamana use the original BFS to perform "),s("em",null,"routing"),a(". Despite this method being convenient for deployment, it has two shortcomings: susceptibility to local optimum (S1) [14] and low routing efficiency (S2) [72]. S1 destroys the search results’ accuracy.")]),s("li",null,[a("For this problem, FANNG adds backtracking to BFS, which slightly improves the search accuracy while significantly increasing the search time [43]. NGT alleviates S1 by adding a parameter "),s("em",null,"𝜖"),a(". On the basis of Definition 4.7, it cancels the size restriction on C and takes "),s("em",null,"𝛿"),a(" (𝑦, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"q"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{q}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.825em","vertical-align":"-0.1944em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1944em"}},[s("span")])])])])])])]),a(") as the search radius "),s("em",null,"𝑟"),a(", for ∀"),s("em",null,"𝑛"),a(" ∈ "),s("em",null,"𝑁"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a("), if "),s("em",null,"𝛿"),a(" ("),s("em",null,"𝑛, 𝑞"),a(") "),s("em",null,"<"),a(" (1 + "),s("em",null,"𝜖"),a(") · "),s("em",null,"𝑟"),a(", then "),s("em",null,"𝑛"),a(" is added to C. Setting "),s("em",null,"𝜖"),a(" to a larger value can alleviate S1, but it will also significantly increase the search time [48].")]),s("li",null,[a("SPTAG solves S1 by iteratively executing BFS. When a certain iteration falls into a local optimum, it will restart the search by selecting new seeds from the KD-tree [98]. HCNNG proposes using guided search to alleviate S2 rather than visiting all "),s("em",null,"𝑁"),a(" ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mover",{accent:"true"},[s("mi",null,"x"),s("mo",{stretchy:"true"},"‾")])]),s("annotation",{encoding:"application/x-tex"},"\\overline{x}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6306em"}}),s("span",{class:"mord overline"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6306em"}},[s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"x")])]),s("span",{style:{top:"-3.5506em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"overline-line",style:{"border-bottom-width":"0.04em"}})])])])])])])])]),a(") like BFS, so guided search avoids some redundant visits based on the query’s location.")]),s("li",null,"Recently, some of the literature uses learning methods to perform routing [14, 59, 94]. These methods usually alleviate S1 and S2 simultaneously, but the adverse effect is that this requires extra training, and additional information also increases the memory overhead (see §5.5).")],-1),ls=l('<h2 id="_5-experimental-evaluation" tabindex="-1"><a class="header-anchor" href="#_5-experimental-evaluation" aria-hidden="true">#</a> <strong>5 EXPERIMENTAL EVALUATION</strong></h2><ul><li><p>本节对基于图的近似最近邻搜索算法中的单个算法（§3）和从算法中提取的组件（§4）进行了丰富的实验研究。由于篇幅限制，我们的一些实验内容在附录中提供。我们的评估旨在回答以下问题：</p></li><li><p>This section presents an abundant experimental study of both individual algorithms (§3) and components (§4) extracted from the algorithms for graph-based ANNS. Because of space constraints, some of our experimental content is provided in appendix. Our evaluation seeks to answer the following question:</p><ul><li><strong>Q1:</strong> How do the algorithms perform in different scenarios? (§5.2–5.3)</li><li><strong>Q2:</strong> Can an algorithm have the best index construction and search performance at the same time? (§5.2–5.3)</li><li><strong>Q3:</strong> For an algorithm with the best overall performance, is the performance of each fine-grained component also the best? (§5.4)</li><li><strong>Q4:</strong> How do machine learning-based optimizations affect the performance of the graph-based algorithms? (§5.5)</li><li><strong>Q5:</strong> How can we design a better graph-based algorithm based on the experimental observations and verify its performance? (§6)</li></ul></li></ul><h3 id="_5-1-experimental-setting" tabindex="-1"><a class="header-anchor" href="#_5-1-experimental-setting" aria-hidden="true">#</a> <strong>5.1 Experimental Setting</strong></h3>',3),is=s("ul",null,[s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Datasets")])])]),s("li",null,[s("p",null,"我们的实验涉及现有工作中广泛使用的八个真实世界数据集，这些数据集涵盖了各种应用，如视频（UQ-V [5]）、音频（Msong [2]、Audio [4]）、文本（Crawl [3]、GloVe [51]、Enron [81]）和图像（SIFT1M [1]、GIST1M [1]）。它们的主要特征总结在表 3 中。“基数”是基础数据集中元素的数量。局部本征维度（LID）表示局部本征维度，LID 值越大意味着数据集“更难”[61]。此外，还使用了 12 个合成数据集来测试每个算法对不同数据集性能（例如维度、基数、聚类数量以及每个聚类中分布的标准差[85]）的可扩展性。出于篇幅考虑，请参见附录 J 中的可扩展性评估。实验中的所有数据集都被处理为基础数据集、查询数据集和真实数据集。")]),s("li",null,[s("p",null,[a("Our experiment involves eight real-world datasets popularly deployed by existing works, which cover various applications such as video ("),s("strong",null,"UQ-V"),a(" [5]), audio ("),s("strong",null,"Msong"),a(" [2], "),s("strong",null,"Audio"),a(" [4]), text ("),s("strong",null,"Crawl"),a(" [3], "),s("strong",null,"GloVe"),a(" [51], "),s("strong",null,"Enron"),a(" [81]), and image ("),s("strong",null,"SIFT1M"),a(" [1],"),s("strong",null,"GIST1M"),a(" [1]). Their main characteristics are summarized in Table 3.")])]),s("li",null,[s("p",null,"# Base is the number of elements in the base dataset. LID indicates local intrinsic dimensionality, and a larger LID value implies a “harder” dataset [61]. Additionally, 12 synthetic datasets are used to test each algorithm’s scalability to different datasets’ performance (e.g., dimensionality, cardinality, number of clusters, and standard deviation of the distribution in each cluster [85]). Out of space considerations, please see the scalability evaluation in Appendix J. All datasets in the experiment are processed into the base dataset, query dataset, and ground-truth dataset.")]),s("li",null,[s("figure",null,[s("img",{src:w,alt:"table3",tabindex:"0",loading:"lazy"}),s("figcaption",null,"table3")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Compared algorithms")])])]),s("li",null,[s("p",null,"我们的实验评估了§3中提到的13种具有代表性的基于图的近似最近邻搜索算法，这些算法是从研究文献和实际项目中精心挑选出来的。这些算法的主要属性和实验参数在附录E和附录F中介绍。")]),s("li",null,[s("p",null,"Our experiment evaluates 13 representative graph-based ANNS algorithms mentioned in §3, which are carefully selected from research literature and practical projects. The main attributes and experimental parameters of these algorithms are introduced in Appendix E and Appendix F.")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Evaluation metrics")])])]),s("li",null,[s("p",null,"- 为了衡量算法的整体性能，我们采用了与索引构建和搜索相关的各种指标。对于索引构建，我们评估索引构建效率和大小。记录一些索引特征，如“图质量”、“平均出度”和“连通分量的数量”；它们间接影响索引构建效率和大小。给定一个在相同数据集上的近似图(G'(V',E'))（算法的图索引）和精确图(G(V,E))，我们将一个索引的“图质量”定义为(\\frac{|E'∩E|}{|E|})[21,26,97]。对于搜索，我们评估搜索效率、准确性和内存开销。搜索效率可以通过“每秒查询数（QPS）”和“加速比”来衡量。 - “QPS”是查询数量（(#q)）与搜索时间（(t)）的比值，即(\\frac{q}{t})[38]。“加速比”定义为(\\frac{|S|}{NDC})，其中(|S|)是数据集的大小，也是线性扫描一次查询的距离计算次数，(NDC)是算法一次查询的距离计算次数（在定义 2.2 中等于(|C|)）[72]。我们使用“召回率”来评估搜索准确性，其定义为(\\frac{|R∪T|}{|T|})，其中(R)是算法的查询结果集，(T)是真实结果集，且(|R| = |T|)。我们还测量其他间接反映搜索性能的指标，如搜索期间的“候选集大小”和“平均查询路径长度”。")]),s("li",null,[s("p",null,[a("To measure the algorithm’s overall performance, we employ various metrics related to index construction and search. For index construction, we evaluate the index construction efficiency and size. Some index characteristics such as "),s("em",null,"graph quality"),a(", "),s("em",null,"average out-degree"),a(", and "),s("em",null,"the number of connected components"),a(" are recorded;")])]),s("li",null,[s("p",null,[a("they indirectly affect index construction efficiency and size. Given a proximity graph "),s("em",null,"𝐺"),a(" ′ ("),s("em",null,"𝑉"),a(" ′ "),s("em",null,", 𝐸"),a(" ′ ) (graph index of an algorithm) and the exact graph "),s("em",null,"𝐺"),a("("),s("em",null,"𝑉 , 𝐸"),a(") on the same dataset, we define "),s("em",null,"graph quality"),a(" of an index as "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"𝐸"),s("mtext",null,"′"),s("mo",null,"∩"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣")]),s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣")])])]),s("annotation",{encoding:"application/x-tex"},"\\frac{|𝐸′\\cap E|}{|E|}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.53em","vertical-align":"-0.52em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.01em"}},[s("span",{style:{top:"-2.655em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord mtight"},"∣")])])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.485em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord mtight"},"′"),s("span",{class:"mbin mtight"},"∩"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord mtight"},"∣")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.52em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})])])])]),a("[21, 26, 97]. For search, we evaluate search efficiency, accuracy, and memory overhead. Search efficiency can be measured by "),s("em",null,"queries per second (QPS)"),a(" and "),s("em",null,"speedup"),a(".")])]),s("li",null,[s("p",null,[s("em",null,"QPS"),a(" is the ratio of the number of queries (#"),s("em",null,"𝑞"),a(") to the search time ("),s("em",null,"𝑡"),a(");i.e., "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mi",null,"q"),s("mi",null,"t")])]),s("annotation",{encoding:"application/x-tex"},"\\frac{q}{t}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0925em","vertical-align":"-0.345em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7475em"}},[s("span",{style:{top:"-2.655em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"t")])])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.4461em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"q")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.345em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})])])])]),a(" [38]. "),s("em",null,"Speedup"),a(" is defined as "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"S"),s("mi",{mathvariant:"normal"},"∣")]),s("mrow",null,[s("mi",null,"N"),s("mi",null,"D"),s("mi",null,"C")])])]),s("annotation",{encoding:"application/x-tex"},"\\frac{|S|}{NDC}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.355em","vertical-align":"-0.345em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.01em"}},[s("span",{style:{top:"-2.655em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.02778em"}},"D"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.07153em"}},"C")])])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.485em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord mtight"},"∣")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.345em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})])])])]),a(" , where |"),s("em",null,"𝑆"),a(" | is the dataset’s size and is also the number of distance calculations of the linear scan for a query, and "),s("em",null,"𝑁𝐷𝐶"),a(" is the number of distance calculations of an algorithm for a query (equal to |C| in Definition 2.2) [72]. We use the "),s("em",null,"recall"),a(" rate to evaluate the search accuracy, which is defined as "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"R"),s("mo",null,"∪"),s("mi",null,"T"),s("mi",{mathvariant:"normal"},"∣")]),s("mrow",null,[s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"T"),s("mi",{mathvariant:"normal"},"∣")])])]),s("annotation",{encoding:"application/x-tex"},"\\frac{|R \\cup T|}{|T|}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.53em","vertical-align":"-0.52em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.01em"}},[s("span",{style:{top:"-2.655em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.13889em"}},"T"),s("span",{class:"mord mtight"},"∣")])])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.485em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∣"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.00773em"}},"R"),s("span",{class:"mbin mtight"},"∪"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.13889em"}},"T"),s("span",{class:"mord mtight"},"∣")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.52em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})])])])]),a(", where "),s("em",null,"𝑅"),a(" is an algorithm’s query result set, "),s("em",null,"𝑇"),a(" is the real result set, and |"),s("em",null,"𝑅"),a("| = |"),s("em",null,"𝑇"),a(" |. We also measure other indicators that indirectly reflect search performance, such as "),s("em",null,"the candidate set size"),a(" during the search and "),s("em",null,"the average query path length")])]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Implementation setup")])])]),s("li",null,[s("p",null,"我们用 C++重新实现了所有算法；去除了所有的单指令多数据（SIMD）、预取指令以及其他特定硬件的优化。为了提高构建效率，对于每种算法的索引构建中涉及向量计算的部分进行了并行化处理[11,90]。所有的 C++源代码都由 g++7.3 编译，而 MATLAB 源代码（仅用于 IEH 中哈希表的索引构建[54]）由 MATLAB 9.9 编译。所有实验都在一台装有英特尔至强金牌 5218 CPU（2.30GHz）和 125G 内存的 Linux 服务器上进行。")]),s("li",null,[s("p",null,"We reimplement all algorithms by C++; they were removed by all the SIMD, pre-fetching instructions, and other hardware-specific optimizations. To improve construction efficiency, the parts involving vector calculation are parallelized for index construction of each algorithm [11, 90]. All C++ source codes are compiled by g++ 7.3, and MATLAB source codes (only for index construction of a hash table in IEH [54]) are compiled by MATLAB 9.9. All experiments are conducted on a Linux server with a Intel(R) Xeon(R) Gold 5218 CPU at 2.30GHz, and a 125G memory.")]),s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"Parameters")])])]),s("li",null,[s("p",null,"由于在整个基础数据集上调整参数可能会导致过拟合[38]，我们从基础数据集中随机抽取一定比例的数据点来形成一个验证数据集。我们在每个验证数据集上寻找每种算法的所有可调整参数的最优值，以使算法的搜索性能达到最佳水平。请注意，高召回率区域的搜索性能主要是根据实际场景的需求来考虑的。")]),s("li",null,[s("p",null,"Because parameters’ adjustment in the entire base dataset may cause overfitting [38], we randomly sample a certain percentage of data points from the base dataset to form a validation dataset. We search for the optimal value of all the adjustable parameters of each algorithm on each validation dataset, to make the algorithms’ search performance reach the optimal level. Note that high recall areas’ search performance primarily is concerned with the needs of real scenarios.")])],-1),rs=l('<h3 id="_5-2-index-construction-evaluation" tabindex="-1"><a class="header-anchor" href="#_5-2-index-construction-evaluation" aria-hidden="true">#</a> <strong>5.2 Index Construction Evaluation</strong></h3><ul><li><p>We build indexes of all compared algorithms in 32 threads on each real-world dataset. Note that we construct each algorithm with the parameters under optimal search performance.</p></li><li><p><mark><strong>Construction efficiency</strong></mark></p></li><li><p>构建效率主要受构建策略、算法类别和数据集的影响。 在图5中，基于近邻图（KNNG）且由近邻下降（NN-Descent）方法构建的算法（例如 KGraph 和 EFANNA）在所有测试算法中具有最短的构建时间，而通过分治（例如 SPTAG）或暴力搜索（例如 IEH）构建的基于 KNNG 的算法具有较高的构建时间。基于随机近邻图（RNG）的算法的构建时间根据初始图的不同有很大差异。例如，在 KGraph（例如 DPG 和 NSSG）上添加 RNG 的近似方法时，它具有较高的构建效率。然而，基于暴力搜索构建的 KNNG 上的 RNG 近似方法（例如 FANNG）的构建效率极低（接近 IEH）。请注意，Vamana 是一个例外；它在不同数据集上的排名有很大差异。这很可能是由于它的邻居选择参数α严重依赖于数据集。基于图分区（DG）的算法（例如 NGT 和 NSW）的构建时间随数据集有明显差异。在一些困难的数据集上（例如 GloVe），它们的构建时间甚至高于 FANNG。</p></li><li><p>The construction efficiency is mainly affected by the construction strategy, algorithm category, and dataset. In Figure 5, the KNNG-based algorithms (e.g., KGraph and EFANNA) constructed by NN-Descent have the smallest construction time among all test algorithms, while the KNNG-based algorithms constructed by divide and conquer (e.g., SPTAG) or brute force (e.g., IEH) have higher construction time. The construction time of RNG based algorithms vary greatly according to the initial graph. For example, when adding the approximation of RNG on KGraph (e.g., DPG and NSSG), it has a high construction efficiency. However, RNG approximation based on the KNNG built by brute force (e.g., FANNG) has miniscule construction efficiency (close to IEH). Note that Vamana is an exception; its ranking on different datasets has large differences. This is most likely attributable to its neighbor selection parameter <em>𝛼</em> heavily dependent on dataset. The construction time of DG-based algorithms (e.g., NGT and NSW) shows obvious differences with datasets. On some hard datasets (e.g., GloVe), their construction time is even higher than FANNG.</p><figure><img src="'+v+'" alt="figure5" tabindex="0" loading="lazy"><figcaption>figure5</figcaption></figure></li><li><p><mark><strong>Index size and average out-degree</strong></mark></p></li><li><p>索引大小主要取决于平均出度（AD）。一般来说，AD 越小，索引大小就越小。如图 6 和表 4 所示，基于随机近邻图（RNG）的算法（例如 NSG）具有较小的索引大小，这主要是因为它们在 RNG 近似过程中切断了冗余边（AD 较低）。基于近邻图（KNNG）、基于图分区（DG）和基于最小生成树（MST）的算法（例如 KGraph、NSW 和 HCNNG）连接了所有附近的邻居而没有修剪多余的邻居，所以它们总是具有较大的索引大小。额外的索引结构（例如 NGT 中的树）也会增加相关算法的索引大小。</p></li><li><p>The index size mainly depends on the average out-degree (AD). Generally, the smaller the AD, the smaller the index size. As Figure 6 and Table 4 show, RNG based algorithms (e.g., NSG) have a smaller index size, which is mainly because they cut redundant edges (the lower AD) during RNG approximation. KNNG-, DG-, and MST-based algorithms (e.g., KGraph, NSW, and HCNNG) connect all nearby neighbors without pruning superfluous neighbors, so they always have a larger index size. Additional index structures (e.g., the tree in NGT) will also increase related algorithms’ index size.</p></li><li><figure><img src="'+f+'" alt="figure6" tabindex="0" loading="lazy"><figcaption>figure6</figcaption></figure></li></ul><figure><img src="'+b+'" alt="table4" tabindex="0" loading="lazy"><figcaption>table4</figcaption></figure><ul><li><p><mark><strong>Graph quality</strong></mark></p></li><li><p>算法类别和数据集是决定图质量（GQ）的主要因素。在表 4 中，基于近邻图（KNNG）的算法（例如 KGraph）的图质量优于其他类别。对随机近邻图（RNG）的近似会修剪一些最近邻，从而破坏了基于 RNG 的算法的图质量（例如 NSG）。然而，这种现象在 DPG 中没有发生，主要是因为它使所有边无向化。有趣的是，基于图分区（DG）和基于最小生成树（MST）的算法的图质量（例如 NSW 和 HCNNG）随数据集有明显差异；在简单数据集（例如 Audio）上，它们具有较高的图质量，但在困难数据集（例如 GIST1M）上会下降。</p></li><li><p>The algorithm category and dataset are the main factors that determine graph quality (GQ). In Table 4, the GQ of KNNG-based algorithms (e.g., KGraph) outperform other categories. The approximation to RNG prunes some of the nearest neighbors, thereby destroying RNG-based algorithms’ GQ (e.g., NSG). However, this phenomenon does not happen with DPG, mostly because it undirects all edges. Interestingly, DG- and MST-based algorithms’ GQ (e.g., NSW and HCNNG) shows obvious differences with datasets; on simple datasets (e.g., Audio), they have higher GQ, but it degrades on hard datasets (e.g., GIST1M).</p></li><li><p><mark><strong>Connectivity</strong></mark></p></li><li><p>连通性主要与构建策略和数据集相关。表 4 显示，基于图分区（DG）和基于最小生成树（MST）的算法具有良好的连通性。前者归因于增量构建策略（例如 NSW 和 NGT），后者得益于其对最小生成树的近似。一些基于随机近邻图（RNG）的算法执行深度优先搜索（DFS）以确保连通性（例如 NSG 和 NSSG）。DPG 添加反向边以使其具有良好的连通性。不出所料，基于近邻图（KNNG）的算法通常有很多连通分量，特别是在困难数据集上。</p></li><li><p>Connectivity mainly relates to the construction strategy and dataset. Table 4 shows that DG- and MST-based algorithms have good connectivity. The former is attributed to the <strong>Increment</strong> construction strategy (e.g., NSW and NGT), and the latter benefits from its approximation to MST. Some RNG-based algorithms perform depth-first search (DFS) to ensure connectivity (e.g., NSG and NSSG). DPG adds reverse edges to make it have good connectivity. Unsurprisingly, KNNG-based algorithms generally have a lot of connected components, especially on hard datasets.</p></li></ul><h3 id="_5-3-search-performance" tabindex="-1"><a class="header-anchor" href="#_5-3-search-performance" aria-hidden="true">#</a> <strong>5.3 Search Performance</strong></h3><ul><li><p>所有搜索都在单线程上进行评估。对于每个查询，召回的最近邻数量统一设置为 10，Recall@10 表示相应的召回率。由于空间限制，我们仅在图 7 和图 8 中列出了代表性结果，其他结果在附录 O 中显示。请注意，我们的观察是基于所有数据集上的结果。</p></li><li><p>All searches are evaluated on a single thread. The number of nearest neighbors recalled is uniformly set to 10 for each query, and <em>𝑅𝑒𝑐𝑎𝑙𝑙</em>@10 represents the corresponding recall rate. Because of space constraints, we only list the representative results in Figure 7 and 8, and the others are displayed in Appendix O. Note that our observations are based on the results on all datasets.</p></li><li><figure><img src="'+N+'" alt="figure7" tabindex="0" loading="lazy"><figcaption>figure7</figcaption></figure></li><li><figure><img src="'+S+'" alt="figure8" tabindex="0" loading="lazy"><figcaption>figure8</figcaption></figure></li><li><p><mark><strong>Accuracy and efficiency</strong></mark></p></li><li><p>如图 7 和图 8 所示，不同算法在同一数据集上的搜索性能或同一算法在不同数据集上的搜索性能有很大差异。一般来说，能够获得更高加速比的算法也能实现更高的每秒查询数（QPS），这表明基于图的近似最近邻搜索算法的搜索效率主要取决于搜索过程中的距离评估次数[113]。基于随机近邻图（RNG）和基于最小生成树（MST）的算法（例如 NSG 和 HCNNG）的搜索性能通常大幅优于其他类别，特别是在困难数据集（例如 GloVe）上。基于近邻图（KNNG）和基于图分区（DG）的算法（例如 EFANNA 和 NSW）只能在简单数据集上实现较好的搜索性能，在困难数据集上它们的性能急剧下降。特别地，SPTAG 的搜索性能随着局部敏感哈希（LID）的增加而急剧下降。这很可能是因为它在搜索过程中频繁通过树重新进入[98]，我们知道树具有严重的维度灾难[61]。</p></li><li><p>As illustrated in Figure 7 and 8, the search performance of different algorithms on the same dataset or the same algorithm on different datasets have large differences. Generally, algorithms capable of obtaining higher speedup also can achieve higher QPS, which demonstrates that the search efficiency of graph-based ANNS algorithms mainly depends on the number of distance evaluations during the search [113]. The search performance of RNG- and MST-based algorithms (e.g., NSG and HC NNG) generally beats other categories by a large margin, especially on hard datasets (e.g., GloVe). KNNG- and DG-based algorithms (e.g., EFANNA and NSW) can only achieve better search performance on simple datasets, their performance drops sharply on hard datasets. Particularly, the search performance of SPTAG decreases dramatically with the increase of LID. This is most likely because it frequently regains entry through the tree during the search [98], we know that the tree has bad <em>curse of dimensionality</em> [61].</p></li><li><p><mark><strong>Candidate set size (CS)</strong></mark></p></li><li><p>候选集（CS）与算法类别、数据集和搜索性能之间存在联系。对于大多数算法，我们可以设置候选集大小以获得目标召回率，但少数算法（例如 SPTAG）在达到设定的召回率之前就达到了“上限”。此时，当我们增加候选集大小时，召回率几乎没有变化（即表 5 中带有“+”的候选集大小值）。候选集中的元素由于在搜索过程中频繁访问通常被放置在缓存中；因此，由于容量限制，我们必须尽可能将候选集大小约束在较小的值。特别是在 GPU 中，候选集大小将对搜索性能产生更大的影响[113]。在表 5 中，基于图分区（DG）的算法和大多数基于随机近邻图（RNG）的算法（例如 NGT 和 NSG）需要较小的候选集大小。基于近邻图（KNNG）和基于最小生成树（MST）的算法的候选集大小与数据集相关，数据集越困难，候选集大小越大（例如 SPTAG）。一般来说，搜索性能较差的算法具有较大的候选集大小（例如 FANNG）。</p></li><li><p>There is a connection between the CS and algorithm category, dataset, and search performance. For most algorithms, we can set CS to obtain the target recall rate, but a few algorithms (e.g., SPTAG) reach the “ceiling” before the set recall rate. At this time, the recall rate hardly changes when we increase CS (i.e., a CS value with “+” in Table 5). The elements in a candidate set generally are placed in the cache because of frequent access during the search; so we must constrain the CS to a small value as much as possible because of the capacity’s limitation. Especially in the GPU, the CS will have a greater impact on the search performance [113]. In Table 5, DG-based and most RNG-based algorithms (e.g., NGT and NSG) require a smaller CS. The CS of KNNG- and MST-based algorithms is related to the dataset, and the harder the dataset, the larger the CS (e.g., SPTAG). In general, algorithms with bad search performance have a larger CS (e.g., FANNG).</p></li><li><figure><img src="'+G+'" alt="table5" tabindex="0" loading="lazy"><figcaption>table5</figcaption></figure></li><li><p><mark><strong>Query path length (PL)</strong></mark></p></li><li><p>在大规模数据集上，通常需要使用外部存储来存储原始数据。通常，页面大小（PL）决定了输入/输出（I/O）次数，这限制了相应的搜索效率[88]。从图 7 和表 5 中可以看出，搜索性能较高的算法通常具有较小的页面大小（例如 HCNNG），但页面大小较小的算法不一定具有良好的搜索性能（例如 FANNG）。此外，有时平均出度较大的算法也具有较小的页面大小是有道理的（例如 NSW）。</p></li><li><p>On large-scale datasets, it generally is necessary to use external storage to store the original data. Normally the PL determines the I/O number, which restricts the corresponding search efficiency [88]. From Figure 7 and Table 5, we see that algorithms with higher search performance generally have smaller PL (e.g., HCNNG), but algorithms with smaller PL do not necessarily have good search performance (e.g., FANNG). In addition, it makes sense that sometimes that an algorithm with a large average out-degree also has a small PL (e.g., NSW).</p></li><li><p><mark><strong>Memory overhead (MO).</strong></mark></p></li><li><p>如表 5 所示，基于随机近邻图（RNG）的算法通常具有最小的内存开销（例如 NSG 和 NSSG）。一些具有额外索引结构的算法具有较高的内存开销（例如 SPTAG 和 IEH）。较大的平均出度（AD）和候选集（CS）值也会增加算法的内存开销（例如 NSW 和 SPTAG-BKT）。总体而言，算法的索引大小越小，搜索过程中的内存开销就越小。</p></li><li><p>As Table 5 show, RNG-based algorithms generally have the smallest memory overhead (e.g., NSG and NSSG). Some algorithms with additional index structures have high memory overhead (e.g., SPTAG and IEH). Larger AD and CS values also will increase the algorithms’ memory overhead (e.g., NSW and SPTAG-BKT). Overall, the smaller the algorithm’s index size, the smaller the memory overhead during search.</p></li></ul><h3 id="_5-4-components-evaluation" tabindex="-1"><a class="header-anchor" href="#_5-4-components-evaluation" aria-hidden="true">#</a> <strong>5.4 Components’ Evaluation</strong></h3><ul><li><p>在本小节中，我们在两个具有不同难度的真实世界数据集上评估基于图的算法的代表性组件。根据上述实验，基于细化构建策略的算法通常具有更好的综合性能。因此，我们基于此策略和图 4 中的流程设计了一个统一的评估框架。评估框架中的每个组件都被设置为特定的实现方式，以形成一个基准算法（详细设置见附录 K）。我们使用 C# + 算法名称来表示相应组件的特定实现。例如，C1_NSG 表示我们使用 NSG 的初始化（C1），即通过 NN-Descent 构建初始图。</p></li><li><p>In this subsection, we evaluate representative components of graph based algorithms on two real-world datasets with different difficulty. According to the aforementioned experiments, algorithms based on the <strong>Refinement</strong> construction strategy generally have better comprehensive performance. Therefore, we design a unified evaluation framework based on this strategy and the pipline in Figure 4. Each component in the evaluation framework is set for a certain implementation to form a benchmark algorithm (see Appendix K for detailed settings). We use the <em>C# + algorithm name</em> to indicate the corresponding component’s specific implementation. For example, <em>C1_NSG</em> indicates that we use the initialization (C1) of NSG, i.e., the initial graph is constructed through NN-Descent.</p></li><li><p>请注意，许多算法对于相同的组件具有相同的实现（例如，C3_NSG、C3_HNSW 和 C3_FANNG）。我们随机选择一个算法来代表这种实现（例如，C3_HNSW）。不同组件对搜索性能和构建时间的影响分别如图 10 和附录 M 所示。</p></li><li><p>Note that many algorithms have the same implementation for the same component (e.g., <em>C3_NSG</em>, <em>C3_HNSW</em>, and <em>C3_FANNG</em>). We randomly select an algorithm to represent this implementation (e.g., <em>C3_HNSW</em>). The impact of different components on search performance and construction time are depicted in Figure 10 and Appendix M, respectively.</p></li></ul><figure><img src="'+k+'" alt="figure10" tabindex="0" loading="lazy"><figcaption>figure10</figcaption></figure><ul><li><p><mark><strong>C1: Initialization</strong></mark></p></li><li><p>图 10(a)展示了不同的图索引初始化方法对搜索性能的影响。“C1_NSG”的搜索性能远好于“C1_EFANNA”和“C1_KGraph”；并且尽管“C1_NSG”需要更多的构建时间，但为了如此大的性能提升是值得的。此外，在 GIST1M（更难的数据集）上，“C1_NSG”与其他两者之间存在更大的差距，这表明它具有更好的可扩展性。</p></li><li><p>Figure 10(a) reports the impact of different graph index initialization methods on search performance. The search performance of <em>C1_NSG</em> is much better than <em>C1_EFANNA</em> and <em>C1_KGraph</em>; and although <em>C1_NSG</em> needs more construction time, it is worthwhile for such a large performance improvement. Moreover, a larger gap exists between <em>C1_NSG</em> and the other two on GIST1M (harder), which shows that it has better scalability.</p></li><li><p><mark><strong>C2: Candidate neighbor acquisition</strong></mark></p></li><li><p>如图 10(b)所示，不同的候选邻居获取方法之间的差异较小。C2_NSW 具有最佳的搜索性能，特别是在 GIST1M 上，代价是更多的构建时间。在相似的构建时间下，C2_NSSG 比 C2_DPG 获得更好的搜索性能。值得注意的是，尽管在图 7 中 DPG 在 SIFT1M 上的搜索性能比 HNSW 好，但 C2_HNSW（即 C2_NSW）的搜索性能超过了 C2_DPG。</p></li><li><p>As shown in Figure 10(b), different candidate neighbor acquisition methods vary slightly. <em>C2_NSW</em> has the best search performance, especially on GIST1M, with the price being more construction time. <em>C2_NSSG</em> obtains better search performance than <em>C2_DPG</em> under a similar construction time. It is worth noting that although DPG’s search performance on SIFT1M is better than HNSW’s in Figure 7, the search performance of <em>C2_HNSW</em> (i.e., <em>C2_NSW</em>) exceeds that of <em>C2_DPG</em>.</p></li><li><p><mark><strong>C3: Neighbor selection</strong></mark></p></li><li><p>图 10(c)描绘了不同的邻居选择方案对搜索性能的影响。显然，对于考虑邻居分布的算法（例如 C3_HNSW、C3_NSSG、C3_DPG、C3_Vamana），其搜索性能比不考虑邻居分布的算法（例如 C3_KGraph）更好。请注意，正如论文[88]中所声称的，C3_Vamana 的性能并不比 C3_HNSW 好。在他们的实验中，NSSG[37]似乎比 NSG 具有更好的搜索性能，所以研究人员认为 C3_NSSG 比 C3_NSG（即 C3_HNSW）更好。然而，研究人员在评估过程中没有控制其他组件的一致性，这是不公平的。</p></li><li><p>Figure 10(c) depicts the impact of different neighbor selection schemes on search performance. Obviously, it shows better search performance for algorithms that consider the distribution of neighbors (e.g., <em>C3_HNSW</em>, <em>C3_NSSG</em>, <em>C3_DPG</em>, <em>C3_Vamana</em>) than those that do not consider this (e.g., <em>C3_KGraph</em>). Note that <em>C3_Vamana</em>’s performance is no better than <em>C3_HNSW</em>’s, as claimed in the paper [88]. NSSG[37] appears to have better search performance than NSG in their experiment, so the researchers be lieve that <em>C3_NSSG</em> is better than <em>C3_NSG</em> (i.e., <em>C3_HNSW</em>). However, the researchers do not control the consistency of other components during the evaluation, which is unfair.</p></li><li><p><mark><strong>C4: Seed preprocessing and C6: Seed acquisition</strong></mark></p></li><li><p>“C4”和“C6”组件在所有比较的算法中是相互关联的；也就是说，指定“C4”后，“C6”也确定了。简而言之，我们用“C4_NSSG”来表示“C6_NSSG”。如图 10(d)所示，用于获取入口的额外索引结构对搜索性能有显著影响。“C4_NGT”和“C4_SPTAG - BKT”的搜索性能最差；它们都是通过在额外的树上进行距离计算来获取入口（我们知道树索引存在严重的“维度诅咒”）。虽然“C4_HCNNG”也通过树获取入口，但它在 KD 树（k-dimensional tree）上只需要进行值比较而无需进行距离计算，所以它比“C4_NGT”和“C4_SPTAG - BKT”表现出更好的搜索性能。“C4_IEH”添加了哈希表来获取入口，从而获得了最佳的搜索性能。这可能是因为哈希表比树能更快地获取接近查询的入口。同时，“C4_NSSG”和“C4_NSG”在没有额外索引的情况下仍然实现了高搜索性能。请注意，这些方法在索引构建时间上没有显著差异。</p></li><li><p>The <strong>C4</strong> and <strong>C6</strong> components are interrelated in all compared algorithms; that is, after specifying <strong>C4</strong>, <strong>C6</strong> is also determined. Briefly, we use <em>C4_NSSG</em> to indicate <em>C6_NSSG</em>. As Figure 10(d) shows, the extra index structure to get the entry significantly impacts search performance. <em>C4_NGT</em> and <em>C4_SPTAG-BKT</em> have the worst search performance; they both obtain entry by performing distance calculations on an additional tree (we know that the tree index has a serious <em>curse of</em> <em>dimensionality</em>). Although <em>C4_HCNNG</em> also obtains entry through a tree, it only needs value comparison and no distance calculation on the KD-Tree, so it shows better search performance than <em>C4_NGT</em> and <em>C4_SPTAG-BKT</em>. <em>C4_IEH</em> adds the hash table to obtain entry, yielding the best search performance. This may be because the hash can obtain entry close to the query more quickly than the tree. Meanwhile, <em>C4_NSSG</em> and <em>C4_NSG</em> still achieve high search performance without additional index. Note that there is no significant difference in index construction time for these methods.</p></li><li><p><mark><strong>C5: Connectivity</strong></mark></p></li><li><p>图 10(e)显示具有连接保证的算法（例如 C5_NSG）比没有连接保证的算法（例如 C5_Vamana）具有更好的搜索性能。</p></li><li><p>Figure 10(e) shows the algorithm with guaranteed connectivity has better search performance (e.g., <em>C5_NSG</em>) than that without connectivity assurance (e.g., <em>C5_Vamana</em>).</p></li><li><p><mark><strong>C7: Routing</strong></mark></p></li><li><p>图 10(f)展示了不同路由策略对搜索性能的影响。C7_NSW 的搜索性能是最好的，并且大多数算法（例如 HNSW 和 NSG）都使用它。C7_NGT 由于参数𝜖的限制存在精度“上限”，可以通过增加𝜖来缓解，但搜索效率会降低。C7_FANNG 通过回溯可以实现高准确率，但回溯也限制了搜索效率。C7_HCNNG 基于查询位置避免了一些冗余计算，然而，这对搜索精度产生了负面影响。</p></li><li><p>Figure 10(f) shows different routing strategies’ impact on search performance. <em>C7_NSW</em>’s search performance is the best, and it is used by most algorithms (e.g., HNSW and NSG). <em>C7_NGT</em> has a precision “ceiling” because of the <em>𝜖</em> parameter’s limitation, which can be alleviated by increasing <em>𝜖</em>, but search efficiency will decrease. <em>C7_FANNG</em> can achieve high accuracy through backtracking, but backtracking also limits search efficiency. <em>C7_HCNNG</em> avoids some redundant calculations based on the query position, however, this negatively affects search accuracy.</p></li></ul><h3 id="_5-5-machine-learning-based-optimizations" tabindex="-1"><a class="header-anchor" href="#_5-5-machine-learning-based-optimizations" aria-hidden="true">#</a> <strong>5.5 Machine Learning-Based Optimizations</strong></h3><ul><li>最近，基于机器学习（ML）的方法被提出来改善算法在加速比与召回率之间的权衡[14,59,78]。一般来说，它们可以被视为对上述基于图的算法（如 NSG 和 NSW）的一些优化。我们在 NSG 和 HNSW 上评估了三种基于机器学习的优化，即 ML1[14]、ML2[59]和 ML3[78]。由于篇幅限制，我们在表 6 和图 9 中只展示了 ML1 的测试结果，其他的具有类似的特征（更多细节见附录 R）。</li><li>Recently, machine learning (ML)-based methods are proposed to improve the speedup vs recall trade-off of the algorithms [14, 59, 78]. In general, they can be viewed as some optimizations on graph based algorithms discussed above (such as NSG and NSW). We evaluate three ML-based optimizations on NSG and HNSW, i.e., ML1 [14], ML2 [59], and ML3 [78]. Because of space limitations, we only show the test results on ML1 in Table 6 and Figure 9, others share similar feature (see Appendix R for more details).</li><li><img src="'+M+'" alt="table6" tabindex="0" loading="lazy"><figcaption>table6</figcaption></li></ul><figure><img src="'+_+'" alt="figure9" tabindex="0" loading="lazy"><figcaption>figure9</figcaption></figure><ul><li><p><mark><strong>Analysis</strong></mark></p></li><li><p>基于机器学习的优化通常以更多的时间和内存为代价获得更好的加速比与召回率的权衡。例如，原始的 NSG 在 SIFT100K 上进行索引构建需要 55 秒，最大内存消耗为 0.37GB；然而，经过 ML1 优化的 NSG 处理索引需要 67315 秒（即使我们使用 GPU 进行加速），并且内存消耗高达 23.8GB。总之，当前基于机器学习的优化具有较高的硬件要求和时间成本，因此它们的广泛应用受到限制。考虑到大多数原始的基于图的算法可以在&lt;5 毫秒内返回查询结果，一些高科技公司（如阿里巴巴、脸书和 ZILLIZ）在实际业务场景中仅部署没有基于机器学习优化的 NSG[38,55,70]。</p></li><li><p>ML-based optimizations generally obtain better speedup vs recall tradeoff at the expense of more time and memory. For example, the original NSG takes 55s and maximum memory consumption of 0.37 GB for index construction on SIFT100K; however, NSG optimized by ML1 takes 67,315s to process the index (even if we use the GPU for speedup), and the memory consumption is up to 23.8 GB. In summary, current ML-based optimizations have high hardware requirements and time cost, so their wide application is limited. Considering that most of the original graph-based algorithms can return query results in &lt; 5ms, some high-tech companies (such as Alibaba, Facebook, and ZILLIZ) only deploy NSG without ML-based optimizations in real business scenarios [38, 55, 70].</p></li></ul><h2 id="_6-discussion" tabindex="-1"><a class="header-anchor" href="#_6-discussion" aria-hidden="true">#</a> <strong>6 DISCUSSION</strong></h2><ul><li><p>According to the behaviors of algorithms and components on real world and synthetic datasets, we discuss our findings as follows.</p></li><li><p><mark><strong>Recommendations</strong></mark></p></li><li><p>在表 7 中，我们的评估根据不同场景下的最佳性能选择算法。NSG 和 NSSG 具有最小的构建时间和索引大小，因此它们适用于 S1。KGraph、EFANNA 和 DPG 以较低的构建时间实现了最高的图质量，因此它们被推荐用于 S2。对于 S3（例如 SSD [88]），DPG 和 HCNNG 是最佳选择，因为它们较小的平均路径长度可以减少 I/O 次数。在困难数据集（S4，大局部独立距离（LID））上，HNSW、NSG 和 HCNNG 表现出有竞争力的搜索性能，而在简单数据集（S5）上，DPG、NSG、HCNNG 和 NSSG 提供更好的搜索性能。对于 S6，由于缓存的限制[113]，我们需要一个较小的候选集大小；目前，NGT 似乎更具优势。NSG 和 NSSG 提供最小的出度和内存开销，因此它们是 S7 的最佳选择。</p></li><li><p>In Table 7, our evaluation selects algorithms based on best performance under different scenarios. NSG and NSSG have the smallest construction time and index size, so they are suitable for <strong>S1</strong>. KGraph, EFANNA, and DPG achieve the highest graph quality with lower construction time, so they are recommended for <strong>S2</strong>. For <strong>S3</strong> (such as SSD [88]), DPG and HCNNG are the best choices because their smaller average path length can reduce I/O times. On hard datasets (<strong>S4</strong>, large LID), HNSW, NSG, and HCNNG show competitive search performance, while on simple datasets (<strong>S5</strong>), DPG, NSG, HCNNG, and NSSG offer better search performance. For <strong>S6</strong>, we need a smaller candidate set size because of the cache’s limitation [113]; for now, NGT appears more advantageous. NSG and NSSG offer the smallest out-degree and memory overhead, so they are the best option for <strong>S7</strong>.</p></li></ul><figure><img src="'+z+'" alt="table7" tabindex="0" loading="lazy"><figcaption>table7</figcaption></figure><ul><li><p><mark><strong>Guidelines</strong></mark></p></li><li><p>直观地说，一个实用的基于图的近似最近邻搜索算法应该具有：（H1）高构建效率；（H2）高路由效率；（H3）高搜索准确性；以及（L4）低内存开销。对于 H1，我们不应该花费太多时间来提高图的质量，因为最好的图质量对于实现最佳搜索性能来说不是必需的。对于 H2，我们应该控制适当的出度，使邻居的分布多样化（如 C3_HNSW），并降低获取条目的成本（如 C4_IEH），以便通过少量的距离计算快速导航到查询的最近邻。此外，我们应该通过在路由过程中优化路由策略（如 C7_HCNNG）来避免冗余的距离计算。在 H3 方面，为了提高搜索对陷入局部最优的免疫力[14]，我们应该在索引构建期间合理设计邻居的分布，确保连通性（如 C5_NSG），并优化路由策略[94]。对于 L4，我们可以从降低出度和候选集大小开始，这可以通过改进邻居选择策略（如 C3_NSG）和路由策略（如 C7_HCNNG）来实现。</p></li><li><p>Intuitively, a practical graph-based ANNS algorithm should have: <strong>(H1) high construction efficiency</strong>; <strong>(H2) high routing efficiency</strong>; <strong>(H3) high search accuracy</strong>; and <strong>(L4) low memory overhead</strong>. For <strong>H1</strong>, we should not spend too much time improving graph quality, because the best graph quality is not necessary to achieve the best search performance. For <strong>H2</strong>, we should control the appropriate out-degree, diversify neighbors’ distribution (such as <em>C3_HNSW</em>), and reduce the cost of obtaining entries (like <em>C4_IEH</em>), to navigate quickly to the query’s nearest neighbors with a small number of distance calculations. In addition, we should avoid redundant distance calculations by optimizing the routing strategy (such as <em>C7_HCNNG</em>) in the routing process. In terms of <strong>H3</strong>, to improve the search’s immunity from falling into the local optimum [14], we should reasonably design the distribution of neighbors during index construction, ensure connectivity (such as <em>C5_NSG</em>), and optimize the routing strategy [94]. For <strong>L4</strong>, we can start by reducing the out-degree and candidate set size, and this can be achieved by improving the neighbor selection strategy (such as <em>C3_NSG</em>) and routing strategy (like <em>C7_HCNNG</em>).</p></li><li><p><mark><strong>Improvement</strong></mark></p></li><li></li><li><p>Based on our observations and <strong>Guidelines</strong>, we design an optimized algorithm that addresses <strong>H1</strong>, <strong>H2</strong>, <strong>H3</strong>, and <strong>L4</strong> simultaneously. In the index construction phase, it initializes a graph with appropriate quality by NN-Descent (C1), quickly obtains candidate neighbors with <em>C2_NSSG</em> (C2), uses <em>C3_NSG</em> to trimredundant neighbors (C3), randomly selects a certain number of entries (C4), and ensures connectivity through depth-first traversal (C5); in the search phase, it starts from the random entries (C6), and performs two-stage routing through <em>C7_HCNNG</em> and <em>C7_NSW</em> in turn. As shown in Figure 11, the optimized algorithm surpasses the state-of-the-art algorithms in terms of efficiency vs accuracy tradeoff, while ensuring high construction efficiency and low memory overhead (see Appendix P for more details).</p></li><li><p><mark><strong>Tendencies</strong></mark></p></li><li><p>在过去的十年中，基于图的近似最近邻搜索算法已经从对四种经典基础图的简单近似（例如 KGraph 和 NSW）发展到对近似最近邻搜索的优化（例如 HNSW 和 NSG）。在此过程中，它们的性能——尤其是搜索性能——在质量上得到了提升。值得注意的是，几乎所有最先进的算法都是基于随机近邻图（RNG）的（例如 HNSW 和 NSG），因此许多方法在基于 K 近邻图（KNNG）或有向图（DG）的算法基础上添加了对 RNG 的近似（见图 3）。基于 RNG 的类别仍然是基于图的近似最近邻搜索的一个有前途的研究方向。最近，基于最小生成树（MST）的算法被应用于基于图的近似最近邻搜索，并且在我们的评估中也取得了出色的结果，尤其是在困难数据集上。在本文讨论的核心算法的基础上，研究人员正在通过硬件[53,88,113]来细化和提高基于图的近似最近邻搜索算法的性能。其他文献添加了量化或分布式方案来应对数据的增加[30,33]。为了满足混合查询需求，最新的研究在基于图的算法的搜索过程中添加了结构化属性约束[104,106]。</p></li><li><p>Over the last decade, graph-based ANNS algorithms have ranged from simple approximation of four classic base graphs (e.g., KGraph and NSW) to ANNS’s optimization (e.g., HNSW and NSG). Along the way, their performance—especially their search performance—has improved qualitatively. It is worth noting that almost all state-of-the-art algorithms are based on RNG (e.g., HNSW and NSG), and thus many approaches add an approximation of RNG on the basis of KNNG- or DG-based algorithms (see Figure 3). The RNG-based category is still a promising research direction for graph-based ANNS. The MST-based algorithm recently was applied to graph-based ANNS, and it also achieves excellent results in our evaluation, especially on hard datasets. On the basis of the core algorithm discussed in this paper, researchers are refining and improving graph-based ANNS algorithms’ performance via hardware [53, 88, 113]. Other literatures add quantitative or distributed schemes to cope with data increases [30, 33]. To meet hybrid query requirements, the latest research adds structured attribute constraints to the search process of graph-based algorithms [104, 106].</p></li><li><p><mark><strong>Challenges</strong></mark></p></li><li><p>目前，几乎所有基于图的算法都是面向原始数据的，这是这些算法具有高内存使用量的主要原因。确定如何将数据编码或其他方法与基于图的近似最近邻搜索算法有机地结合起来是一个值得探索的问题。与树、哈希和量化相比，基于图的算法具有最高的索引构建时间[61]，这增加了实时更新图索引的难度。此外，研究如何将 GPU 加速或其他方法与基于图的近似最近邻搜索算法相结合以实现图索引的实时更新是一个值得深入研究的问题。对于具有不同特征的数据，基于图的算法具有不同的适应性，因此表现出不同的性能水平。最后，一个主要的突出挑战是如何通过学习根据数据集的特征自适应地选择最佳的基于图的算法。</p></li><li><p>At present, almost all graph-based algorithms are oriented to raw data, which is the main reason why these algorithms have high memory usage. Determining how to organically combine data encoding or other methods with graph-based ANNS algorithms is a problem worth exploring. Compared with tree, hashing, and quantization, the graph-based algorithms have the highest index construction time [61], which adds difficulty with updating the graph index in real time. Also, figuring how to combine GPU acceleration or other methods with the graph-based ANNS algorithm to realize the real-time update of the graph index is worthy of an in-depth study. For data with different characteristics, the graph-based algorithms have different adaptability, and thus exhibit different performance levels. Finally, a major outstanding challenge is discerning how to adaptively select the optimal graph-based algorithm according to the dataset’s characteristics by learning.</p></li></ul><h2 id="appendix" tabindex="-1"><a class="header-anchor" href="#appendix" aria-hidden="true">#</a> <strong>APPENDIX</strong></h2><h3 id="appendix-a-proof-for-the-equivalence-of-the-neighbor-selection-strategies-of-hnsw-and-nsg" tabindex="-1"><a class="header-anchor" href="#appendix-a-proof-for-the-equivalence-of-the-neighbor-selection-strategies-of-hnsw-and-nsg" aria-hidden="true">#</a> <strong>Appendix A. Proof for the equivalence of the neighbor selection strategies of HNSW and NSG</strong></h3><ul><li><mark><strong>Notations</strong></mark></li><li></li></ul>',21);function ms(os,hs){const r=i("ExternalLinkIcon"),e=i("router-link");return o(),h("div",null,[C,T,c(" more "),s("div",L,[D,s("ul",null,[H,E,q,s("li",null,[s("a",P,[a("https://zhuanlan.zhihu.com/p/610454162"),t(r)])])])]),s("nav",I,[s("ul",null,[s("li",null,[t(e,{to:"#一、简单介绍"},{default:n(()=>[a("一、简单介绍")]),_:1})]),s("li",null,[t(e,{to:"#no-0-abstract"},{default:n(()=>[a("No.0 ABSTRACT")]),_:1})]),s("li",null,[t(e,{to:"#no-1-introduction"},{default:n(()=>[a("No.1 INTRODUCTION")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_1-1-motivation"},{default:n(()=>[a("1.1 Motivation")]),_:1})]),s("li",null,[t(e,{to:"#_1-2-our-contributions"},{default:n(()=>[a("1.2 Our Contributions")]),_:1})])])]),s("li",null,[t(e,{to:"#_2-preliminaries"},{default:n(()=>[a("2 PRELIMINARIES")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_2-1-problem-definition"},{default:n(()=>[a("2.1 Problem Definition")]),_:1})]),s("li",null,[t(e,{to:"#_2-2-scope-illustration"},{default:n(()=>[a("2.2 Scope Illustration")]),_:1})])])]),s("li",null,[t(e,{to:"#_3-overview-of-graph-based-anns"},{default:n(()=>[a("3 OVERVIEW OF GRAPH-BASED ANNS")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_3-1-base-graphs-for-anns"},{default:n(()=>[a("3.1 Base Graphs for ANNS")]),_:1})]),s("li",null,[t(e,{to:"#_3-2-graph-based-anns-algorithms"},{default:n(()=>[a("3.2 Graph-Based ANNS Algorithms")]),_:1})])])]),s("li",null,[t(e,{to:"#_4-components-analysis"},{default:n(()=>[a("4 COMPONENTS’ ANALYSIS")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_4-1-components-for-index-construction"},{default:n(()=>[a("4.1 Components for Index Construction")]),_:1})]),s("li",null,[t(e,{to:"#_4-2-components-for-search"},{default:n(()=>[a("4.2 Components for Search")]),_:1})])])]),s("li",null,[t(e,{to:"#_5-experimental-evaluation"},{default:n(()=>[a("5 EXPERIMENTAL EVALUATION")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#_5-1-experimental-setting"},{default:n(()=>[a("5.1 Experimental Setting")]),_:1})]),s("li",null,[t(e,{to:"#_5-2-index-construction-evaluation"},{default:n(()=>[a("5.2 Index Construction Evaluation")]),_:1})]),s("li",null,[t(e,{to:"#_5-3-search-performance"},{default:n(()=>[a("5.3 Search Performance")]),_:1})]),s("li",null,[t(e,{to:"#_5-4-components-evaluation"},{default:n(()=>[a("5.4 Components’ Evaluation")]),_:1})]),s("li",null,[t(e,{to:"#_5-5-machine-learning-based-optimizations"},{default:n(()=>[a("5.5 Machine Learning-Based Optimizations")]),_:1})])])]),s("li",null,[t(e,{to:"#_6-discussion"},{default:n(()=>[a("6 DISCUSSION")]),_:1})]),s("li",null,[t(e,{to:"#appendix"},{default:n(()=>[a("APPENDIX")]),_:1}),s("ul",null,[s("li",null,[t(e,{to:"#appendix-a-proof-for-the-equivalence-of-the-neighbor-selection-strategies-of-hnsw-and-nsg"},{default:n(()=>[a("Appendix A. Proof for the equivalence of the neighbor selection strategies of HNSW and NSG")]),_:1})])])])])]),K,W,R,F,V,B,O,Q,j,U,X,Y,Z,J,$,ss,as,ts,es,ns,ls,is,rs])}const gs=m(A,[["render",ms],["__file","基于高维数据ANNS综述.html.vue"]]);export{gs as default};
