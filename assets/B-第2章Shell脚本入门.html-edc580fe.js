import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as a,c as i,d as _,a as l,e as h,w as t,b as e,f as c}from"./app-2a2d189a.js";const p={},u=l("h1",{id:"b-第2章shell脚本入门",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#b-第2章shell脚本入门","aria-hidden":"true"},"#"),e(" B-第2章Shell脚本入门")],-1),d=l("p",null,"B-第2章Shell脚本入门",-1),b=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),f={class:"table-of-contents"},S=c('<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="b-第2章shell脚本入门-1" tabindex="-1"><a class="header-anchor" href="#b-第2章shell脚本入门-1" aria-hidden="true">#</a> B-第2章Shell脚本入门</h2>',3),k=l("li",null,[l("p",null,"已简单回顾了 Shell 是什么，接下来将直接上手操作，编写一个 Shell 脚本。编写脚本的基本示例通常是“Hello World”，在编程语言学习中，入门案例一般都是“Hello World”。接下来尝试用 Shell 脚本输出“Hello World”。")],-1),x=l("li",null,[l("p",null,"先介绍 Shell 脚本的格式。对于 Shell 脚本，默认后缀名通常是“.sh”，比如之前列举的脚本。不过，在 Shell 解析过程中，对后缀名无要求，只要是可执行文件，且内容按 Shell 标准编写，后缀名是什么都行，甚至不写后缀名也可以，只是约定俗成一般加“.sh”后缀。")],-1),m=l("li",null,[l("p",null,"可以看一下脚本的具体样子来学习如何编写。这里使用“less”命令，比如“less /bin/unix-lpr”，虽不知道其用途，但能看到其格式。进入后会发现，带“#”号的部分明显是注释，下面正式内容开始有“=”，明显是在赋值，后面还有各种“=”及路径，后面可能有各种操作，具体语法暂不关注，关键先看开头。开头的注释部分有一句特殊的第一行注释，即“#!”后跟“/bin/sh”，这表示当前默认选择的命令行解析器。在 CentOS 7 中，“sh”默认指向“bash”，所以编写 Shell 脚本时，通常第一行指定的解析器是“/bin/bash”。")],-1),g={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},B={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},H=l("li",null,[l("p",null,"进入后，首先写“#!”后跟“/bin/bash”，一般都写成“bash”。接下来要输出“Hello World”，观察会发现脚本也是一行一行解析，与在命令行控制台输出命令执行一样，本质相同。在命令行控制台若要打印“Hello World”，使用“echo”命令，所以在脚本中可直接写“echo”，后跟引号括起来的“Hello World”，编写完成。")],-1),W={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},C={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},E={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},v={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},N={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},V={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},L=l("li",null,[l("p",null,"比较这两种执行方式，会发现第一种使用“bash”命令，相当于另起一个“bash”进程，将文件名作为参数传入，无需脚本有“x”权限；第二种直接调用脚本，让当前“bash”环境执行，所以必须有可执行权限。")],-1),w={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},I={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},O={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},T=l("li",null,[l("p",null,"“source”命令是“bash”的内置命令，可通过“type source”查看，其源自“C Shell”（“csh”），“bash”中也有对应的实现。在一般的 Linux 发行版中，两种方式都支持，可认为等价。")],-1),y=l("li",null,[l("p",null,"这种执行方式与前面介绍的两种常见执行方式的区别在于子 Shell 进程。前面执行 Shell 脚本时，不管用“sh”或“bash”命令解析执行，还是用绝对或相对路径执行，本质上都打开了一个子 Shell 进程，即当前“bash”环境不受影响，为执行脚本在内部嵌套起一个“bash”，在其中逐句解释执行脚本语句并输出结果。而“source”和“.”命令执行脚本时，不启动子进程，直接在当前 Shell 中逐行解析执行脚本命令。这样的好处是没有父子 Shell 的嵌套环境，嵌套环境最大的影响是环境变量，父子之间环境变量的生效范围可能不同，可能在子 Shell 中操作的环境变量在父 Shell 中不生效。若修改了配置文件或环境变量未及时生效，可使用“source”命令执行相关初始化文件，使环境变量生效。")],-1),A=l("li",null,[l("p",null,"这是关于执行脚本的不同方法及相关扩展，一般只需了解前两种方法，特别是第二种，有可执行权限后直接调用执行即可，编写脚本其实很简单。")],-1);function D(j,q){const s=r("router-link"),o=r("ExternalLinkIcon");return a(),i("div",null,[u,d,_(" more "),b,l("nav",f,[l("ul",null,[l("li",null,[h(s,{to:"#概述框架"},{default:t(()=>[e("概述框架")]),_:1})]),l("li",null,[h(s,{to:"#b-第2章shell脚本入门-1"},{default:t(()=>[e("B-第2章Shell脚本入门")]),_:1})])])]),S,l("ul",null,[k,x,m,l("li",null,[l("p",null,[e("有了这个基本概念，接下来看如何编写。首先创建相应目录，在“root”主目录下，为方便管理，创建一个单独文件夹，叫“scripts”（因为是 Shell 脚本）。进入“scripts”目录创建文件，比如第一个文件叫“"),l("a",g,[e("hello.sh"),h(o)]),e("”（默认约定加上“.sh”后缀，不加也可），然后编辑“"),l("a",B,[e("hello.sh"),h(o)]),e("”。")])]),H,l("li",null,[l("p",null,[e("接下来尝试执行脚本，先看当前如何执行。文档中有关于执行方式的说明，第一种最简单，直接使用“bash”或“sh”，后跟脚本的相对路径或绝对路径即可运行。这很好理解，解析脚本需要命令行解析器（Shell 解析器），将其当作命令执行，后跟脚本名。接下来用这种方式尝试，直接“bash "),l("a",W,[e("hello.sh"),h(o)]),e("”（当前工作目录在“scripts”下，相对路径可不写），能在控制台打印出“Hello World”，脚本编写和执行成功。")])]),l("li",null,[l("p",null,[e("若退到其他工作目录，能否执行该脚本？可以，使用相对路径，找到“scripts”目录下的“"),l("a",C,[e("hello.sh"),h(o)]),e("”执行，或使用绝对路径“/root/scripts/hello.sh”，都没问题。因为“sh”是“bash”的软链接，执行效果相同。这是第一种执行方式，使用“bash”或“sh”直接解析执行脚本。")])]),l("li",null,[l("p",null,[e("这种执行方式简单直接，无需额外操作，但实际运用中执行脚本通常不用这种方式。脚本本质上应能直接执行，像一些“.sh”脚本文件，应能直接敲文件名执行，不用其他工具解析，本质上可以。因为当前进程就是“bash”，不用再指定“bash”。所以第二种方式是直接输入脚本的绝对路径或相对路径执行脚本。接下来尝试，省去“bash”，直接用绝对路径调用“"),l("a",E,[e("hello.sh"),h(o)]),e("”，会提示权限不够。查看当前目录下的“scripts”，“"),l("a",v,[e("hello.sh"),h(o)]),e("”是“root”用户创建的文件，有读写权限，但无可执行权限。对于文件，若要执行必须有“x”权限，脚本文件能直接执行，目录若要“cd”进入也需要“x”权限。接下来为文件增加可执行权限，“"),l("a",N,[e("hello.sh"),h(o)]),e("”就有了“x”权限，显示为绿色。此时直接按绝对路径调用能输出结果，相对路径“scripts/hello.sh”执行也没问题。")])]),l("li",null,[l("p",null,[e("需强调的是，若在“scripts”工作目录下，直接敲“"),l("a",V,[e("hello.sh"),h(o)]),e("”不行，尽管在相对路径下且工作目录中有该文件，但 Linux Shell 会将其当作命令去执行，而“/bin”“/usr/bin”目录下无此命令，所以会提示未找到命令无法执行。在当前“scripts”工作目录下执行脚本，用相对路径需加“./hello.sh”，绝对路径也可行。在实际工作中执行脚本通常用这种方式，需熟悉。")])]),L,l("li",null,[l("p",null,[e("这是执行脚本的常见做法，这里再介绍一点扩展知识，即第三种执行脚本的方式，在脚本路径前使用“source”命令或“.”命令执行脚本。接下来尝试，用“source”替代“bash”，如“source "),l("a",w,[e("hello.sh"),h(o)]),e("”（相对路径），或“source /root/scripts/hello.sh”（绝对路径），都能执行。除“source”外，还有完全等价的“.”命令，如“.”空格“"),l("a",I,[e("hello.sh"),h(o)]),e("”（相对路径）也能执行。要区分“./hello.sh”（工作目录下的相对路径）和“.”空格“"),l("a",O,[e("hello.sh"),h(o)]),e("”，执行方式完全不同。")])]),T,y,A])])}const G=n(p,[["render",D],["__file","B-第2章Shell脚本入门.html.vue"]]);export{G as default};
