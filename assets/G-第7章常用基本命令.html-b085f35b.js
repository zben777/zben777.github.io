import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as r,d,a as l,e as s,w as e,b as i,f as n}from"./app-2a2d189a.js";const u={},c=l("h1",{id:"g-第7章常用基本命令",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#g-第7章常用基本命令","aria-hidden":"true"},"#"),i(" G-第7章常用基本命令")],-1),h=l("p",null,"G-第7章常用基本命令",-1),m=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"说明"),l("p",null,"主要是各种搜索找的学习；")],-1),g={class:"table-of-contents"},b=n(`<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h2 id="概述框架" tabindex="-1"><a class="header-anchor" href="#概述框架" aria-hidden="true">#</a> 概述框架</h2><h2 id="g-第7章常用基本命令-1" tabindex="-1"><a class="header-anchor" href="#g-第7章常用基本命令-1" aria-hidden="true">#</a> G-第7章常用基本命令</h2><h2 id="一、linux-系统实操篇-常用基本命令学习" tabindex="-1"><a class="header-anchor" href="#一、linux-系统实操篇-常用基本命令学习" aria-hidden="true">#</a> 一、Linux 系统实操篇：常用基本命令学习</h2><ul><li><p>接下来是学习的重点——实操篇，主要是学习 Linux 系统中常用基本命令。我们知道，在 Linux 系统的/bin 和/sbin 目录下有大量的命令。逐一学习这些命令较为枯燥，因此，在这一章，我们将其分为 11 个小节，按不同类型和类别分别介绍常用基本命令。</p></li><li><p>提到 Linux 系统中的命令，指的都是在 shell 层面。因为 shell 本身可以看作是一个命令解释器，为我们提供了一个交互式的文本控制台界面。在 shell 终端输入命令，shell 会对其进行解释，最终交由 Linux 内核执行。所以，shell 是连接外部应用和 Linux 内核的桥梁，也是在 Linux 系统上执行操作的主要手段。</p></li><li><p>例如，之前在虚拟机中输入“ls”这样的命令来列举当前目录下的所有文件。输入命令后，当前使用的终端控制台负责与用户交互，shell 接收到命令后，会调用相应的程序进行分析解释，然后交给 Linux 内核执行，最终将结果以交互式的方式展示出来，这就是最简单的命令调用过程。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>base<span class="token punctuation">)</span> bzhang@pc243<span class="token operator">:</span><span class="token operator">~</span><span class="token operator">/</span>Linux$ ls
test31<span class="token punctuation">.</span>txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p>在此过程中，我们提到的 shell 究竟是什么呢？在 Linux 系统中，shell 的具体实现方式多种多样。通常，在当前的发行版本中，/bin 目录下会有一个名为“sh”的命令，可将其视为 shell 命令的入口，我们打开的交互式界面实际执行的就是这个“sh”命令。</p></li><li><p>Linux 最早源于 Unix，在 Unix 中，最终解释执行的程序叫做“bourne shell”。不过，它的特点是 shell 编程功能强大且灵活，但在处理与用户的交互方面稍显不足。后来，Linux 在“bourne shell”的基础上发展出了新的 shell 终端，在中间加入了“again”，即“bourne again shell”，取其首字母“b”“a”“sh”，当前大多数 Linux 发行版使用的 shell 叫做“bash”，这是一个交互式的命令解释器程序。</p></li><li><p>当然，“bash”功能众多，显得较为臃肿复杂，因此一些发行版希望对其进行简化和优化。比如，“debian”系列以及基于“debian”的 Ubuntu，从 6.10 版本之后，默认的 shell 工具是“dash”。此外，还有其他的 shell 工具，如“csh”。我们这里主要使用“bash”。</p></li><li><p>在 CentOS 7 系统中，默认的 shell 就是“bash”。在虚拟机中可以查看，比如在计算机中进入/bin 目录，通过搜索“sh”命令，可以发现它是一个链接，查看其属性，会发现它链接到了“bash”。同样，通过命令行“ls -l /bin | grep sh”也能看到相关信息，表明“sh”链接到了“bash”应用。当然，在/bin 目录下也能找到“bash”命令。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>这个命令是在 Linux 系统中执行的，其作用如下：

<span class="token number">1.</span> \`ls <span class="token operator">-</span>l <span class="token operator">/</span>bin\`：
   <span class="token operator">-</span> \`ls\`是列出目录内容的命令。
   <span class="token operator">-</span> \`<span class="token operator">-</span>l\`参数表示以长格式显示文件信息，包括文件权限、所有者、大小、修改时间等详细信息。
   <span class="token operator">-</span> \`<span class="token operator">/</span>bin\`是一个目录，通常包含许多常用的可执行命令。

<span class="token number">2.</span> \`<span class="token operator">|</span>\`：管道符号，将前一个命令的输出作为后一个命令的输入。

<span class="token number">3.</span> \`grep sh\`：
   <span class="token operator">-</span> \`grep\`是一个用于在输入中搜索指定模式的命令。
   <span class="token operator">-</span> \`sh\`在这里是要搜索的模式。这个命令会在\`ls <span class="token operator">-</span>l <span class="token operator">/</span>bin\`的输出结果中查找包含字符串\`sh\`的行。

总体来说，这个命令的目的是在\`<span class="token operator">/</span>bin\`目录下列出的文件信息中，找出文件名或其他信息中包含\`sh\`的那些条目，可能是查找与 shell 相关的可执行文件。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><ul><li><p>接下来，所有的命令都在“bash”中执行和解释。前面提到/bin 和/sbin 目录下有众多命令，数量繁多，即使分类学习，也难以全部记住。学习命令的关键在于熟悉不同类型，通过熟悉命令掌握 Linux 系统的基本原理和基本操作方法，重点是掌握方法。若遇到未记住或从未见过的命令，可查询类似命令大全的手册。</p></li><li><p>在 Linux 开源社区，为程序员提供了非常方便的命令手册，调用方式也很简单，无需额外下载或购买，有一系列的帮助命令，其中最主要的是“man”。“man”并非“男人”的意思，而是“manual”的缩写，即手册，它是 Linux 系统的在线帮助文档，内容丰富，涵盖了 Linux 使用的方方面面，分册管理，共 9 册，包括常用的可执行程序、shell 命令、系统调用、库函数、文件格式、内核进程等，可查询到几乎所有的信息，是非常全面的基础文档。</p></li><li><p>其使用方法简单，若要查看某个命令的帮助信息，直接输入“man”，后跟命令名称即可。例如，输入“man ls”，可进入一个页面，其中“NAME”部分说明了“ls”命令的主要作用是列出当前目录下的内容，“SYNOPSIS”是基本使用语法，即“ls”后面可跟各种选项和文件名。“DESCRIPTION”部分详细列出了具体参数的含义，包含了该命令的所有用法。文档已汉化，显示清晰。若要查看文档的其他部分，可通过方向键上下移动，嫌移动慢可按空格翻页，或按“page down”键，向上翻页则按“page up”键，或按“f”键向下、“b”键向上。文档中如“-l”参数，全称是“--format=long”，以长格式显示，除文件名外，还显示文件类型、权限、硬链接数、所有者名称、组名、大小等信息。若要退出页面，按“q”键即可。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token punctuation">(</span>base<span class="token punctuation">)</span> bzhang@pc243<span class="token operator">:</span><span class="token operator">~</span>$ man <span class="token function">ls</span>

<span class="token punctuation">(</span>base<span class="token punctuation">)</span> bzhang@pc243<span class="token operator">:</span><span class="token operator">~</span>$ ls <span class="token operator">-</span>l Linux
total <span class="token number">4</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span> <span class="token number">1</span> bzhang bzhang <span class="token number">10</span>  <span class="token number">8</span>月 <span class="token number">31</span> <span class="token number">22</span><span class="token operator">:</span><span class="token number">53</span> test31<span class="token punctuation">.</span><span class="token function">txt</span>
<span class="token punctuation">(</span>base<span class="token punctuation">)</span> bzhang@pc243<span class="token operator">:</span><span class="token operator">~</span>$ ls Linux
test31<span class="token punctuation">.</span><span class="token function">txt</span>
<span class="token punctuation">(</span>base<span class="token punctuation">)</span> bzhang@pc243<span class="token operator">:</span><span class="token operator">~</span>$ 



<span class="token function">LS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                                                                User Commands                                                               <span class="token function">LS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

NAME
       ls <span class="token operator">-</span> list directory contents

SYNOPSIS
       ls <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

DESCRIPTION
       List information about the <span class="token function">FILEs</span> <span class="token punctuation">(</span>the current directory by <span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  Sort entries alphabetically <span class="token keyword">if</span> none of <span class="token operator">-</span>cftuvSUX nor <span class="token operator">--</span>sort is specified<span class="token punctuation">.</span>

       Mandatory arguments to <span class="token keyword">long</span> options are mandatory <span class="token keyword">for</span> <span class="token keyword">short</span> options too<span class="token punctuation">.</span>

       <span class="token operator">-</span>a<span class="token punctuation">,</span> <span class="token operator">--</span>all
              <span class="token keyword">do</span> <span class="token operator">not</span> ignore entries starting with <span class="token punctuation">.</span>

       <span class="token operator">-</span>A<span class="token punctuation">,</span> <span class="token operator">--</span>almost<span class="token operator">-</span>all
              <span class="token keyword">do</span> <span class="token operator">not</span> list implied <span class="token punctuation">.</span> <span class="token operator">and</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>

       <span class="token operator">--</span>author
              with <span class="token operator">-</span>l<span class="token punctuation">,</span> print the author of each file

       <span class="token operator">-</span>b<span class="token punctuation">,</span> <span class="token operator">--</span>escape
              print C<span class="token operator">-</span>style escapes <span class="token keyword">for</span> nongraphic characters

 Manual page <span class="token function">ls</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> line <span class="token number">1</span><span class="token operator">/</span><span class="token number">215</span> <span class="token number">10</span><span class="token operator">%</span> <span class="token punctuation">(</span>press h <span class="token keyword">for</span> help <span class="token operator">or</span> q to quit<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>之前还使用过切换当前目录的命令“cd”（change directory），输入“man cd”，发现显示的并非“cd”的信息，而是“bash”的解释，这是因为“cd”与“ls”不同，“ls”是一般化命令，而“cd”是 shell 中的内置命令。</p></li><li><p>内置命令和外部命令的概念：一部分命令直接内嵌在 shell 中，通常是基础功能的系统命令，如“cd”，还有之前提到的输入“exit”可直接退出当前控制台环境，“exit”也是内置命令。这些内置命令直接写在“bash”源代码中，与“bash”融为一体，系统启动、“bash”加载后，这些命令也随之加载，常驻系统内存。而其他命令则需要从外部调用，功能较多、复杂度较高、数量庞大，属于系统中的实用程序。外部命令的执行由 shell 控制解释，如“ls”就是外部命令。</p></li><li><p>判断一个命令是内置命令还是外部命令，可使用“type”命令。例如，“type cd”显示“cd”是“shell 内嵌”，即内置命令；“type ls”则显示其为“/bin/ls”，即外部命令。另外，“type useradd”显示其为“/usr/sbin/useradd”，也是外部命令。常见的内置命令还有“history”，输入“history”可列出之前输入过的所有命令。</p></li><li><p>对于内置命令，如“cd”，在“man”手册中不能直接查看，需在后面加“-f”，如“man -f cd”，可看到在不同分册中有对“cd”的解释。“man”手册分册管理，第一册中的“cd”解释可能是对“bash”的说明，第三册和“POSIX”标准（EP 册）中也有“cd”的解释。</p></li><li><p>“man”本身也是一个命令，输入“man man”可查看其含义，即格式化并显示在线帮助手册页面。</p></li><li><p>若觉得“man”命令打开的页面内容过多、复杂，还有更简洁高效的版本，即“help”命令。其用法与“man”类似，“help”后跟命令名称，如“help cd”，可获取“cd”的相关信息，但“help”命令只能获取 shell 内置命令的帮助信息，对于外部命令，如“ls”，输入“help ls”会提示无匹配的帮助主题。而外部命令通常提供了另一种简洁的帮助信息，即在命令后加“--help”参数，如“ls --help”，可看到该命令的帮助信息。</p></li><li><p>了解这些帮助指令后，学习过程中无需背记所有命令，忘记时查询即可。若不习惯英文帮助信息，可在网上查询，但需与官方文档对比，以防网上信息不准确。</p></li><li><p>最后，介绍一些 shell 中常用的快捷键。之前用过“Ctrl + c”，如在进行“ping”操作时，若要停止不停跳动的连接信息，可按此快捷键停止当前进程。还有“Ctrl + l”用于清屏，或者使用“clear”命令，效果类似。“reset”命令可彻底清空当前工作区域，将当前的“bash”和“shell”环境重新初始化。另外，善于使用“Tab”键，可提示补全信息，自动补全输入内容，减少输入错误，提高效率。通过上下键可回溯之前输入过的命令，方便快速重新输入。</p></li><li><p>这些快捷操作是后续学习命令的基础。</p></li></ul><h2 id="二、文件目录类" tabindex="-1"><a class="header-anchor" href="#二、文件目录类" aria-hidden="true">#</a> 二、文件目录类：</h2><h3 id="_1、linux-文件目录类命令" tabindex="-1"><a class="header-anchor" href="#_1、linux-文件目录类命令" aria-hidden="true">#</a> 1、Linux 文件目录类命令</h3><ul><li><p>了解了基本的帮助命令后，相当于有了一本字典，学习命令的过程会轻松许多。不必记住所有命令，只要知晓基本原理，明确其所属类别及查找途径，遇到不知用法的命令，通过“man”工具或“help”命令查看信息即可。这是后续学习的基础。</p></li><li><p>接下来需对常用命令逐一学习，过程可能较枯燥，需做好心理准备，毕竟命令众多。学习过程中，一要学会使用“man”或“help”命令查看用法，二要理论联系实际，亲自操作，否则仅看演示或文档，可能理解不清晰，易产生疲倦和枯燥感。</p></li><li><p>接下来开启第一大类命令——文件目录类的学习，此类命令相对经典且简单，常用用法较少。首先是最简单的基本命令“pwd”，其全称为“print working directory”，即打印工作目录。意思是进入控制台后，一开始会有个波浪线，代表当前用户的主文件夹，后续通过“cd”切换路径，工作目录会改变，有时可能会迷失，“pwd”能告知当前位置，显示的是当前工作目录的绝对路径。</p></li><li><p>绝对路径这一概念，空口说较枯燥，直接实操。不再直接在虚拟机上打开终端输入命令，因实际工作场景多为远程登录云服务器或在机房操作，无法操作实体机，故采用SSH连接。且使用虚拟机时，界面切换不便。连接“100”，后续所有测试命令均在远程登录界面使用。</p></li><li><p>输入“pwd”并回车，控制台显示“/root”，即当前工作目录。因为进入后波浪线表示当前用户主文件夹，“root”用户主文件夹就在根目录下的“root”目录，所以当前绝对路径为“/root”。</p></li><li><p>再举例，修改静态 IP 时，需找到“etc”目录下“systemfig”目录中的一个配置文件。通过“cd”命令切换到对应的目录，此时输入光标前的路径变为“systemfig”，但仅知此文件夹名，不知其所在层级及来源，此时输入“pwd”，可看到当前工作目录为“/etc/systemfig”，此为绝对路径。</p></li><li><p>通过上述两例，可清晰理解绝对路径。从最初的根目录开始，到当前工作目录的路径唯一。Linux 系统文件目录结构有标准规范，根目录以“/”表示，分出众多子文件夹，如“bin”“lib”“home”“root”“etc”等。整个目录结构为树状，根在最上方，文件或文件夹必在某一节点，从根追溯有唯一路径，如同家庭住址，从国家到省、市、县、街道、门牌号，地址唯一，能精确定位。在 Linux 系统命令行操作中，常切换目录，此时查看当前路径可使用“pwd”获取绝对路径。</p></li><li><p>有绝对路径，就有相对路径。绝对路径从根开始，精确到最终地址；相对路径则不精确，需有参照物，即基于当前所在位置。如同两人约定见面，快到时打电话告知位置，一人说在某某大厦，另一人说在其斜对面街道小区。相对路径基于当前位置，经路径跳转可得对方位置。此概念在详细讲解“cd”命令时，可做更深入理解。</p></li><li><p>“pwd”是最简命令，用于查看当前绝对路径，且“pwd”为内置命令，可输入“type pwd”查看，若要查看其帮助信息，使用“help pwd”即可。</p></li><li><p>除“pwd”外，还有常用的切换目录命令“cd”，其全称为“change directory”。熟悉的用法是“cd”后加路径，如切换到“etc/systemfig”，此为绝对路径，以“/”开头表示根目录，从根开始逐层找到当前位置。若要切换到“root”用户主文件夹下的“桌面”目录，可输入“cd /root/桌面”，此时再输入“pwd”，显示为“/root/桌面”，此为绝对路径跳转。</p></li><li><p>若目录层级多，如“桌面”下有“a”“b”“c”等多层级目录，每次切换都写完整路径较麻烦。若从“d”目录跳转到“e”目录，不必写“/root/桌面/a/b/c/e”，可基于当前位置，以相对路径描述。如想从“视频”目录跳转到“桌面”目录，一种方式是“cd /root/视频”，另一种是以当前位置为基准，输入“cd../桌面”，“..”表示返回上一层目录，即从“视频”返回“root”，再进入“桌面”。</p></li><li><p>相对路径不仅此种用法，若在“root”目录下，想从当前目录进入“桌面”目录，可直接输入“cd 桌面”。相对路径与绝对路径最大区别在于，绝对路径以“/”开头，表示从根目录开始，相对路径不以“/”开头，以当前目录为基准点，“..”返回上级菜单，若直接写目录名，则在当前目录下查找。</p></li><li><p>“cd”命令还有其他常用方法，如“cd -”，表示返回上一次所在位置。若从“root”主文件夹切换到“桌面”，再输入“cd -”，可返回“root”主文件夹；从“root”切换到“etc/systemfig”，输入“cd -”，可返回“root”。此用法在实际工作中，于两个远距离目录间来回跳转时很方便。</p></li><li><p>对于“cd”命令，还可直接输入“cd”，不附带任何参数，此操作会返回当前用户的主文件夹。“root”用户返回“/root”，若为普通用户“atguigu”，则返回“/home/atguigu”。可提前了解后续的“su”命令（“switch user”，切换用户），如从超级管理员“root”切换到“atguigu”，输入“su atguigu”即可，进入后“pwd”查看，当前位置为“/home/atguigu”。可通过“exit”退出当前“atguigu”会话，返回“root”。</p></li><li><p>以上是“cd”切换目录的常见用法。</p></li></ul><h3 id="_2、linux-命令-ls" tabindex="-1"><a class="header-anchor" href="#_2、linux-命令-ls" aria-hidden="true">#</a> 2、Linux 命令：LS</h3><ul><li><p>前面讲完了“pwd”和“cd”，接下来介绍另一个熟悉的命令“ls”。“ls”用于列举当前目录下的所有内容，包括文件夹和文件，它是“list”的简写，可添加众多选项。最常用的选项是“-a”和“-l”，分别来看一下。</p></li><li><p>先在有内容的目录，如主文件夹下操作。直接输入“ls”，能看到“CFG”配置文件及蓝色的默认生成目录。若输入“ls -a”，显示内容增多，除原有配置文件和目录外，还有点和两点。两点表示上一级菜单，在“cd”切换时，直接“cd..”会跳转到当前目录的上一级，如在“/root”下执行“cd..”会回到根目录。而一个点表示当前目录，直接“cd.”无影响，相对路径跳转时会用到点和两点。</p></li><li><p>此外，其余以点开头的文件和目录在 Linux 中有特殊含义，它们是隐藏内容。在 Linux 中，隐藏文件和隐藏文件夹均以点开头。所以平时“ls”时看不到，使用“ls -a”则会显示。其中，“.bashrc”文件非常重要，是“root”用户的配置文件，涉及环境变量和别名设置等，后续用到再详述。</p></li><li><p>除“-a”参数外，还有“-l”参数。“-l”表示以长格式列出，之前使用过，能列出当前文件的属性、权限等信息，如文件类型、所有者、所属用户组、创建时间、文件名等。可明显看到，若为一般文件，前面显示“-”，若为目录，显示“d”，通过此可清晰区分文件和文件夹。</p></li><li><p>多说一句，对于“ls”命令，可能见过“ll”，它与“ls -l”完全相同，是该命令的别名。输入“type ll”，可看到它是“ls -l --color=auto”的别名。有时为简便，可直接输入“ll”。若要列出隐藏文件的属性，可输入“ls -al”，将两个参数合并，这是常见用法。</p></li><li><p>以上是关于“ls”的用法。</p></li></ul><h3 id="_3、文件夹的操作" tabindex="-1"><a class="header-anchor" href="#_3、文件夹的操作" aria-hidden="true">#</a> 3、文件夹的操作</h3><ul><li><p>关于文件夹的操作，接下来介绍创建新文件夹和删除文件夹（删除目录）这两个基本操作，它们都比较简单，放在一起说明。</p></li><li><p>首先，若要创建新文件夹，使用“mkdir”命令，这是“make directory”的缩写。若想创建一个名为“a”的文件夹，直接在“mkdir”后跟上文件夹名即可。此时可能看起来没反应，实际上相对路径下已在当前目录生成了“a”文件夹。当然，也可用绝对路径，如“mkdir /a”，此时需注意，若再次查看，当前目录可能看起来无变化，因为该文件夹创建在了根目录下。若要查看根目录下的内容，可输入“ls /”，就能看到“a”文件夹。此外，“mkdir”不仅能创建单个文件夹，还能同时创建多个，例如“mkdir b c”，会同时生成“b”和“c”两个目录。</p></li><li><p>接着思考能否嵌套创建目录，比如创建“b/c/d/e/f”这样的嵌套目录。直接创建会提示“没有那个文件或目录”，因为要创建的“f”所在的“d”和“e”目录不存在。所以，应先创建“d”，再在“d”下创建“e”，然后在“e”下创建“f”。若想简化此过程，“mkdir”最常用的参数是“-p”（“p”表示“parent”，即父目录）。例如，输入“mkdir -p f/g/h/i”，就能自动创建嵌套的目录，且可自动补全。</p></li><li><p>有创建就有删除，删除目录使用“rmdir”命令，这是“remove directory”的意思，其用法与“mkdir”基本相反。例如，当前有“a”“b”“c”三个文件夹，若要删除“a”，直接输入“rmdir a”即可。若要同时删除多个，如“b”和“c”，中间用空格隔开即可。但要注意，若想删除“d”和“g”时，若其内部有子目录或子文件（即非空），则删除会失败。此时，应先删除“d”下的“e”下的“f”，再删除“e”，最后删除“d”，以实现嵌套删除。</p></li><li><p>当然，也有更简单的方法，即“rmdir -p”。例如，对于嵌套的“g/h/i”，若直接删除“g”会提示目录非空，可先删除最底层的“i”，若删除“i”后其上级目录为空，则可自动删除。</p></li><li><p>以上就是文件夹的常规操作，都很简单，自行尝试测试就能掌握用法。</p></li></ul><h3 id="_4、linux-文件操作-创建文件" tabindex="-1"><a class="header-anchor" href="#_4、linux-文件操作-创建文件" aria-hidden="true">#</a> 4、Linux 文件操作：创建文件</h3><ul><li><p>前面了解了在 Linux 中对于目录或文件夹的基本操作命令，接下来需探讨如何操作具体的文件。在 Linux 中，对文件的操作主要包括创建新文件、复制文件、删除文件以及修改文件内容。其中修改文件内容可使用 Vim 编辑器，此部分不再重复介绍。</p></li><li><p>首先探讨如何创建新文件，在 Linux 中，创建新文件的命令为“touch”，其英文含义为“触摸”，相当于创建一个空文件。具体语法简单，直接“touch”后跟上新文件的名称即可，且该名称应为之前不存在的。</p></li><li><p>先查看当前目录下的内容，初始时有两个配置文件及一些文件夹目录。然后执行“touch hello”，当前目录下即新增一个名为“hello”的文件。在 Linux 中，文件可以不带后缀名，默认视为文本文件，可直接打开编辑。直接给定文件名，文件即创建在当前工作目录下。</p></li><li><p>若切换工作目录，如切换到“home”下的“atguigu”目录，再执行“touch hello2”，则“hello2”文件会创建在“atguigu”目录下。跳转回“root”目录，此目录下无“hello2”，只有之前创建的“hello”。</p></li><li><p>在“root”主文件夹下，执行“touch”时也可补充文件路径，明确指定文件的创建位置。如指定“/home/atguigu/hello3”，则文件会创建在指定的绝对路径“/home/atguigu”下。使用绝对路径创建文件的原理清晰，相对路径的使用与之类似，不再赘述。</p></li><li><p>创建文本文件还有另一种方法，即直接使用“Vim”。如“Vim hello4”，可创建一个空文件。但需注意，“touch”创建的空文件直接存在，而“Vim”创建后若未进行任何操作直接退出，文件可能不存在。若使用“:wq”保存后退出，则会创建“hello4”文件。</p></li><li><p>以上为创建文件的相关内容，操作较为简单。</p></li></ul><h3 id="_5、linux-命令-复制文件-cp" tabindex="-1"><a class="header-anchor" href="#_5、linux-命令-复制文件-cp" aria-hidden="true">#</a> 5、Linux 命令：复制文件（CP）</h3><ul><li><p>接下来介绍复制文件的指令“CP”，其英文全称是“copy”，即拷贝。其基本语法为，由于是拷贝操作，需指定源文件和目标位置。它后面有两个参数，一个是“source”，指要复制的原文件；另一个是“dest”，即“destination”，意为目的地，即要把文件复制到何处。</p></li><li><p>进行测试以了解其具体用法。比如，在“home/atguigu”下目前创建了两个文件“hello2”和“hello3”。若想将当前“root”目录下的“init_setup.cfg”配置文件复制过去，可输入“CP”，然后加上要复制的文件，其后跟着复制的目标路径，如“home/atguigu”。也可用相对路径，先退到根目录，再“home.atguigu”。指定路径后回车，在“home/atguigu”下会多出对应的配置文件。</p></li><li><p>若要将“init_setup.cfg”直接复制给“home”下的“atguigu”中的“hello2”文件，需注意，此时目标不再是目录而是文件，这将导致覆盖操作。回车后，Linux 会提醒是否覆盖“/home/atguigu/hello2”，回答有两种，即“y”表示“yes”（要覆盖）或“n”表示“no”（不要覆盖）。若输入“y”并回车，再查看“home/atguigu”下的“hello2”文件，其内容已被完全复制为配置文件的内容。</p></li><li><p>对于复制操作中若目标是文件名的情况，相当于将原内容完全覆盖。</p></li><li><p>有些同学可能觉得每次覆盖操作都有提醒比较麻烦，在 Linux 中，可在“CP”前加“\\”（反斜线），即“\\CP”，这样就不会有提示，直接覆盖文件。若不清楚效果，可覆盖“home/atguigu”下的“hello3”文件，加反斜线后可直接覆盖，不再提示。</p></li><li><p>解释一下这种用法，反斜线表示直接使用 Linux 中的原生命令。通过“type CP”查看其类型，会发现“CP”是“CP -i”的别名。“-i”表示“interactive”（交互式），即出现覆盖情况时给出提示。默认的“CP”（实际是“CP -i”）因考虑覆盖操作不安全而给出提醒，若不想有提醒，可加反斜线使用原生命令“CP”。</p></li><li><p>就如前面提到的“LS”，它是“ls --color=auto”的别名，执行“LS”时有不同颜色显示文件和文件夹，而加反斜线执行“\\LS”则无颜色区分。这就是原生命令和别名的区别。通过“Alias”命令可查看有别名的命令，如“CP”是“CP -i”，“LL”是“LS -l”等。</p></li><li><p>关于“CP”，还有另一种用法，它不仅能复制文件，还能复制文件或目录。若选择目录，单纯复制目录用途不大，通常关心的是复制目录下的内容，此时复制整个文件夹时需加参数“-r”，“r”是“recursive”（递归）的意思，即递归地将文件夹下的每个子文件夹和子文件全部复制过去。</p></li><li><p>现创建一个名为“a”的文件夹，在其中复制配置文件，然后将“a”目录完整复制到“home/atguigu”下，输入“CP -r a /home/atguigu”，查看“home/atguigu”，会有“a”目录，进入查看，其中也有配置文件，这就是递归复制文件夹的效果。</p></li></ul><h3 id="_6、linux-文件操作-删除与移动" tabindex="-1"><a class="header-anchor" href="#_6、linux-文件操作-删除与移动" aria-hidden="true">#</a> 6、Linux 文件操作：删除与移动</h3><ul><li><p>讲完复制文件和文件夹，接下来介绍删除操作。删除命令“RM”是“remove”的简写，其写法简单，后面直接跟上要删除的文件或目录即可。</p></li><li><p>首先看如何删除。退回到“root”目录，其中有很多文件，可随意删除，例如删除“hello”和“hello4”。直接输入“RM hello”，会有提示“是否删除普通空文件 hello”，输入“y”并回车，文件即被删除。之所以有此提示，是因为前面提到“RM”是“RM -i”的别名，“-i”表示“Interactive”（交互），因删除是较危险的操作，默认需提示确认。</p></li><li><p>若不想提示，直接删除，可在后面加选项“-F”（“F”是“False”的意思），强制执行删除操作。例如，“RM -f hello4”，完全无提示直接删除。</p></li><li><p>“RM”也可用于删除文件夹。之前提到有“rmdir”（“remove directory”）指令用于删除文件夹，而“RM”是更通用的删除命令。若直接“RM a”，会提示无法删除，因为“a”是目录。“RM”默认用于删除文件，若要删除目录，需加选项“-r”（“recursive”，递归），例如“RM -r a”，会询问是否进入目录“a”等，确认后即可删除干净。</p></li><li><p>若在“home/atguigu”下，想删除“a”目录且不想多次确认，可使用“RM -rf”，无提示直接删除干净。但使用“RM -f”时务必小心，特别是根目录下，例如“RM -rf /”（“/”是根目录，“*”可视为通配符，表示根目录下所有内容），此操作会删除根目录下所有内容，切勿尝试。</p></li><li><p>既然提到通配符，若在“atguigu”主目录下，只想删除目录下所有文件而保留目录，不想提示可加“-f”，输入“RM -f./<em>”（“.”表示当前目录，“</em>”表示所有内容），即可删除所有文件。使用“RM -f”时务必谨慎。</p></li><li><p>关于神奇的“RM”就介绍到这。</p></li><li><p>文件的基本操作还有“MV”，是“move”的简写，即移动。移动时应有两个参数，前面告知要移动的文件，后面指明移动的位置。“MV”常见用法是前面给文件名，后面给目录名。</p></li><li><p>先回到“root”主目录，若要将“init_setup.cfg”文件移动到“atguigu”目录下，输入“MV init_setup.cfg /home/atguigu”，“root”目录下该文件消失，“home/atguigu”目录下会出现此文件。当然，可再移回。</p></li><li><p>“MV”命令还有另一用法，后面给的不是目录名而是文件名，意味着移动并重命名。例如“MV init_setup.cfg /home/atguigu/1.cfg”，“root”目录下文件消失，“home/atguigu”目录下出现“1.cfg”。一般不建议随意修改系统原有文件，可再移回。</p></li><li><p>在当前目录下，“MV”也可用于重命名，例如“MV a.cfg 2.cfg”，相当于重命名。</p></li><li><p>以上就是关于文件和文件夹的常规操作，包括创建、复制、删除、移动，操作简单，尝试即可掌握。</p></li></ul><h3 id="_7、linux-文件内容查看指令" tabindex="-1"><a class="header-anchor" href="#_7、linux-文件内容查看指令" aria-hidden="true">#</a> 7、Linux 文件内容查看指令</h3><ul><li><p>前面介绍了针对文件或文件夹的基本操作，如创建、移动、复制、删除文件等，这些操作是针对整个文件进行的。通常，我们更关注文件的内容。此前提到，若要修改文件内容，可使用 Vim 编辑器。但有时，我们并不想修改文件，只是想查看其内容，比如配置文件或日志文件，重点在于查看，而非修改。接下来，重点介绍一些查看文件内容的常用指令，无需打开 Vim 过程，仅查看。</p></li><li><p>首先，最简单的指令是“cat”，与猫无关，其实是“catch”的省略，用于捕捉当前文件的所有内容。若想查看某个文件，直接“cat”后跟文件名即可。例如，已知当前目录下有两个配置文件，直接“cat initial_setup.cfg”，所有内容即会列出。但当文件内容较多、较大时，需滚动滚轮查看之前内容，“cat”方式虽简单，但不太方便。此外，“cat”有个可选参数“-n”，可显示所有行的行号。若在“cat”前加“-n”，每行的行号会标注出来，此用法较常见，但当行数很多时，“cat”显示会有麻烦，所以它多用于较小的文件，几行内容，“cat”一下即可直接显示。这便是“cat”的主要用法。</p></li><li><p>因“cat”不太好用，若文件较大、行数较多，可使用能分页、全屏幕显示的工具。这里介绍的第二个指令是“more”。“more”可视为文件内容的分屏查看器，本质上是基于 VI 编辑器的文本过滤器，以全屏幕方式显示文件内容。使用时，输入“more”后跟要查看的文件即可。但与“cat”不同的是，使用“more”查看文件后，相当于进入类似 VI 编辑器的状态，只能查看，不能编辑，且有一些快捷键可用于操作，可翻页查看不同位置的内容。</p></li><li><p>以某文件为例，如“initial_setup.cfg”，直接“more initial_setup.cfg”，即可进入查看。进入后，界面类似之前的 Vim 编辑器，但无颜色高亮显示，下方有“more”及“55%”，表示当前页面显示了 55%的内容。翻页操作简单，与之前的“man”手册操作类似，直接按空格可翻到下一页，按回车则一行一行往下翻。也可按“f”向前直接翻页，按“b”则往回翻页。此外，按“=”可查看当前显示的行数。按“:f”（先按冒号，再按 f）可完整显示当前文件及所在位置等信息。但此信息相对较少，且查找关键字不太方便，只能上下翻页。退出方式有两种，一是不断向下翻页直至结束自动退出，二是直接按“q”中途退出。</p></li><li><p>除“more”外，因其功能不够强大，不能满足全部需求，于是有了“less”指令。“less”与“more”类似，也是分屏显示文件内容的指令，功能更强。首先，它支持各种显示终端，且在操作时，不是一次性加载整个文件显示，而是根据需要动态加载，对于大文件显示效率很高。例如，有一个 13 兆多的文本文件，若在 Windows 系统中直接打开，会很费时，但在 Linux 中用“less”则不会。</p></li><li><p>举例来说，将该大文件上传至 Linux 系统，通过命令行查看，当前目录下多了这个大文件。使用“less”查看，如“less xxxxx.txt”（文件以“x”开头），界面显示信息看似比“more”更少。翻页操作与“more”类似，空格或“f”键可往下翻页，回车可一行一行往下，“b”键可回退上一页，“page up”和“page down”也可实现上下翻页。按“=”可显示更多信息，包括文件名、当前页的行数范围、字节数、显示比例等。而且，加载速度快，打开十几兆的文本文件毫无压力。若要快速跳至文件开头或结尾，按“g”（小写）回到开头，按“G”（大写）跳到结尾。此外，“less”还支持搜索功能，按“/”可输入关键字搜索，如搜索“第二章”可直接跳转，若有多个匹配，按“n”（小写）向下查找，按“N”（大写）向上查找。若要向上搜索，可按“?”加关键字。退出方式与“more”相同，按“q”即可。“less”可说是查看大文档的首选工具，非常好用。</p></li></ul><h3 id="_8、linux-命令-echo-与输出重定向" tabindex="-1"><a class="header-anchor" href="#_8、linux-命令-echo-与输出重定向" aria-hidden="true">#</a> 8、Linux 命令：Echo 与输出重定向</h3>`,29),v=l("ul",null,[l("li",null,[l("p",null,"前面介绍了如何查看文件内容，接下来介绍其他几个常见且与文件操作相关的命令。首先是“Echo”，其有回声之意，并非直接与文件相关，而是直接将内容输出至控制台，即直接给予反馈。此操作非常简单，先执行“clear”清屏，然后可直接使用“Echo”。例如，若想输出“hello word”，直接输入即可在控制台显示。")]),l("li",null,[l("p",null,"若想调整“hello word”的格式，比如不用逗号分隔、不用空格，是可行的。“Echo”默认会将其后所写的全部内容原封不动地输出。若想多空几格，比如输入“apple hello”，输出仍一样，多空几格无用。此时，可使用双引号将内容引起来，这样其中的所有内容都会原样输出。")]),l("li",null,[l("p",null,"接着会想到，若想在输出中加入制表符或换行符，将“hello”和“word”分两行打印，也是可以的。这需要使用转义字符，在计算机系统中，对于字符集的表示，许多控制字符都以转义字符形式出现。例如，换行用“\\n”，制表符用“\\t”，若要表示反斜杠本身，则用“\\”。若想实现换行，输入“hello\\nword”，若无“-e”选项，仍会原封不动输出。所以此时需增加“-e”选项，以支持反斜线控制的转义字符表达式。如此一来，“hello\\nword”就可分两行输出。同时，也可直接输出引号，若要在输出字符中添加引号，通过转义即可实现。这便是“Echo”的用法。")]),l("li",null,[l("p",null,"“Echo”看似与文件无关，那在文件操作中如何应用呢？想到它能输出内容至控制台，那能否将“Echo”的某一内容直接写入文件呢？之前编辑文件内容需用“Vim”打开文本文件，现在能否用命令行直接修改文件内容呢？答案是可以的，这就涉及到输入输出重定向，这里重点介绍输出重定向，使用“>”和“>>”来实现。")]),l("li",null,[l("p",null,"输出重定向指的是，某一指令的结果默认显示在当前控制台界面，若加“>”重定向，则可将显示内容直接写入文件，“>”会直接覆盖文件内容；若用“>>”，则将当前内容追加到文件中。例如，“ll”（显示详细信息），若“ll > infer”，当前无“infer”文件，则会创建该文件并写入“ll”的输出内容。若再执行“ls > infer”，此时文件内容会被“ls”的输出覆盖。若要追加，使用“>>”，如“echo hello Linux >> infer”，再查看“infer”，会发现新增了“hello Linux”。这种操作在某些配置文件的修改中非常方便，若只需追加内容，无需打开“Vim”，直接使用此方法即可，避免误操作。")]),l("li",null,[l("p",null,[i("此外，“Echo”还有另一用法，它不仅能将字符串输出至控制台，还能查看当前的系统环境变量。系统环境变量用“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mtext",null,"”加上变量名表示，若不清楚有哪些系统环境变量，输入“")]),l("annotation",{encoding:"application/x-tex"},"”加上变量名表示，若不清楚有哪些系统环境变量，输入“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"加上变量名表示，若不清楚有哪些系统环境变量，输入"),l("span",{class:"mord"},"“")])])]),i("”后按“Tab”键，会提示众多可选项。例如，“"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"u"),l("mi",null,"s"),l("mi",null,"e"),l("mi",null,"r"),l("mtext",null,"”可显示当前用户为“"),l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"o"),l("mi",null,"t"),l("mtext",null,"”，“")]),l("annotation",{encoding:"application/x-tex"},"user”可显示当前用户为“root”，“")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6944em"}}),l("span",{class:"mord mathnormal"},"u"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"ser"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"可显示当前用户为"),l("span",{class:"mord"},"“"),l("span",{class:"mord mathnormal"},"roo"),l("span",{class:"mord mathnormal"},"t"),l("span",{class:"mord"},"”"),l("span",{class:"mord cjk_fallback"},"，"),l("span",{class:"mord"},"“")])])]),i("PATH”可显示默认的路径包含“/usr/local/bin”等。由于系统命令所在路径在“PATH”环境变量中声明，所以可在任意位置直接调用命令。还可将当前的“host name”等环境变量追加到文件中，如“echo $HOSTNAME >> infer”。")])]),l("li",null,[l("p",null,"以上就是“Echo”与输出重定向结合的一些用法，在实际应用中用途广泛。")])],-1),x=n(`<h3 id="_9、linux-查看文件内容的特殊方法-head-和-tail" tabindex="-1"><a class="header-anchor" href="#_9、linux-查看文件内容的特殊方法-head-和-tail" aria-hidden="true">#</a> 9、Linux 查看文件内容的特殊方法：head 和 tail</h3><ul><li><p>接下来介绍两个查看文件内容的特殊方法，即“head”和“tail”。“head”在英文中意为“头”，它用于显示当前文件头部的内容，即文件开头的几行。默认情况下，“head”后跟一个文件，显示的是该文件的头 10 行内容。若要指定显示前 5 行、15 行或 20 行等，可添加“-n”选项，其后跟上指定的行数。</p></li><li><p>进行测试，例如“head”加上之前的大文本文档，可看到其前十行，每行包括空格等。若想多看些内容，可使用“head -n 20”加上文件名，能看到更多行。</p></li><li><p>有“head”自然有“tail”，“head”显示文件开头几行，“tail”则显示文件末尾几行。默认情况下，“tail”指令只显示最后的 10 行，同样也可加“-n”选项指定显示行数。测试“tail”指令，例如针对之前的文本文档，能看到最后的部分显示。若指定“tail -n 5”加上文本文件，由于最后一行可能无换行符，显示可能看似错一行，回车即可正常。</p></li><li><p>关于“tail”，其用法与“head”类似，关键是它还有一个有趣的选项“-f”。“f”是“follow”的意思，即不仅要看文件末尾当前的几行内容，还要跟踪后续若有新增数据或新增内容，能实时监控并显示出来。因此，“tail -f”可用于实时追踪文本文档的所有更新变化，在实际应用中非常有用。</p></li><li><p>例如，打开日志文件时，往往希望实时追踪其变化，了解当前发生的情况，此时直接用“tail -f”即可看到新增的所有内容。而且由于日志通常是不断增长且不会修改之前的内容，所以“tail -f”特别适用于这种持续增长且只追加的情况，用于跟踪监控。</p></li><li><p>在此进行一个测试，直接使用“tail -f”，不使用之前的大文件，而用“infer”。首先，默认输出 10 行，信息全部列出，但未退出执行，因为这相当于启动了一个监控当前文件状态的进程。</p></li><li><p>此时，可以另外新建一个控制台命令行进行交互式操作。这边监控，那边向文件中添加内容。例如，使用“echo”追加，注意要追加，若直接覆盖，会提示文件已被截断，可自行测试。在此直接追加“hello”到“infer”，回头查看，果然多了“hello”。再追加“welcome info”（多写了一个“e”，不重要），所有追加内容都会实时显示，实现监控。</p></li><li><p>这里还有好玩的功能，即可以暂停。按“Ctrl + s”，再输出追加内容，回头查看，不再输出。继续输出“infer”，回头看仍无显示，这相当于暂时停止了监控，但所有变化仍会记录。何时重新启动呢？之前“Ctrl + s”是暂停，现在按“Ctrl + q”就是继续，继续时之前暂停收到的追加数据会一下子全显示出来。这是个有趣的功能。若不想监控，直接按“Ctrl + c”，相当于结束进程的快捷键，即可退出。这就是“tail -f”的主要用法，在实际工作中非常有用。</p></li><li><p>这里还需多说一点，细心的同学可多做测试。测试可能会发现，“tail -f”监控文件时，若直接用“echo”追加没问题，但直接复写会报错“文件已截断”，相当于追加监控出了状况。复写相当于修改了之前的内容，若重新追加，还可继续监控，但会显示“文件已截断”。</p></li><li><p>另外，若用“Vim”打开“infer”，在后面追加并保存，会发现这边无变化。这涉及到 Linux 文件系统中更底层的概念。在 Linux 文件系统中，所有硬盘分区的文件都会分配一个编号，一般称为“index”，也叫索引节点号。每个文件底层的存储方式是所谓的“inode”，对应的编号就是索引节点号。若用“ls”命令加上“-i”参数，后跟文件名，如“infer”，可看到前面的数字，即当前文件的索引号。在底层，文件快速索引时，硬件上进行文件块安排有一个专门的编号。</p></li><li><p>前面跟踪时，实际是按照索引号跟踪。若用“Vim”打开，在最后一行按“shift + g”，再按小写“o”进入插入模式，添加一个“4”然后保存，此时索引号会变。若还在监控，会发现无显示，因为索引号变了，本质上可认为已变成另一个文件。这算是一点扩展内容，大家下来后可根据自己测试的结果加深理解。这里只要会用“tail -f”做日志的实时监控即可。</p></li></ul><h3 id="_10、linux-命令-ln-与软链接、硬链接" tabindex="-1"><a class="header-anchor" href="#_10、linux-命令-ln-与软链接、硬链接" aria-hidden="true">#</a> 10、Linux 命令：ln 与软链接、硬链接</h3><ul><li><p>在文件目录类命令这部分内容的最后，再来介绍一个比较特殊的命令，即“ln”。“ln”是“link”的简写，用于创建链接，可链接到其他文件或目录。通常用“ln”创建的是软链接。</p></li><li><p>软链接类似于 Windows 里的快捷方式。若为文件或目录创建软链接，相当于有一个单独的文件链接到原始文件。此链接文件有自己的数据块，主要保存的是链接到其他文件的路径，相当于把路径存放在新创建的链接文件中，通过该链接可跳转至真正要访问的文件。若对编程语言，尤其是 C、C++语言熟悉，会发现这有点像指针的概念，即创建的链接相当于指针，指向另一内存空间对应的变量，自身也可视为存放另一内存空间地址的特殊变量。若对指针概念不熟悉，可将其想象为 Windows 中的快捷方式。</p></li><li><p>此前已接触过相关内容，根目录下的“bin”目录并非真正意义上的目录，其图标上有小箭头，实为软链接，链接到“user”下的“bin”目录。“sbin”目录同理，也是软链接，链接到“user”下的“sbin”目录。此即软链接的具体用法。</p></li><li><p>软链接还有另一个名称，即符号链接，因本质上是为原始文件创建了一个符号链接。使用时，一般是“ln”后跟固定选项“-s”（“s”代表“soft”的首字母），此为创建软链接的标准语法，后面是原文件或目录的名称，最后是软链接的名称。创建的链接可以指向文件，也可以指向目录。</p></li><li><p>接下来在命令行中进行操作测试。首先在当前用户的主目录下执行“ls”，查看其中的文件和目录。文件较多，若在其他目录下希望通过快捷方式快速访问“root”主目录下的“infer”文件，可创建软链接。例如，在“home/atguigu”（另一个用户的主目录）下创建指向“root”主目录下“infer”文件的软链接，命名为“my_infer”，命令为“ln -s /root/infer /home/atguigu/my_infer”。此时在“atguigu”目录下会新增“my_infer”文件，其颜色与普通文件和目录不同。查看其类型，使用“ll”或“ls -l”，会发现开头为“l”，若普通文件开头为“-”，目录开头为“d”，显然这是一个链接文件。此软链接指向的是“root”下的“infer”文件。</p></li><li><p>确认该链接文件能否正常打开对应的“infer”文件。先查看“infer”文件内容，在“infer”文件的最后一行添加“666”并保存。然后回到“atguigu”主目录下查看“my_infer”文件，内容完全相同。这表明打开“my_infer”实际就是打开“infer”，二者是链接关系。</p></li><li><p>上述例子是链接到具体文件，同样也可创建链接到目录的软链接。创建新目录“folder”，在其中创建文件“file”。然后在“atguigu”主目录下创建指向“root”主目录下“folder”目录的软链接，命名为“my_folder”，命令为“ln -s /root/folder /home/atguigu/my_folder”。查看可知，“my_infer”指向文件，“my_folder”指向目录，二者均为链接文件，类型开头均为“l”。关于文件类型，在讲解文件权限部分时会详细说明。</p></li><li><p>创建链接文件后，查看其效果。回到“root”主目录，进入“folder”目录，可看到“file”文件。切换到“home/atguigu”，看到“my_folder”，可进入，其中内容与“folder”目录下的“file”文件相同。此时，若使用“pwd”，显示的是链接路径“home/atguigu/my_folder”。若想显示文件的实际路径，使用“pwd -P”，可抛开软链接的影响，显示真正的物理路径。</p></li><li><p>例如，回到“root”主目录，若想进入“my_folder”目录，可直接在“atguigu”目录下执行“cd my_folder”，“pwd”显示的是软链接路径。若想进入实际路径“/root/folder”，在“cd”命令前加上“-P”，即“cd -P my_folder”，进入的就是实际的“folder”目录。此操作同理。</p></li><li><p>关于软链接，有创建就有删除。软链接本质上是特殊文件，存储的是地址信息，删除方式与普通文件相同，使用“rm”命令。在“home/atguigu”目录下，删除指向文件的软链接“my_infer”，直接使用“rm my_infer”，会有提示，若确认删除输入“y”。删除后，“root”主目录下的“infer”文件仍存在，因为删除的只是快捷方式。</p></li><li><p>删除指向目录的软链接“my_folder”时，若不想进行交互确认，可添加“-f”选项。对于文件目录，还可添加“-r”选项，用于删除子文件和子目录。若直接使用“rm -rf my_folder”，会删除链接及目录下的所有内容。回到“root”主目录，“folder”目录不受影响。但需注意，若添加了“/”，如“rm -rf my_folder/”，则会删除真实目录下的内容，如“folder”目录下的“file”文件。因此，删除时务必注意，明确软链接是链接文件，直接删除自身即可。</p></li><li><p>若“folder”目录仍存在，仍可进入“home/atguigu/my_folder”。若“pwd -P”，进入的仍是“root”下的“folder”。若在“root”主目录下删除原始的“folder”目录，再尝试进入“home/atguigu”下的“my_folder”，会发现链接失效，变为黑色，无法跳转，此时可删除“my_folder”。</p></li><li><p>此外，做一点扩展。既然有软链接，还有硬链接。若不添加“-s”选项，直接使用“ln 文件名 链接名”，创建的就是硬链接。硬链接与软链接的区别在于，硬链接是为文件增加一个指向，而软链接是单独创建新的链接文件指向原文件。</p></li><li><p>文件有重要信息“inode”，此前在文件追加内容时提到，使用“Vim”追加后，“tail -f”无法监视，是因“inode”中的信息（如索引）发生变化。“inode”可理解为保存文件原信息（如元数据）的节点数据，包括文件类型、权限、链接数、创建时间等。关键的是，文件有唯一编号（索引节点号），在 Linux 中，允许不同文件名指向同一“inode”节点，从而可创建指向“inode”的相同文件名，这对原文件无影响，只是增加新链接，此即硬链接。硬链接的优点是删除原始文件，不影响其他硬链接文件的访问，因其与原始文件完全平等，均链接到“inode”信息。而软链接创建的链接文件有自己的“inode”和数据块，数据块中存放原始文件地址，若删除原始文件，链接失效。</p></li><li><p>需注意，Linux 文件系统中的链接数概念，指的并非软链接数量，因软链接可视为单独的链接文件，与原文件关系不大，真正的文件链接数是硬链接的数量。硬链接只能针对文件创建，不能针对目录创建，实际使用相对较少，一般创建的多为软链接。此为扩展内容，了解即可。</p></li></ul><h3 id="_11、linux-命令-history" tabindex="-1"><a class="header-anchor" href="#_11、linux-命令-history" aria-hidden="true">#</a> 11、Linux 命令：history</h3><ul><li><p>最后这部分介绍完之后，再来介绍一个所谓的“history”命令。“history”意为历史，此命令用于查看已经执行过的历史命令。可直接在当前命令行输入“history”，即可看到当前“bash”中已执行过的 1000 多条命令，之前每步操作执行的命令一目了然，历史信息尽在其中。所以，最好不要做坏事，否则他人通过“history”命令能看到之前的具体操作。</p></li><li><p>当然，“history”还有一些有趣的具体使用方式。例如，“history 10”，意思是显示过去刚刚输入过的 10 条命令。另外，由于存在对应的编号，若想重复调用某一编号的指令，比如 1156 号指令，可直接在此编号前加一个感叹号，然后回车，即可看到相应的命令。这非常简单。</p></li><li><p>此外，可能有人会想，若做了不好的事，不想留下历史记录，该怎么办？其实也很简单，直接输入“history -c”，可将所有命令清空。此时，似乎看不到任何显示，再输入“history”查看，就没有其他内容，仅能看到“history”这一命令本身。整体使用非常简便。</p></li><li><p>至此，对于文件目录类操作的所有命令就介绍完毕。</p></li></ul><h2 id="三、时间日期类" tabindex="-1"><a class="header-anchor" href="#三、时间日期类" aria-hidden="true">#</a> 三、时间日期类：</h2><ul><li><p>前面介绍的是文件目录类的命令，这部分内容较多，讲解了众多指令。后续需多加练习，于实践中逐渐熟悉。</p></li><li><p>接下来要介绍的这部分相对简单，即时间日期类的命令。这部分主要是获取系统时间，并进行一些时间相关的操作。其中，最简单的是“date”命令，从字面上看，其英文含义为“日期”，用于直接获取当前的系统时间及日期信息并展示出来。在命令行中直接输入“date”，无需添加其他内容，便能看到当前的年、月、日、星期几、时、分、秒等具体时间信息，使用极为简便。</p></li><li><p>关于“date”命令，主要是获取当前的时间信息。除了直接展示所有信息这种最简方式外，更多时候可能会在其后添加某些参数。此处需注意，可提取当前具体的年份、月份、天数以及时分秒等具体信息，它们有对应的语法规则。例如，“%Y”表示当前的年份，“%m”表示当前的月份（“months”），“%d”表示当前的天数（即本月的第几天），“%H”（“hour”）表示当前的小时数，“%M”（注意大写的“M”表示当前的“minutes”，即分钟数，小写的“m”表示当前的月份），“%S”表示当前的秒数。如此，便能显示各种不同的当前信息。在此可稍作测试。</p></li><li><p>例如，若想显示当前的年份信息，在“date”后需加一个“+”，再加上“%Y”，当前为 2022 年。有时若想简写，使用小写“y”，获取的则是当前年份的后两位。因已跨越 2000 年，通常使用大写“Y”以完整显示年份。同样，若要获取当前的月份，可添加“%m”，当前为 3 月。若要获取当前的天数，需在前面添加“+”，即“%d”。对于时分秒，分别为“%H”“%M”“%S”。可将其结合，如“%Y-%m-%d %H:%M:%S”，有时会将其写成自己熟悉的简略形式，以便更清晰地查看。</p></li><li><p>需注意，若有人说不用连字符，而用空格，这是不行的，此时需将后面这部分用引号引起来，且需使用英文符号，这样也能输出当前的年、月、日、时、分、秒。这是较为常用的方法。</p></li><li><p>另外，有一个较为特殊的用法，即“%s”。需注意，大写的“S”指的是当前的秒数，例如当前为 48 秒。小写的“s”则是当前秒数的时间戳。所谓时间戳，指的是自 UTC 标准时间 1970 年 1 月 1 日开始至当前时间的所有秒数计数，目前可能有 16 亿多秒。若后面多了三位，则计数单位不是秒，而是毫秒。使用“date +%s”获取的即为当前秒数的时间戳。在许多需编写系统日志的场景中，此用法非常有用。</p></li><li><p>除上述基本用法外，“date”还可不显示今日当前的时间，可添加“-”参数，并指定具体日期。其后需添加一个特殊的字符串，用于描述是几天前。若数字为正数，表示之前的某一天；若为负数，则表示之后的某一天。例如，“date -d 1 days ago”表示昨天的日期，若为“-1”，则显然是明天的日期。此处的单位可变化，数字也可调整，以显示期望的时间点。这是“-d”选项的用法。</p></li><li><p>还有一个选项“-s”，用于重新设置当前系统时间。操作较为简单，直接输入“date -s”，其后添加期望设置的时间字符串。通常，时间格式为“年-月-日 时:分:秒”，使用连字符和冒号进行分隔。例如，可将当前时间设回到 2017 年。若再次查看“date”，则显示为 2017 年 6 月 19 日。当然，设置未来时间，如 2027 年，也是可行的。</p></li><li><p>若将当前时间调乱后，想联网获取最新时间以同步时钟，需使用另一个命令“ntpdate”。若输入此命令时系统提示不存在，可先进行安装。默认情况下，CentOS 7 应已安装此服务，可直接调用。其后需跟上连接的同步时钟服务器的名称。若未找到具体服务器名称，可上网搜索。使用“ntpdate”并连接服务器，即可同步时钟获取当前最新、最准确的时间。</p></li><li><p>上述即为“date”命令的具体用法。关于时间日期，还有一个常用命令“cal”。已知“cal”是“Calendar”的前三个字母缩写，即日历。此日历的使用方法非常简单，直接输入“cal”，获取的是当天所在月份的日历。因当前设置为 2027 年，所以显示的是 2027 年 6 月的日历。</p></li><li><p>若想看例如当前处于月底或月初时，不光想看当前月，还想查看前一月和后一月的信息，可输入“cal -3”，便能看到相邻的两个月，即 5、6、7 三个月。若不习惯将周日放在第一天，而想将周一放在第一天，可输入“cal -m”，此时周一便会显示在前面。若想看某一具体年份，如 2022 年，输入“cal 2022”，便能看到 2022 年的全年日历信息。若想查看当前系统时间所在年度的信息，输入“cal -Y”，因当前系统设置为 2027 年，所以显示的是 2027 年的全年日历信息，且当天日期有专门标注并高亮显示。</p></li><li><p>上述即为时间日期类命令“date”和“cal”的基本用法，操作较为简单，尝试一下即可掌握。</p></li></ul><h2 id="四、用户权限类" tabindex="-1"><a class="header-anchor" href="#四、用户权限类" aria-hidden="true">#</a> 四、用户权限类：</h2><h3 id="_1、linux-用户管理命令" tabindex="-1"><a class="header-anchor" href="#_1、linux-用户管理命令" aria-hidden="true">#</a> 1、Linux 用户管理命令</h3><ul><li><p>接下来要介绍的是另一大块内容，即 Linux 中关于用户管理的相关命令。</p></li><li><p>我们知道，Linux 系统本身是一个多用户、多任务的分时操作系统，所以可能会有很多人使用同一台机器进行操作，甚至有可能同时登录和操作。人一多，自然就要进行良好的管理，否则就会混乱。因此，必须给不同的用户赋予相应的身份，也就是给他们一个特定的账号，这个账号可以设置自己的密码，并且拥有不同的权限。当用户想要登录系统时，就用分配给自己的账号登录，从而获取不同的系统资源。这就是用户管理的基本思想。</p></li><li><p>接下来我们所要学习的这些命令，都必须以系统的超级管理员（root）身份进行操作，否则一般用户是无法对其他普通用户进行管理的。</p></li><li><p>首先，最简单的用户管理操作就是添加新用户。比如在公司实际开发过程中，团队里来了新人，他可能需要对当前的某个服务器有相应的权限，这时我们就创建一个新用户把他加进来。这个命令很简单，直接使用“useradd”，后面跟着用户的名称就可以了。另外还有一种添加方式，就是加上“-g”选项，后面跟着组名。这意味着在添加用户的时候，可以直接把他归到某一个分组里。关于用户组的管理，我们在下一节会详细介绍，这里就不展开了。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>useradd username       （添加新用户）
useradd <span class="token operator">-</span>g 组名 用户名      （添加新用户到 特定的组里面）

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接下来，我们在命令行里实际操作一下，看看怎么添加用户。首先回忆一下当前系统里有几个用户。首先当然是我们登录进来的身份，即 root 用户，这是当前的系统超级管理员。除了 root 之外，还有一个用户叫“atguigu”，这是在安装系统时就已经创建好的普通用户。root 的主目录是“/root”，而普通用户在登录进来后，他们的主目录都应该在“/home”下面，每个用户都有对应的主目录，比如“atguigu”，我们就可以在“/home”下面看到有一个“atguigu”目录，这就是“atguigu”这个用户的主目录。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> cd <span class="token operator">/</span>home<span class="token operator">/</span>
bash<span class="token operator">:</span> ll
bash<span class="token operator">:</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>现在我们已经有了这样两个用户，接下来再创建一个普通用户，比如“useradd Tony”。创建之后，当前目录下面就多了一个叫做“Tony”的文件夹，这就是新用户“Tony”的主目录。如果我们以“Tony”的身份登录进来，就会进入到“Tony”这个目录下面。我们会发现，对于 Linux 系统而言，所有新创建的普通用户，都会在“/home”目录下面创建一个自己的主文件夹，或者叫主目录。这是创建一个新用户最常见、最简单的方法。</p></li><li><p>当然，对于用户的主目录，也是可以改变其名字的。我们可以直接使用“MV”命令来进行重命名，也可以在创建用户的时候直接对主文件夹进行重命名。比如我们现在再添加一个新用户，叫“David”，同时给他改一下主文件夹的名字。我们加上“-d”选项，后面跟着对应的主文件夹的位置和名称。比如我们还是放在“/home”下面，名字不要叫“David”了，叫“Dave”。接下来我们再看一下，“/home”下面多出来的这个目录就叫做“Dave”，而不再是“David”。这里需要注意的是，当前的用户名字还是叫“David”，也就是我们如果在外面登录的话，用户名还是“David”，而登录进来之后其主文件夹叫做“Dave”。这两者是不一样的，用户名和他的主目录要区分清楚。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> useradd <span class="token operator">-</span>d <span class="token operator">/</span>home<span class="token operator">/</span>dave david
bash<span class="token operator">:</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建了用户之后，当前他还没有密码，没有密码是不安全的，所以我们还得给新创建的用户设置一个密码。设置密码的命令也非常简单，就是“passwd”。比如我们要给“Tony”设置一个密码，输入“passwd Tony”，然后输入新密码“123456”。可以看到这里密码是不会显示出来的，直接输完之后回车就可以。这里它显示说这是一个无效的密码，因为密码少于 8 个字符。我们设置得太简单了，出于安全性的考虑，最好不要这样设置。但是在我们这里，设置成这样也是没问题的。接下来要重新输入密码，注意，这并不是说之前那个不能用了，而是再输一次刚才输过的“123456”就可以了。当然，如果输入一个 8 个字符以上的密码会更好。现在就已经更新完成了。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> passwd Tony
bash<span class="token operator">:</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接下来，如果我们想要以“Tony”的身份重新连接，比如直接新建一个连接，假设当前的这个连接叫做“HEDOP100”，我们当前的身份是“Tony”，下面的密码是“123456”。接下来直接做一个连接，可以看到现在就连进来了。因为我没有改当前的外观，所以是黑屏。我们看现在登录进来的用户就是“Tony”，那他现在的主目录是什么呢？当然就是“/home”下面的“Tony”。同样的道理，我们这里还可以再给“David”设置一个密码，比如我们给多一点，“12345678”。可以看到现在还是说这个密码是无效的，尽管字符够多了，但是可能还是过于简单或者不符合系统的要求，不过没关系，我们还是输入“12345678”。现在输好了之后，同样可以新建一个连接。这个连接我们还是叫做“hadop100”，后面用户是“David”，主机名不要了，删掉。同样接下来进行用户身份的验证，输入“David”和“12345678”。接下来做一个连接，可以看到完全没有问题，连接进来之后，他的主目录就是“/home”下面的“Dave”。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>这就是每个用户登录和连接的情况，现在我们就实现了一个多用户、多任务的分时连接，每个用户登录进来都可以进行操作。当然了，接下来我们不需要让“Tony”和“David”一直登录着，如果想要做别的操作的时候我们再切换过来就可以了。现在我们就直接退出，就相当于注销掉当前用户了。我们可以把这个窗口关掉。</p></li><li><p>接下来我们还是以 root 的身份来做一些用户的管理操作。前面我们已经创建了新的用户，那我们怎么查看一下当前某一个用户到底存不存在呢？比如说我们刚才已经把“Tony”这个用户创建出来了，而且设置了密码，理论上肯定是存在的，都已经用它登录过了。那假如说我们没有登录过，想快速知道有没有这个用户，怎么办呢？可以用这样一个命令，“ID”。“ID”就是身份的意思，看看这个身份到底有没有。比如我们输入“Tony”，看一下，当前就可以显示他的“uid”，“uid”我们就想到了，这是“user ID”，也就是用户的 ID。他的 ID 是 1001，名字是“Tony”，然后还有一个“gid”。这个“gid”是什么呢？“gid”其实就是他的用户组的“group ID”，用户组的 ID 也是 1001，那么这个组也叫做“Tony”。对应的后面可以看到组等于 1001 “Tony”。所以这其实就是当前“Tony”这个用户他所有的所属信息。关于用户组，我们后面再说。同样对应的还有“David”，我们知道“David”对应的应该是 1002，编号是依次往后追加的。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> id username
bash<span class="token operator">:</span> id Tondy
uid<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> gid<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> groups<span class="token operator">=</span><span class="token number">1002</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">(</span>sudo<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>既然有了“Tony”和“David”，那我们可能会感兴趣，之前不是有一个主目录叫“Dave”吗？那“Dave”这个用户存在吗？我们看一下，是没有这样一个用户的，它只是“David”这个用户的主文件夹的名称而已。这就是用“ID”这个命令去验证一个用户是否存在。</p></li><li><p>然后我们又想到，你这只能是单个地去验证，那我现在就想看到当前系统里面到底一共有多少用户，能不能一下子把这个列表都展示出来呢？也是可以的，只不过我们需要去查看一个文件。可以看到，这个文件就在配置文件里面，“/etc”下面有一个叫做“passwd”的文件，就像我们设置密码的那个名称一样。在这个配置文件里面，我们就可以查看当前系统里面到底创建了哪些用户。我们可以看一眼，当然，这个配置文件本身也是可以改的，因为我们是超级管理员，但是一般我们不要去改，所以用“cat”这种方式去查看就可以了。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>如果你想要用分屏的方式，比如“less”也是可以的。比如输入“less /etc/passwd”，接下来我们就可以逐个去查看。最上面我们看到的就是“root”，然后下面我们看到有一堆其他的用户，这些用户好像我们都从来没见过，感觉没什么用。这些是干什么的呢？注意，这里面大多数非常多的这些用户，大部分都是系统中默认创建出来的。比如说“bin”“daemon”“adm”“sync”“halt”等等，这些都是跟系统服务相关的。这些用户是单独创建出来用来运行相应的系统服务的，所以这些用户一般被称为系统用户或者叫伪用户，就是他们并不能作为真正用户的身份去登录，他们就是用来运行系统里面的服务的。所以这些用户我们也不要去删除他们，万一删除了，有可能系统就不能正常运行了，所以一般情况下不要去改动。</p></li><li><p>当然了，我们更感兴趣的是刚才创建出来的那些用户，那那些用户在哪里呢？其实我们看后面这个数字也能看得出来，这里有“0”，“0”这是什么呢？“1”，很显然，这就是当前这个“UID”，后面跟着的肯定就是它的组“ID”了，也就是“GID”。所以当前“root”默认第一个用户是 0，它的编号是 0，那后面就是 1、2、3、4 等等。当然，中间可能有一些编号是空着的，是系统预留出来的。那我们真正刚才自己创建出来的普通用户在哪里呢？直接“shift + j”跳到最后去看，哎，我们看到了“atguigu”后面，我们知道“Tony”不是从 1001 开始的吗？这是因为“atguigu”自定义的普通用户是从 1000 开始的，它的“UID”是 1000，那后面“Tony”是 1001，“David”是 1002 就全列在最后面了。当然了，后面还有其他的信息，比如这里我们看到对应的就是他的主目录。比如“atguigu”在“/home”下面的“atguigu”，“Tony”在“/home”下面的“Tony”。如果是像我们改了的，那就是“/home”下面的“Dave”。后面还有一个“bash”，这是什么意思呢？这就是当前每一个用户用来登录系统跟系统进行交互的方式，它通过哪一个进程去进行交互呢？当然都是通过我们当前的这个“shell”了，我们当前使用的“shell”就是“bash”，对吧，“bash”。或者有些人可能把它叫做“bad shell”，一般情况下我们直接叫做“bash”就可以了。前面你看到这些很多系统用户，他们跟系统交互的方式都是“logging”，当前是不用去登录的，他们自己本身默认就是运行系统服务的。这就是我们可以查看到当前系统里面的所有用户，按“q”可以退出。</p></li><li><p>那除了查看当前所有的用户呢，有的同学可能就想到了，我能不能在当前的这个会话里面直接去切换另外一个用户的身份呢？当然是可以的。一种方式就是你重新去连接，对吧，新创建一个连接，以“Tony”的身份或者以“David”的身份连接，这当然是没有问题的。或者呢，我也可以在当前这个会话窗口里面，把当前的用户做一个“logout”，相当于注销掉，然后再重新以别的用户的身份去登录，这也是可以的。那有没有更加快速的，我不用注销“root”也能直接切换过去呢？因为你想，当前这个“root”，他不是超级管理员吗？理论上他的身份不是随便跳转吗？想跳到谁就跳到谁吗？是可以的，这个命令非常强大，叫做“Su”，就是“switch user”，所谓的切换用户这样的一个操作。“switch user”后面只要跟上你想跳转的用户名称就可以了。所以这里其实非常简单，就是后面，我想跳成“atguigu”，那直接跟上“atguigu”。我们看接下来前面当前登录的状态就变成了“atguigu”了。当前的这个位置还在“/home”下面，如果我们直接“cd”到波浪线，跳转到自己的主目录的话，现在“pwd”一下，我们看到跳转到的就是“/home”下面的“atguigu”。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> su username
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>那当然了，从这个“root”用户跳转到其他用户的话，我们是不需要输入密码，直接就可以过来了。那假如说我们以一个普通用户的身份，现在要跳转到“Tony”，我们看它是提示你必须要输入密码。普通用户，你们彼此都是平等的，你不知道密码当然是不能跳转了。所以这里我输入“123456”，哎，现在我就又以“Tony”的身份跳转到这里了。在“Tony”这里，我看当前的目录是“/home/atguigu”，对吧？那如果我“ls”一下，你会发现它其实是无法打开的，权限不够。这个其实很好理解，因为你是“Tony”的身份，你跟“atguigu”两者都是平等的，那你怎么能随便看别人的东西、改别人的东西呢？所以这个权限是不够的。关于这个权限，我们后面可以再详细展开说。</p></li><li><p>那当然了，这个“Tony”，如果说我们现在要“cd”到他的主目录的话，就会看到跳转到的就是“/home”下面的“Tony”目录了。“David”这个用户也是同样的道理，这个都非常简单。</p></li><li><p>那假如说我们想要再跳转回“root”，那怎么办呢？一种方式是我可以“su”，就是“Su”直接到“root”用户去，当然，这个你必须要输入“root”的密码才可以。那这里我可以直接“control c”把它先退出来，我不输密码，不跳转。因为我之前就是从“root”跳转过来的嘛，那能不能快速地切回去呢？其实也是可以的。就当前来说，其实我们这个用户的切换跳转，它是会话的一个层层嵌套。就本来我开启的是一个当前“root”用户的一个连接会话，在这个连接会话里呢，我做了一个跳转之后，嵌套了一个“atguigu”这个用户的会话，然后基于这个“atguigu”又做了一次跳转，又嵌套了一个当前“Tony”用户的会话。所以接下来呢，我其实可以层层返回，层层退出“Tony”的会话，如果我把它结束掉，直接“exit”退出，那么就会回退到“atguigu”这个用户的会话，同样“atguigu”这个会话再退出，就会退到原来“root”登录的状态。那个会话我们可以看一下，就在这。直接“exit”，哎，我们看现在直接就退回到“atguigu”这个用户了，这个是完全没有问题的。当然如果你在这里的话，直接“ls”的话，你会发现，当前如果我是在这个“atguigu”目录下的话，当然它就可以直接打开了。你如果想要去看，我们回退到上一层菜单，如果想要看“Tony”他的主目录的话，同样他的权限也是不够的。那如果我们再退一层“exit”，再做一个退出“exit”，那现在就回退到最一开始的“root”登录进来之后的那个会话。那现在当然他就有所有的权限去查看了，当前“Tony”的目录也是可以看的，“atguigu”的目录也是可以看的，这是超级管理员嘛。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>那这个过程大家可能就会发现，哇，这个跳来跳去，这就有点麻烦了。那假如说我跳着跳着，根本就不知道当前是哪个用户了，也不知道他这个层级关系了，那怎么办呢？那另外还有一个命令，你可以知道当前用户的身份是什么，这个命令就叫做“who”。当然了后面可以直接加上一个非常简单的操作，“who am i”，问一下我是谁，一个非常终极的哲学问题，我到底是谁？“whoami”。那我们看到当前当然就是“root”用户了。这个“whoami”其实还可以简写，因为你看到这个“root”，它其实后面我们会看到，这相当于这是一个类似于进程的监控信息，所以它其实呢，可以直接把这个“who”和“my”连在一起，“who my”这个显示的就只是当前登录的用户的名称。这里需要大家注意的是，如果我切换到另外一个用户，比方说切换到“David”，切换过来之后，如果我直接敲“whoami”连在一起的话，当前显示的这是“David”，但是如果我敲分开的“who am i”的话，大家其实会发现它还是“root”，因为我当前还是基于“root”用户创建的一个会话，这个进程其实还是“root”登录进来的。所以大家会发现，如果原始的是“root”的话，那你在这里不管跳转多少次，比方说我在跳转到“Tony”那里去，这里输入“123456”，然后我们看一下“whoami”，我们看到还是“root”。那当然你如果要是连在一起敲的话，那就变成了“Tony”了。所以这个大家要区分开来。就这两个命令展示的时候，如果中间有空格拆开，这其实可以认为查看的是最原始登录进来的、创建会话的时候最外层的这个用户到底是谁。那如果说是直接放在一起的“whoami”的话，考察的就是当前具体这个会话目前使用的身份到底是谁。所以“我是谁”，这是一个值得思考的哲学问题，大家一定要把这个命令搞清楚。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> who am i  （最外层的）
bash<span class="token operator">:</span> whoami        （具体的会话）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、linux-用户管理进阶命令" tabindex="-1"><a class="header-anchor" href="#_2、linux-用户管理进阶命令" aria-hidden="true">#</a> 2、Linux 用户管理进阶命令</h3><ul><li><p>前面我们介绍了用户管理中较为基本且常用的命令，如添加用户、设置密码、查看系统中的用户以及使用“Su”命令切换用户等。</p></li><li><p>接下来要介绍的是 Linux 中一个非常有名且强大的命令——“sudo”，有时简称为“sudo”。</p></li><li><p>“sudo”命令的作用是可以给普通用户临时赋予“root”权限，即原本是普通用户，使用该命令后，能够进行超级管理员的相应操作，功能十分强大。</p></li><li><p>接下来，我们在命令行中进行实际操作，了解其具体用法。当前登录用户为“root”，先切换到普通用户，比如切换到新创建的“Tony”用户。“root”用户切换至普通用户无需输入密码，可直接切换。</p></li><li><p>假设以“Tony”的身份查看“root”主目录的内容，显然权限不足，无法查看，因为这是超级管理员的目录。若想查看，通常需注销“Tony”或回退至“root”身份登录，但这样操作繁琐。能否以“Tony”的身份直接提升权限，临时获得执行“ls”查看“root”目录下所有内容的权限呢？答案是可以的，只需使用“sudo”命令，即“sudo ls”，然后需输入“Tony”的密码。输入“123456”后，却提示“Tony 不在 sudoers 文件中。此事将被报告”。这意味着，当前未对“Tony”进行授权，直接输入密码使用“sudo”获取超级管理员权限是不合理的。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> sudo ls

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>因此，需要进行授权操作，授权方式通过“sudoers”配置文件实现。该文件只有“root”用户有权限修改，可在其中指定哪些用户能够执行“sudo”命令。</p></li><li><p>接下来，先返回“root”用户登录状态，修改该文件。此文件位于配置文件目录下的“/etc/sudoers”。文件中以“#”开头的内容为注释。我们当前最关注的是“root”用户的配置，其默认已配置，“ALL=(ALL) ALL”表示“root”用户在任何地方都拥有运行所有命令的权限。若要使其他用户获得类似“root”的超级管理员权限，可复制“root”用户的配置行并进行修改。</p></li><li><p>对“sudoers”文件进行修改，使用“yy”复制“root”用户的配置行，然后在下方粘贴（“p”操作）。接着删除原有的内容，将其改为“Tony”用户。完成修改后，保存（“wq”）。需注意，此时会提示文件为只读，因该配置文件十分重要，默认只读。只有“root”用户有权限修改，且修改时需加上“!”强制执行。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>修改完成后，切换至“Tony”用户，执行“ls”发现权限不足，再执行“sudo ls”，输入“Tony”的密码“123456”，即可成功执行，能直接看到“root”主目录下的所有内容，这便是“sudo”的用法，十分强大，可临时获取超级管理员权限。</p></li><li><p>关于用户管理操作，我们知道能增加、能修改，自然也能删除。若要删除用户，需以“root”身份进行操作，使用“user delete”命令，之前是“user add”，现在是“delete”（“del”），即“user del”。比如，要删除“Tony”用户。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> username <span class="token keyword">delete</span>
bash<span class="token operator">:</span> username del

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>进入“home”目录查看，会发现“Tony”用户的文件夹仍存在，但通过“id Tony”查看，已无该用户，查看“/etc/passwd”文件，也会发现“Tony”已不在。</p></li><li><p>当然，如果不想要对应的主目录，也可完全删除。在实际工作中，通常不建议直接删除主目录，因为当员工离职或换组时，其之前的工作文件可能仍有用，应根据需要再决定是否删除主目录中的文件。</p></li><li><p>也可在删除用户的同时直接删除其主目录，操作是在使用“user del”时加上“-r”选项。比如删除“David”用户，删除后“home”目录下“David”的主目录也会消失。通过“id David”查看，已无该用户，查看“/etc/passwd”文件，也会发现“David”已被删除。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> username del <span class="token operator">-</span>r
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>为了后续测试方便，还是将这两个用户添加回来，使用“user add”添加“Tony”用户，“user add -d Dave”添加“David”用户，使其恢复到未删除前的状态。</li></ul><h3 id="_3、用户组管理命令" tabindex="-1"><a class="header-anchor" href="#_3、用户组管理命令" aria-hidden="true">#</a> 3、用户组管理命令</h3><ul><li><p>在上一节中，我们介绍了一个非常有趣且强大的命令——“sudo”（sudo）。该命令能够让普通用户拥有“root”权限，使其能够执行原本无权进行的操作，功能强大但也存在风险。</p></li><li><p>那么，系统是如何为其授权并控制权限以防滥用的呢？这依靠的是一个配置文件，即“/etc/sudoers”。在这个文件中，指定了哪些用户具有执行命令的权限。也就是说，大多数用户在默认情况下是没有权限执行“sudo”命令的。若想让某个用户拥有此权限，需将其添加到“/etc/sudoers”文件中。例如，在文件中添加了“Tony”用户后，“Tony”就可以使用“sudo”命令查看“root”主目录的内容，而原本他是没有此权限的。</p></li><li><p>然而，如果进行更多测试，可能会发现一些问题。比如，切换到“atguigu”用户，原本该用户无权查看“root”主目录的内容。但执行“sudo ls”并输入“atguigu”的密码后，却能够查看“root”目录下的内容。这较为奇怪，因为之前“Tony”未添加到“sudoers”文件中时，是无法执行“sudo”操作的，会提示未添加到文件中。而现在查看“sudoers”文件，其中并没有“atguigu”用户，那他是如何获取到“sudo”命令权限的呢？这就涉及到了另一个概念——用户组。</p></li><li><p>接下来，我们介绍一下用户组相关的管理命令。什么是用户组呢？简单来说，可以将其视为小组、队列，甚至是一个家族或门派。不同组中的用户，就如同加入了不同的家族或门派，可能拥有不同的技能和权限。在 Linux 中创建的用户，默认情况下属于各自对应的组，即每个用户都有一个专属的组。比如，退出查看“id atguigu”时，会发现其“uid”（用户 ID）为“atguigu”，“gid”（组 ID）也为“atguigu”。这意味着默认情况下，“atguigu”会创建一个与用户名相同的组，并且自身属于该组。需要注意的是，这里的组“atguigu”对应的“gid”为 1000。此外，“atguigu”还属于“wheel”组（编号为 10），关于这个组后面再做解释。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>不止“atguigu”如此，“root”用户的用户名是“root”，“uid”为 0，“gid”（组名）也为“root”，编号为 0，所属组为“root”组。同样，“Tony”和“David”创建后，也有与其用户名相同的组创建出来。这是 Linux 的一个特点，新建用户默认在与其同名的组中。</p></li><li><p>所有用户组的相关信息都存于另一个配置文件中，即“/etc/group”。对于“atguigu”用户，查看此文件仍需使用“sudo”。通过该文件，可以看到“Tony”组（1001）、“David”组（1002）、“atguigu”组（1000）等。当然，还有其他与系统用户和系统用户组相关的组别。</p></li><li><p>说完基本概念，接下来看看对于用户组的具体操作，了解每个用户所属的“门派”。最简单的操作自然是新建一个组，新建组使用的命令是“groupadd”。之前新建用户使用“useradd”，现在是“groupadd”。既然有了“Tony”老师和“David”老师，新建一个组叫做“美容美发”，输入“groupadd 美发”（此处简称为“美发”）。此时会提示权限不足，因为当前是“atguigu”用户。退出并恢复到“root”用户登录状态，然后执行“groupadd 美发”，接下来查看“/etc/group”，会发现多了一个“美发”组，编号为 1003。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span>groupadd 组名
bash<span class="token operator">:</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接下来，希望将“Tony”和“David”两位老师添加到“美发”组中，此时使用的命令与用户相关，用于修改用户所属的用户组。可以使用“usermod”命令，加上“-g”选项表示修改用户相关属性，最常见的就是修改其组名。例如，将“Tony”和“David”添加到“美发”组，输入“usermod -g 美发 Tony”和“usermod -g 美发 David”。接下来查看“Tony”和“David”，会发现用户名不变，分别为 1001 的“Tony”和 1002 的“David”，但用户组名称已变为 1003 的“美发”组，默认的 1001“Tony”组和 1002“David”组已不再使用。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> usermod <span class="token operator">-</span>g 组名 Tony
bash<span class="token operator">:</span> usermod <span class="token operator">-</span>g 组名 David

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>添加到“美发”组后，如果觉得组名不够洋气，想修改为英文名。这就涉及到修改组的组名，之前修改用户所属组使用“usermod”，修改组的信息则使用“groupmod”（group modify）。可以使用“-n”选项进行重命名，例如输入“groupmod -n haircut 美发”，将组名从“美发”改为“haircut”（剪头发）。再次查看“id Tony”，会发现组 ID 仍为 1003，但名称已变为“haircut”，“David”所属的组同样也变为“haircut”。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span> groupmod <span class="token operator">-</span>n haircut meifa
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>若要完整查看当前的组，可以使用“cat /etc/group”配置文件。可以看到存在的组有“root”（编号 0）、“atguigu”（编号 1000）、“Tony”（编号 1001）、“David”（编号 1002）、“haircut”（编号 1003）。</p></li><li><p>前面提到“Tony”和“David”的默认组已不再使用，可以将其删除。删除用户组使用“groupdel”（group delete）命令，删除“Tony”和“David”两个组。然后再查看“/etc/group”，会发现只剩下“atguigu”和“haircut”组，中间的 1001 和 1002 已不存在。总体而言，用户组的管理操作较为简单。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>bash<span class="token operator">:</span>groupdel Tony
bash<span class="token operator">:</span>groupdel David

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在实际应用中，通常会根据不同的项目组或具体的工作（如开发、测试、运维等）将用户划分到不同的组，并为各组赋予相应的权限。</p></li><li><p>前面还有一个问题未解决，即“atguigu”用户不仅属于“atguigu”（1000）组，还属于“wheel”组。“wheel”组类似于管理员组。在默认安装操作系统时，指定了“root”和“atguigu”两个用户，“atguigu”用户虽是普通用户，但被直接添加到了管理员组“wheel”中。查看“/etc/sudoers”文件，除了“root”和“Tony”的指定行外，下面还有一行“%wheel ALL=(ALL) ALL”，其中“%”表示其后是一个组名。这意味着“wheel”组中的所有用户都有权限执行所有命令。因此，“atguigu”作为管理员组的成员，直接执行“sudo”命令时不会有任何提示，可以直接执行，无需像“Tony”那样单独配置。</p></li><li><p>了解了这些，就可以将用户和用户组结合起来，更深入地理解“sudo”命令的使用。</p></li></ul><h3 id="_4、文件权限管理" tabindex="-1"><a class="header-anchor" href="#_4、文件权限管理" aria-hidden="true">#</a> 4、文件权限管理</h3><ul><li><p>前面我们已经介绍了用户管理和用户组管理的相关命令，此时会思考一个问题：用户组划分出来到底有何作用？答案自然是为了对众多用户进行集中化管理。多个用户组成一个用户组，如何与其他组进行区分？其区别在于拥有不同的系统操作权限。比如之前提到的“sudo”，在“sudoers”配置文件中，可以为一个组添加权限，如加上“%”和组名，就可赋予该组执行所有命令的权限。同时，还可以为一个组赋予其他特定权限。</p></li><li><p>在实践过程中，我们会发现，比如切换到“atguigu”用户，想要进入“root”用户的主目录，显然需要提升权限，因为普通用户本身无权查看他人主目录。可以想到，除了超级管理员“root”外，普通用户之间的主目录通常是相互无权访问的。</p></li><li><p>这里还涉及到另一个问题，除了各自的主目录内容，对于根目录下的其他目录，比如“etc”配置文件，到底谁有权访问？“root”用户肯定可以访问，但并非所有普通用户都能访问。这就引出了另一个问题，除了主目录的访问权限，对于其他文件和文件夹，针对不同的用户和用户组，是否也应该有相应的权限划分？这就涉及到接下来要讲的内容——文件权限管理。这其实与前面讲到的用户和用户组管理是紧密结合的，划分用户组甚至划分不同用户的原因，一方面是为了方便多用户同时操作，另一方面也是为了进行权限管理，而权限主要体现在对文件和文件夹的读写操作上。</p></li><li><p>接下来，先讲解一些基础知识，即 Linux 中的文件属性是什么。</p></li><li><p>Linux 系统是典型的多用户多任务系统，不同用户具有不同的权限。为保护系统安全，系统对不同用户访问某个文件或目录时的权限做了不同规定。</p></li><li><p>查看访问权限非常简单，直接使用“ll”（或者其别名“ls -l”）命令，即可显示当前文件的所有信息，其中包含文件的访问权限。</p></li><li><p>回过头来复习一下，直接“ll”查看当前目录，可以看到文件和文件夹前面都有一串字符，这串字符共有 10 位，代表了当前的文件类型和文件或文件夹的访问权限。</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>第一位，如果是“-”，表示这是一个普通文件，可以以文本文件的方式直接用“vim”打开；如果是“d”，表示当前是一个目录（文件夹，“directory”）；如果是“l”，之前见过，表示这是一个链接（“link”）。当然，还有其他不同类型的文件，比如“c”类型和“b”类型。这两种类型都属于设备文件，“c”表示字符类型的设备文件，比如鼠标、键盘等输入操作可能涉及字符，就属于“c”类型；“b”类型则指的是块设备文件，比如硬盘就应是块设备文件。</p></li><li><p>之所以涉及这些设备，是因为之前说过，Linux 系统中一切皆文件，所有设备都用文件来进行管理，所以就有对应的文件类型。可以“ll”一下“dev”目录查看，前面“d”打头的是目录，“c”打头的是字符设备文件，往上翻还能看到“b”打头的块设备文件，“l”打头的则是链接。一般情况下，最常考察和应用的还是普通文件、目录文件夹，最多还涉及“l”（link）链接文件。</p></li><li><p>第一位表示文件类型的字符已经了解，后面 9 位又分别表示什么呢？其实后面 9 位可以每 3 位划分一组。即 2 - 4 位为一组权限，1 - 3 位为一组权限，4 - 6 位为一组权限，7 - 9 位为一组权限。而且权限的写法通常是“rwx”，或者用“-”代替。</p></li><li><p>它们分别表示：1 - 3 位表示所谓的属主权限，属主即该文件的创建者或所有者（“owner”），有时直接称为“u”（“user”），所属用户的权限。通常，这三个权限都是开启的。这三个权限分别是：第一位“r”表示读权限，即是否可以读取该文件；第二位“w”表示写权限，即是否可以写该文件；最后一位“x”表示执行权限，即是否可以执行该文件。所以是读、写、执行（“rwx”）三种权限。</p></li><li><p>同样，4 - 6 位表示属组权限，即当前文件所属的用户组中除属主外的其他用户的权限。一般来说，其权限比属主权限小，通常可能是可读、可执行，但不可写。这里一般称为“g”（“group”）权限，即属组权限。</p></li><li><p>最后，7 - 9 位表示其他用户权限，称为“other”，一般用“o”表示。</p></li><li><p>所以这就是所谓的“UGO”三种不同权限类型的表示。</p></li><li><p>下面具体回顾一下：首位“0”表示当前文件的类型；1 - 3 位确定属主对该文件的权限（通常是“user”）；4 - 6 位确定属组，即所有者同组用户对当前文件的权限（“group”权限）；7 - 9 位则是其他用户（“other”）所拥有的权限。</p></li><li><p>这里需要注意，“rwx”这三种权限对于文件和目录的解释是不同的。对于文件，“r”表示是否可以查看文件（“read”，读取），“w”表示是否可以修改、写入数据（“write”）。注意，“w”可以修改文件，但不代表可以删除文件。要删除文件，相当于要对当前文件所在的目录进行修改，所以必须有当前文件所在目录的写入（“w”）权限。</p></li><li><p>最后的“x”代表可执行权限，即当前文件如果是脚本或可执行文件，赋予“x”权限就可以直接执行，被系统调用执行。</p></li><li><p>对于目录，这三种权限的含义有所不同。“r”（读）权限，表示可以查看目录下的所有内容，只有具有目录的读权限，才可以执行“ls”命令查看目录内的东西；“w”（写入）权限，表示可以在目录内创建文件或目录、删除文件或目录、重命名文件或目录；“x”（可执行）权限，对于目录而言，执行“cd”命令能够进入当前目录，就表示可执行。</p></li><li><p>所以要分清文件和目录对于“rwx”不同权限的解释。</p></li><li><p>接下来，还是在命令行中针对具体情况进行详细分析。</p></li><li><p>首先，查看当前目录下所有的文件和文件夹，前面的 10 位代表了它们的类型和文件权限。</p></li><li><p>比如，“initial_setup_ks.cfg”文件，其权限是：首先“-”表示是普通文件，可以直接用“vim”打开查看内容。前三位表示当前文件的属主权限，由“root”用户创建，后面列出的“root”指的是当前文件的属主，另一个“root”指的是其所属的用户组。所以“root”用户作为属主，拥有读、写权限，没有执行权限，因为这是一个配置文件，最多读取和修改，无法直接执行，系统会自动读取和调用。后面，如果是属主所属的用户组“root”中的其他用户，只有读权限，没有写权限。如果是“other”，同样只能读不能写，这一点非常明确。</p></li><li><p>同样，再看最上面的配置文件，其区别在于属主有读、写权限，而相同用户组中的其他用户和组外的其他用户连读取权限都没有，这看得很清楚。</p></li><li><p>后面还能看到一些目录文件夹，其类型是“d”，后面“rwx”都有，表示“root”用户可以查看目录内容、更改目录内容，创建文件、文件夹，删除、重命名，也可以执行（“cd”）进入当前目录。而且不光“root”用户可以，所属组“root”中的用户和其他用户也都可以读取目录内容和进入目录。</p></li><li><p>接下来做一个简单测试，因为当前目录在“root”的主目录下，其他用户没有访问权限。可以退到根目录查看“root”的访问权限，“cd”到根目录，“ll”查看，“root”是一个目录，“root”用户有读取和执行权限，“root”组也有读取和执行权限，但其他用户既不能读也不能进入。或者在“root”目录中直接“ls -a l”，可以看到“.”（当前目录自身）和“..”（父目录）。由于其他用户无法访问“root”的主目录，为避免这个问题，可以将其下的一些文件复制到比如“atguigu”的主目录下。比如，直接“cp”当前目录下“a”打头的配置文件和“initial_setup_ks.cfg”文件到“/home/atguigu”下。</p></li><li><p>两个文件复制过去后，切换用户为“atguigu”，然后跳转到其主目录，可以“ll”查看，文件的属主和所属用户组还是之前的“root”，权限也未改变。此时查看“initial_setup_ks.cfg”，可以读取，而另一个“a”打头的配置文件无法访问，权限不足。这是因为普通用户对该文件没有访问权限，非常明显。当然，对于“initial_setup_ks.cfg”文件，当前也没有写入权限，除非使用“sudo”或者用强制写入的方式，因为有“sudo”权限，所以可以强行写入，但一般情况下，没有写权限时最好不要写入，因为这是只读文件。</p></li><li><p>既然看到了所有文件信息，也可以对其他一些参数和信息做基本解释。前面是文件类型和权限，后面的“1”表示当前文件的硬链接数。还记得之前“ln -s”创建的是软链接，“ln”不加“-s”参数创建的就是硬链接。硬链接的特点是所有创建的链接都指向同一个文件的“inode”（索引节点），也就是说创建硬链接后，原始文件删除也没有影响，后面的硬链接仍可访问到“inode”信息和存储的数据空间，可防止误删。所以只有当硬链接数量变成 0 时，文件才真正被删除。默认一个文件放在那里，硬链接数量是 1。如果是软链接，数量不会变，可以自行测试。</p></li><li><p>后面是文件的属主（“owner”，“user”），再后面是所属的用户组（“group”），再往后的数字是文件的大小，再往后是文件创建或最后一次更改的时间，最后是文件的名称。</p></li><li><p>总结起来，所有信息都有对应的解释，平常最关心的可能是最前面的文件类型和权限，同时要看清文件的属主和属组，这样就能知道权限如何分配。还要注意一点，后面的链接数，如果是文件，指的是硬链接的个数；如果是文件夹，因为硬链接不能指向文件夹，只能指向文件（指向“inode”），所以这里的链接数指的是其下的子文件夹个数。可以验证一下，回到“root”的主目录，查看“公共”这个子目录，里面为空，但有两个链接数，因为“ls -a”会有两个子目录，“.”表示当前目录自身，“..”表示父目录，所以即使新建一个空文件夹，默认链接数也是 2。</p></li><li><p>这就是关于文件属性和权限的基本介绍。</p></li></ul><h3 id="_5、文件权限更改" tabindex="-1"><a class="header-anchor" href="#_5、文件权限更改" aria-hidden="true">#</a> 5、文件权限更改</h3><ul><li><p>我们已经了解文件的属性和权限的含义，此时自然会想到，如果当前想要访问或修改一个文件的内容但没有权限，该怎么办？最简单的想法或许是切换为“root”用户，或者让“root”用户将自己加入“sudoers”文件以获取执行所有命令的权限，但这种权限过大。一般而言，若只想访问或修改某一特定文件，比如之前在“atguigu”目录下复制过来的两个文件，未必需要以“root”身份或使用“sudo”方式进行文件的读取和写入，只需更改文件的权限，赋予“atguigu”相应的操作权限即可，这为权限管理提供了更丰富、精细的方式。</p></li><li><p>接下来看看如何更改文件的权限，基本语法为“chmod”（change mode），用于改变当前文件的属性。其改变方式如下：文件权限分为“UGO”三组，每组权限由三位字符“rwx”（分别表示读、写、执行权限）对应。操作方式很简单，首先是“chmod”，然后加上“u”“g”“o”“a”中的某一个字符。“u”表示要更改的属主权限（1 - 3 位），“g”表示属组权限（4 - 6 位，group），“o”表示其他用户权限（7 - 9 位），“a”则表示所有权限。接着加上“+”“-”“=”，再跟上“rwx”。</p></li><li><p>“=”表示为相应权限赋值，比如“u=rwx”，即赋予属主“rwx”权限。若为“g+r”，“+”表示增加权限，意味着原本属组可能没有读取权限，现在增加了读取权限，变为“r--”。“-”则表示删除或撤销权限，比如“o - r”，若原本其他用户权限为“rwx”，则删除读权限后变为“-wx”。</p></li><li><p>简单来说，前面指定要更改“UGO”中哪一组的权限，“=”“+”“-”表示赋值、增加或减少权限，后面指明具体的“rwx”权限，最后是文件或目录的名称。这种方式常见，例如，当前为“root”用户（更改文件属性需要权限，“root”用户具备），若想为“initial_setup_ks”文件添加执行权限，可输入“chmod u + x initial_setup_ks”，查看其权限，会发现多了“x”。若想为属组增加写权限，即“g + w”，再次查看，属组的“w”权限便添加进来。添加可执行权限后，文件颜色变为绿色（在系统中，可执行文件通常以绿色显示）。若指定“a”，并赋予“rwx”，即“chmod a = rwx”，则所有权限都变为“rwx”。</p></li><li><p>这是第一种修改文件权限的方式，简单易理解，可读性较强，但组合方式较多，有时看起来可能较复杂。</p></li><li><p>还有一种更强大、直接的更改文件或目录权限的方式，即直接使用数字。“4”表示读权限，“2”表示写权限（w），“1”表示可执行权限（x）。若要赋予某一权限组读和写权限，可将“4”和“2”相加，即“6”。若要赋予读、写、执行全部权限，可将“4”“2”“1”相加，结果为“7”。由此，“UGO”每组权限均可由 1 - 7 的数字表示。“1”表示只有可执行权限（x），“2”表示只有写权限（w），“3”为“2 + 1”，即写和可执行权限（wx），“4”为读权限（r），“5”为“4 + 1”，即读和可执行权限（rx），“6”为“4 + 2”，即读和写权限（rw），“7”为读、写、执行权限（rwx）。</p></li><li><p>仔细观察或了解计算机底层二进制编码，会发现此方式原理简单，即对这三位权限做了二进制编码。若用二进制数表示某一位是否具有权限，“0”表示无权限，“1”表示有权限。比如“000”表示无任何权限，“111”表示拥有全部权限，“111”转换为十进制即为“7”。所以，若“u”位给“7”，表示三位权限全有。若只有前两位有权限，即“110”，转换为十进制为“6”。若只有第一位（读）和第三位（可执行）有权限，即“101”，为“5”。因此，直接给定数字即可，比如常见的“chmod 777”，表示将文件属性修改为最大权限，即所有用户都可读、可写、可执行。</p></li><li><p>接下来进行测试，比如对“initial_setup_ks”文件设置为“777”，所有权限全部开放。但通常其他用户一般不给对应权限，最多给可读权限（r）。实际应用中，可能会为属主赋予“7”或“6”的权限（无执行权限），属组和其他用户给可读权限，完整表示即为“644”（三位一组，分别为属主、属组、其他用户的权限）。输入“chmod 644”进行修改，切换至“atguigu”用户，原本无法读取的内容现在可以读取。只要开放相应权限，就可进行对应操作。</p></li><li><p>需要注意的是，若修改权限的对象是目录，且希望递归地为其内部所有子文件和子文件夹赋予相关权限，可添加“-R”（大写）参数。比如“chmod -R 777 指定目录”，将目录及其下所有文件和目录的权限都设置为“777”，但需谨慎，这相当于开放了完整权限，任何人都可修改和删除。</p></li><li><p>以上是关于文件和目录属性的更改。此外，还有两个方面的内容。对于文件，不仅可以更改其属性（主要是“UGO”相关的权限），还可以更改文件的所有者和所属组。对应的命令，一个是“chown”（change owner），另一个是“chgrp”（change group）。整体较为简单，可以直接尝试。</p></li><li><p>先切换至“root”用户，查看两个配置文件，其所属用户和所属组均为“root”。现在进行更改，比如将属主更改为“atguigu”，执行“chown atguigu 文件”，再查看，属主已变为“atguigu”。若“atguigu”对其拥有所有权限，可将文件权限设置为“700”，此时其他用户无权限。若以“root”用户有权限读取，切换至“atguigu”用户，仍可访问，因为文件属主已变为“atguigu”。若要递归更改目录的属主，可添加“-R”参数，将目录下所有文件和子目录的属主更改为某一用户。</p></li><li><p>除更改属主外，还可更改所属组。比如对“initial_setup_ks.cfg”配置文件更改所属组，输入“chgrp”命令，若当前无超级管理员权限，操作会被拒绝。切换回“root”用户后再执行，所属组即更改完成。</p></li><li><p>由此可见，在 Linux 中，文件属于哪个用户可更改，所属组也不一定是用户对应的组，可进行调整和自定义，其用户和文件权限管理非常方便灵活。</p></li></ul><h3 id="_6、linux-用户管理与文件权限综合应用练习" tabindex="-1"><a class="header-anchor" href="#_6、linux-用户管理与文件权限综合应用练习" aria-hidden="true">#</a> 6、Linux 用户管理与文件权限综合应用练习</h3><ul><li><p>截至目前，我们已对 Linux 中的用户管理和文件权限相关命令有了基本了解。接下来，进行一个综合的应用练习。</p></li><li><p>在实际场景中，公司里不同的项目和部门通常会有不同的组。例如，大数据可能是一个部门，此时可能需要创建一个名为“big data”的组。再比如，还有做测试的组，可以创建为“testing”组，可能还有运维及其他部门，在机器系统中操作时，都应有对应的组进行管理。这是因为组内的文件，同组人员可能能够读取、修改和提交代码，而其他组的同事可能只能访问而不能修改内容，此时就需要对权限进行精细化管理，这涉及到前面所讲的用户管理、用户组管理和文件权限管理。接下来，在控制台中模拟这个过程。</p></li><li><p>首先创建不同的组，先创建“big data”组：<code>groupadd big data</code>。创建完成后，再创建一个组，比如“testing”组。创建这两个组后，可以查看“/etc/group”确认，新创建的组分别是 1004 的“big data”和 1005 的“testing”。</p></li><li><p>接下来在组中添加用户。比如，在“big data”组中，新招了一个员工叫小明，添加时使用“useradd -g”选项，将其直接添加到该组。可以看到小明的“UID”是小明，“GID”是“big data”，没问题。同样，再添加一个“big data”组的同事小亮。</p></li><li><p>在“testing”组中，添加新员工小红和小蓝，使用“-g testing”。</p></li><li><p>添加完成后，确认小红和小蓝都属于“testing”组。先定义好用户组和用户。</p></li><li><p>然后到根目录查看，小明、小亮、小红、小蓝都有以自己用户名命名的主目录。</p></li><li><p>接下来考虑谁创建文件并为他人赋予不同权限。首先是小明，切换到小明用户，小明上线后在自己的主目录下创建一个重要的代码文件，比如“important_code”，内容为“hello word”。创建后查看该文件的属性和权限，只有小明有读写权限，“big data”组的其他人及其他用户只有读权限，用数字表示即为 644 。</p></li><li><p>此时切换到同组的小亮用户。由于新添加的用户都未设置密码，为简便操作，先退回到“root”用户，再切换到小亮。小亮想要访问小明创建的“important_code”文件，需先进入小明的主目录，但权限不够。为清晰展示，先使用“root”用户为小明的目录添加可执行权限“chmod”，再切换到小亮，此时可以进入小明的主目录。但想要访问文件，发现权限仍不够，之前只给了“x”可执行权限，还应添加“r”读权限。回到“root”用户修改权限，再次切换到小亮，此时可以进入小明的主目录并查看文件内容。</p></li><li><p>查看“important_code”文件能否访问，发现可以读取但不能更改，因为文件是只读的。若强制更改只读文件，需加感叹号，但小亮没有“sudo”权限，无法更改，只能强制退出。</p></li><li><p>若希望小亮能修改文件内容，先退出，切换到小明，进入主目录为文件添加写权限“g + w important_code”，再切换回小亮，即可在文件中添加内容并保存。这意味着组内同事可以互相访问文件并修改，共同提交和修改代码，即实现了合作。</p></li><li><p>同组的小亮可以访问和修改，那不同组的小红呢？退出并切换到小红，会发现连小明的主目录都无法访问，权限不足。使用“root”用户更改小明主目录的权限，比如用数字 755 ，更改后切换到小红，可以进入小明的主目录并查看内容，但无法修改“important_code”文件，因为小红属于“other”组，只有读权限。</p></li><li><p>再假设小蓝从测试组换到了大数据组，使用“root”用户更改小蓝的用户组信息“usermod -g big data 小蓝”。查看小蓝是否在大数据组，确认后切换到小蓝，进入小明的主目录并打开“important_code”文件，可以进行修改，因为小蓝已成为大数据组的一员，拥有与小亮、小明相同的权限，而小红仍无法更改该文件。</p></li><li><p>这就是一个综合应用的案例，结合实际公司中的应用场景，对文件权限和用户管理进行了综合介绍。</p></li></ul><h2 id="五、搜索查找类" tabindex="-1"><a class="header-anchor" href="#五、搜索查找类" aria-hidden="true">#</a> 五、搜索查找类：</h2><h3 id="_1、搜索查找类命令" tabindex="-1"><a class="header-anchor" href="#_1、搜索查找类命令" aria-hidden="true">#</a> 1、搜索查找类命令</h3><ul><li><p>接下来要介绍的是搜索查找类的命令，这些命令在实际工作应用中非常常用。</p></li><li><p>首先介绍的是著名的“find”命令。从名字就能看出，这是用于查找的命令。其特点是可以从指定目录向下递归遍历各个子目录，将满足条件的文件显示在控制终端。此命令功能强大，能递归查找，快速找到所需内容。</p></li><li><p>基本语法为：“find”后面加上当前的搜索范围，即从哪个目录开始查找。若不指定，则默认从当前路径开始查找。后面会有一些选项，比如“-name”，表示按照指定的文件名或查找模式来查找文件，即根据文件名是否满足对应模式来决定是否查找出来；“-user”，用于指定用户名；“-size”，用于指定文件大小，大小可用“+”“-”表示大于或小于某个值，后面可带单位，如“B”“C”“W”“K”“M”“G”等，这些是常用的表示文件大小的单位。</p></li><li><p>当然，“find”可选的选项非常多，比如时间范围，也可以按照文件的时间范围进行选择。但一般常用的是根据文件名、用户、大小这三种进行选择。</p></li><li><p>接下来看具体的实际应用。在当前目录下，有很多文件和目录。比如，在当前目录（若未给出，默认就是当前目录“.”）查找“name”等于“infer”的文件，能看到除了当前目录下明显的“infer”文件，在隐藏的“.loco”目录下的“shale”和“trash”目录中还有一个叫“infer”的文件，一下子把所有子目录中的相关文件都找出来了。若想确认，可以在“/public”目录下创建一个“infer”文件，然后重新执行“find -name infer”，就能把这三个文件全部找出来。当然，若不省略路径，给出绝对路径或相对路径，如“/infer”，也能查找出来。若限定只查找当前“/public”子目录，就能只查到刚刚创建的文件。整体使用非常简单。</p></li><li><p>这里需要指出的是，不仅能查找指定名字的文件，还能按照名字模式查找。比如，常用“<em>”表示通配符，可查找所有类似的文件。例如，查找具有固定后缀名的文件，像这里有“CFG”，可以输入“find”，然后是当前目录“/”，接着是“-name”，注意若为“</em>.cfg”，要用引号引起来，方便解析，这样就能找到当前目录下和隐藏目录中的“CFG”配置文件，结果非常清晰。</p></li><li><p>除了用“-name”根据文件名进行匹配（前面是路径，后面是匹配模式），还可以用“-user”。比如在“/home”目录下查找“Tony”这个用户的文件，能看到所有“Tony”的文件都在其主目录下，若之前未创建文件，就都是隐藏文件。</p></li><li><p>此外，还可以用“-size”。指定的是文件大小，按照文件大小进行选择，这也很常见且常用。先查看当前目录下的文件大小，比如“ll”能看到文件大小，若觉得不够直观，可使用“-l -h”参数，更人性化显示。能看到这里有个 14 兆的文本文件。若要筛选出“/root”目录下“size”超过 10 兆的所有文件，输入相应命令，就能筛选出对应的文本文件。若选择范围缩小，比如 2 兆以上，除了文本文件，可能还有其他文件被列举出来。这就是“find”最常见的一些用法。</p></li><li><p>除了“find”，还有一个常用的定位文件路径的命令“locate”。“locate”的定位方式与“find”稍有不同。“find”是在当前目录下的所有硬盘存储的数据文件中寻找，而“locate”并非在硬盘中查找，系统中事先已建立好所有文件名称及其对应路径的关系数据库，即“Loki”数据库。使用“locate”命令查找时，是在这个数据库中查找，所以查找速度特别快，因为无需遍历整个文件系统，只要在数据库中查到对应值即可。</p></li><li><p>但这里存在一个问题，若当前的目录文件系统发生改变，如新建文件、修改或移动文件，数据库并非实时更新。一般默认情况下，数据库每天自动更新一次，不够实时。为保证查询结果准确，在查找定位前应先进行更新操作，更新操作的命令是“updatedb”。</p></li><li><p>第一次执行“updatedb”，若之前未更新且文件更改较多，可能执行较慢，之后再执行就会变快。它其实是将信息更新并写入。若不进行更新，能否查到对应信息呢？若在此期间未做相应更改，或许能查到，但最好先进行更新。</p></li><li><p>接下来在命令行中尝试。首先执行“updatedb”，然后可以进行“locate”操作。“locate”后面可查找感兴趣的内容，比如对“tmp”这样的文件夹感兴趣，查找后会列出所有包含“tmp”这三个字母的文件夹和文件，最先找到的是根目录下的“tmp”文件夹。或者查找当前目录下一个叫“xzhdx”的大文本文件，使用“locate”能直接找到“/root”下的该文本文件。此命令非常好用且简单。</p></li><li><p>这里需要多介绍的是，不仅能查找文件和目录，对于当前 Linux 中的很多命令，也能进行定位。比如像之前查找当前用户时用的“whoami”，现在用“which”。直接输入“which”加上一个命令，比如“which ls”，能看到“ls”是一个别名，位于“/userbin”下。同样，也可以查看“which locate”，能看到位于“/userbin”下。“which”本身也是一个命令，“which which”也是可以的，能看到“which”本身也是一个别名，存在于“/userbin alias”和“/userbin which”下。</p></li><li><p>同样还有一个类似的命令“whereis”，比如“whereis locate”，这是标准的查找“locate”命令位于何处的命令。在需要了解一个命令存放位置时，使用“which”或“whereis”都可以进行查找。</p></li></ul><h3 id="_2、搜索查找命令-grep-及相关操作" tabindex="-1"><a class="header-anchor" href="#_2、搜索查找命令-grep-及相关操作" aria-hidden="true">#</a> 2、搜索查找命令：grep 及相关操作</h3><ul><li><p>除上述内容外，最后要着重介绍一个搜索查找类的命令，即“grep”。“grep”本身较为简单，类似于筛选、过滤查找的命令。其使用方法也很简便，“grep”后面可跟上一些选项，然后是查找的内容及原文件。</p></li><li><p>这意味着它要在文件中查找对应的内容，有点像在“Vim”中直接输入“/”查找内容的过程，只不过无需使用任何文本编辑器，直接在外部执行命令就能查找文件中的内容。</p></li><li><p>与前面讲到的“find”和“locate”最大的区别在于，“find”和“locate”是按照文件名、大小等寻找和定位，而“grep”则是从文件的内容中进行筛选。因此，“grep”的使用更为广泛。</p></li><li><p>前面提到的选项，最常用的是“-n”，指的是将筛选出的内容的匹配行和行号同时列出。</p></li><li><p>通过具体测试来了解一下。比如，有一个初始化的“initsetup_ks.cfg”配置文件，其中很多地方出现了“boot”这个关键字。接下来查找“boot”在文件中的出现位置和行数，输入“grep -n boot initsetup_ks.cfg”并回车，就能查找到，如第三行、第十二行、第十三行等，所有查找到的“boot”都会被列举出来。这是非常有用的操作，经常会在文件或代码源文件中查找某个关键字，“grep”是快速查找的非常有用的命令，主要用于过滤查找。</p></li><li><p>提到“grep”，就不得不提与其经常配合使用的另一个在 Linux 中比较特殊的操作符——管道，即一个竖线“|”。之前在某些场景中也用过，一个命令后面跟一个竖线，表示构建了一个管道。所谓管道，就是前面命令的处理结果通过管道传递给后面，作为后面命令的参数进行处理，相当于将命令串联起来连续处理，这个操作很有趣。</p></li><li><p>来看如何使用这个功能。比如，执行“ls”命令能得到当前目录下的所有文件和目录名称。若当前目录中的文件和目录很多，可能无法快速找到想要的内容。此时可以“ls”后接管道再进行过滤筛选。比如要找后缀名为“.cfg”的配置文件，就能很容易地找到对应的两个“cfg”文件。</p></li><li><p>有时还可以结合管道符做其他操作。比如前面通过“grep”查找配置文件中“boot”关键字，那查找到的这些行一共有几行呢？在 Linux 中，有一个用于统计的命令“wc”（word count 的缩写，在大数据中很常见，用于单词计数统计）。</p></li><li><p>先简单看一下“wc”的效果。比如查看“infer”文件的内容，若直接对“infer”执行“wc”命令，能看到后面是文件名，前面的“21”指的是当前的行数，共 21 行；“22”指的是当前的单词数量，因为大部分内容是连在一起的名字，算一个单词，“hello Linux”中间有空格，空格是分词标志。所以是 21 行、22 个单词，还有 158 指的是所有当前字符所占的字节大小。</p></li><li><p>比如对之前“grep”查找“boot”关键字得到的行做一个统计，直接用“wc”，能看到共 8 行、32 个单词，最后是 341 字节大小。</p></li><li><p>这就是关于“grep”的用法，用于筛选过滤，通常与管道符配合使用。</p></li><li><p>这就是关于搜索查找类命令的简单介绍。</p></li></ul><h2 id="六、压缩解压类" tabindex="-1"><a class="header-anchor" href="#六、压缩解压类" aria-hidden="true">#</a> 六、压缩解压类：</h2><h3 id="_1、linux-中的压缩与解压命令" tabindex="-1"><a class="header-anchor" href="#_1、linux-中的压缩与解压命令" aria-hidden="true">#</a> 1、Linux 中的压缩与解压命令</h3><ul><li><p>接下来要介绍的是 Linux 中的压缩、解压类命令。这类命令整体较为简单，重点在于一个压缩命令和一个解压命令，只要会使用即可。在实际工作中，此类命令使用频繁，经常会与压缩包打交道，所以必须掌握。</p></li><li><p>首先来看非常经典的第一个命令，即“gzip”以及“gunzip”。顾名思义，使用的是“gzip”工具，它是 Linux 自带的压缩文件工具，压缩后的文件后缀名固定为“.gz”。其语法简单，直接“gzip”后跟要压缩的文件，得到“.gz”压缩文件。若要解压，使用“gunzip”，后跟“.gz”文件即可。</p></li><li><p>需要注意的是，“gzip”本身是一个简单的压缩工具，只能压缩文件，不能压缩目录，且不会保留原文件。即原文件压缩后只剩下“.gz”文件，若要保留原文件，需提前复制。一般情况下，有“.gz”文件也可恢复原文件，但要注意它不保留原文件。另外，若同时压缩多个文件，会产生多个压缩包，不会打包在一起，它是纯粹的单纯压缩工具。</p></li><li><p>可在命令行中进行测试。在当前“root”的主目录下，有一个大的“.txt”文件，对其进行压缩打包。直接输入“gzip”，然后跟上文件名称，完成打包，会生成一个“.gz”文件。查看其大小，原文件约 14 兆，压缩后约 6.3 兆，压缩效果明显。若要恢复原文件，使用“gunzip”，后跟对应的“.gz”文件，原文件就会回来，查看大小仍为 14 兆。这就是“gzip”的用法。</p></li><li><p>除了“gzip”，还有一个常用工具“zip”。“zip”用于压缩，“unzip”用于解压。语法为：“zip”对文件进行压缩，得到“.zip”文件；解压时使用“unzip”命令，后跟“.zip”文件。需要注意的是，“zip”可以保留原文件，还能进行目录的压缩，将目录及其中的子目录和文件一起压缩打包。“unzip”解压时，可使用“-d”选项指定解压后文件的存放位置。“zip”工具经典且通用，在 Windows 和 Linux 中都有，既能压缩文件，也能压缩目录，使用较多。</p></li><li><p>在当前控制台进行测试。由于可以压缩目录，直接输入“zip”，加“-r”参数进行递归压缩，将压缩后的文件命名为“my_root.zip”。注意“zip”后面首先是压缩包名称，然后是要压缩的原始文件或目录。压缩过程中会显示相关信息，完成后当前目录会多一个“my_root.zip”。查看其大小为 61 兆。“zip”工具兼具打包和压缩功能，压缩比可能不高。若要解压此压缩包，使用“unzip -d”指定解压目录，如“time”，解压后在“time”目录下会有很多文件，包括“root”目录，其内容与“root”主目录相同，这就是压缩和解压的过程。</p></li><li><p>除了“zip”，接下来介绍另一个重要工具“tar”。对于很多同学来说，“tar”可能更为熟悉。“tar”本质上不是压缩工具，而是做打包归档的，默认不进行压缩，只是将所有东西归到一起。其使用方式为“tar”后跟选项，然后指定打包后的文件名，一般为“.tar”，若要压缩，通常为“.tar.gz”。常见选项有：“-c”表示打包操作；“-x”表示解包操作；“-v”显示打包或解包的详细信息；“-f”指定压缩后的文件名；“-z”表示在打包过程中同时进行压缩，使用的压缩工具是 Linux 自带的“gzip”，所以常见的生成文件后缀名为“.tar.gz”；“-C”表示解压到指定目录。</p></li><li><p>接下来在命令行中进行测试。先退回到“root”目录，对当前的一些文件进行打包和压缩。比如输入“tar”，若要打包并压缩，使用“-zcvf”，指定压缩后的文件名，如“temp.tar.gz”，然后列出要打包的文件，如“initsetup_ks.cfg”、“txd”文件、“infer”以及“public”目录，会生成“temp.tar.gz”。查看其大小，有明显压缩。然后可进行解包解压，使用“tar -zxvf”，指定要解包的文件“temp.tar.gz”，使用“-C”指定解压到“tmp”目录，查看“tmp”目录，会发现解压出的文件和目录，包括“infer”、“CFG”配置文件、“txt”文件和“public”目录。</p></li><li><p>总体对比，“gzip”是单纯的压缩工具，单独使用较少。“zip”和“tar”可视为综合的打包归档工具，“zip”自带压缩功能，“tar”可结合“gzip”（加“-z”参数）进行压缩。整体而言，“zip”和“tar”使用较多，而在实际应用中，“tar”使用最多，因其灵活性高，打包压缩效率也较高。只要掌握其主要参数，多加练习即可。</p></li><li><p>以上就是关于压缩和解压命令的内容。</p></li></ul><h2 id="七、磁盘管理类" tabindex="-1"><a class="header-anchor" href="#七、磁盘管理类" aria-hidden="true">#</a> 七、磁盘管理类：</h2><h3 id="_1、文件目录相关操作及磁盘空间查看" tabindex="-1"><a class="header-anchor" href="#_1、文件目录相关操作及磁盘空间查看" aria-hidden="true">#</a> 1、文件目录相关操作及磁盘空间查看</h3><ul><li><p>到目前为止，我们已经学习了众多命令。整体来看，对于文件和目录的操作已相当熟悉。比如在 7.2 节，主要介绍了文件、目录相关的基本操作；而在 7.4、7.5、7.6 三节内容中，会发现主要探讨的是用户、用户组对文件和目录具有怎样的操作权限。即在进行用户、用户组管理，划分不同用户和用户组时，最终体现在他们对于文件和目录的操作权限上。所以这部分内容，最终也落实在文件上。后面的 7.7、7.8 节介绍的是搜索查找以及压缩解压，这也是针对文件和目录的特殊操作。由此可见，在 Linux 中，一切皆文件，所有的基本命令基本都是围绕文件和目录展开的。</p></li><li><p>前面已经介绍了如何查找当前目录下有哪些文件和子目录，使用“ls”命令非常方便。若想查看当前所有文件的详细信息，可以用“ll”或者“ls -l”将当前信息全部显示出来。但这种显示方式只能看到当前目录下一层级的所有目录和文件。若当前子目录中还有嵌套的子目录，且层级众多，就不方便直接查看了。对于这种情况，Linux 中有一个小工具，可能有同学知道，即“tree”。它能以标准的树状目录形式，将当前感兴趣并想要列举出的目录下的所有子目录层级全部列出。当然，默认的系统中可能没有这个工具，若需要安装，输入“sudo install tree”，表示安装“tree”工具。现在已经安装过，所以无需再安装。安装过程中可能需要一些交互式输入，比如询问是否进行某些操作、安装某些东西，通常输入“y”然后回车即可，逐步完成工具的安装。</p></li><li><p>安装完成后，输入“tree”加上要查看的目录，就能一目了然地看到当前目录下的所有内容，包括所有文件、目录。当然，由于目录名称是汉字，所以这里的显示可能涉及 Unicode，但这不重要，能清晰地看到下面的文件信息和子目录信息。有了“tree”工具，查找查看当前目录下的所有层级结构就不成问题了，能看得非常清晰。</p></li><li><p>不过，还有另一个需求。在实际操作过程中，不光要知道当前的目录结构，随着使用时间增长，文件目录增多，一方面层级结构越来越复杂，另一方面占用的硬盘空间也越来越大，剩余资源就越来越少。作为具有系统管理和维护权限的管理员，要随时关心当前的硬盘占用情况。那如何查看当前硬盘占用情况呢？最简单的想法是之前可以用“ls”或“ll”，加上“-h”，能明显看出当前目录下每个文件的大小。这种方式能看到上面有一个总用量，比如当前目录占了 81 兆。有同学可能会想到，直接“ls -l -h”查看根目录不就行了吗？但会发现，直接看根目录，总用量只有 32K。这是因为在当前统计总用量时，只是简单地将列举出来的文件大小叠加，而在列举大小时，并非将每个目录的总大小都计算在内。比如“root”目录，里面有很多几十兆的东西，但这里的“root”目录看起来只有 4.0K，其实算的只是当前目录（文件夹）本身作为一个文件的大小。所以这样看是不准确的，更希望有一个单独的命令，直接统计出当前目录里所有内容，包括子文件、子文件夹占用硬盘空间的大小。Linux 提供了这样的命令，即“du”。直接使用“du”命令，能看到它直接列出了当前目录下所有嵌套的子目录、子文件夹，包括隐藏文件，最后有一个总计。这就是查看当前目录下所有占据空间大小的基本命令。当然，“du”这样查看会显得比较乱，其实往往可能只希望用简单的方式查看当前目录的大小，这里最后一行就是当前的大小。而且“du”有更多可选的选项，能让输出更友好。接下来看看这个命令的具体用法。</p></li><li><p>“du”的全称是“Disk Usage”，即磁盘目前的占用情况。基本用法是“du”后面直接跟上一个目录或文件，来查看当前目录或文件的大小。当然，文件没必要用“du”查看，直接“ll”就能看到大小，所以一般后面跟的都是目录。</p></li><li><p>再说一下它可以跟上的选项。首先是“-h”，意思是“human readable”，即以人类更易阅读的方式显示，不显示完整的字节数，而是显示为几 K、几 M、几 G 这样带单位的形式，更合理。然后是“-a”，使用“du”命令时需特别注意，默认并非统计所有文件和目录的大小，仔细观察会发现，比如这里有“public”等子目录，剩下的都是点，即当前的隐藏文件或文件夹。之前下面还有几个很大的文件以及打包压缩后的文件，这里都没有显示。所以若要统计所有文件和子目录的大小，必须加上“-a”参数。“-a”指的是全部，不仅查看子目录，还要包括文件的大小。另外还有一个参数“-c”，比较简单，就是显示所有文件和子目录的大小后，最后再显示一个总和。有时可能会觉得这个用处不大，因为像这里最后统计完成后，最后一行统计的就是当前目录（“.”）本身的大小，也可认为是总计的结果。当然，若要真正总计，应加上“-a”和“-h”，这样更易读。可以看到当前这样统计起来是 166 兆，这就是当前统计的结果。</p></li><li><p>不过，按照现在的输出情况，会发现上面输出的内容还是太多。能否更简洁一点呢？首先，若加上“-c”，会发现区别不大，只是多了一个总用量，和直接统计“.”（当前目录）的大小是一样的。若加上“-s”参数，统计效果是只统计当前的总量，注意此时不会再显示下面的任何子目录和文件，相当于只显示一行，即当前整个目录的总大小。当然，有时这个又太简略了，上面那个又太详细了，能否取个折中的方案呢？也是有的，这个方案就是加上“--max-depth”参数，指的是当前统计子目录的最大深度。一般给“--max-depth=1”，再加上“-ah”，能看到只显示当前下一层级的所有子目录或子文件，对当前所有内容做统计，最终看到总大小是 166 兆。当然，有时也会设置为不同的参数，若给 2，统计的个数就会更多，因为会包含下面第二层的子目录。若给 0，其实就相当于上面的“-s”，只显示总和。这就是使用“du”命令查看当前文件和目录占用磁盘空间大小的用法。</p></li></ul><h3 id="_2、磁盘空间查看相关命令" tabindex="-1"><a class="header-anchor" href="#_2、磁盘空间查看相关命令" aria-hidden="true">#</a> 2、磁盘空间查看相关命令</h3><ul><li><p>前面介绍了“du”这个命令，主要用于查看当前文件和目录占用的磁盘空间。若想知道当前“root”目录占用了多少磁盘空间，前面提到直接“du -sh”即可看到，约为 166 兆。因为此时不关心其下具体的文件和子目录的大小，所以直接“du -sh”就行。</p></li><li><p>由此想到，如何查看当前所有硬盘的占用情况呢？有同学可能会想到，直接“du -sh”，然后考察根目录不就行了吗？毕竟所有东西不都放在根目录下吗？直接回车。当然，上面会提示有些地方无法访问，这并不重要，因为这是“Proc”目录，与当前正在运行的系统进程可能有关，有些进程不存在就找不到对应的文件和目录。可以看到，当前总共约 5.3G。这是否就是硬盘被占用的总共大小呢？看起来差不多，但仔细思考会发现，这个命令只能看到根目录下所有文件和子目录统计出来总共占用的大小，与真正磁盘的占用情况不太一样。</p></li><li><p>回忆一下，之前在安装系统前进行磁盘分区操作。当时，有一块 50G 的硬盘，首先划分了一个引导分区，第一个分区挂载到不同目录下，这是引导分区，划出 1G，当时说“boot”用不了这么大，但划 1G 方便些。然后又划出 4G 的空间作为交换分区“swap”，在系统中这个分区没有在目录下的挂载点，其挂载点就是“swap”，当作虚拟内存使用。剩下的 45G 是第三个分区，通通挂载到根目录下。所以会发现，平常使用的所有文件存放的地方应该在这第三个分区的 45G 里。</p></li><li><p>因此，现在关心的是磁盘的占用到底是什么情况。假如只有一块磁盘，如果再来一块硬盘，每块硬盘到底占用了多大空间呢？因为当前的 Linux 文件系统是一个虚拟目录，无法从目录结构中看出是哪块磁盘，磁盘和具体目录的关系是通过挂载点连接在一起的。所以想看清哪块磁盘到底占用了多少空间，能否看到这个详细信息呢？此时不能用“du”，而要用另一个命令“df”。</p></li><li><p>“df”非常简单，是“disc free”的缩写，用于查看当前磁盘剩余的空间，自然也能看出占用的空间。具体语法是“df”，直接“df”也行，后面可以跟一些具体的选项，这里一般给的选项是“-h”，即“human readable”，以更友好、带单位的方式显示空间大小。接下来，直接“df -h”，就能看到当前的磁盘占用信息。</p></li><li><p>这里可以看到，首先是文件系统的展示，然后后面的信息相对简单，包括容量大小、已用大小、剩余可用大小、已用百分比和挂载点。这么多信息，到底看哪个呢？其实通过挂载点能看得很清楚。之前划分了 3 个分区，第一个分区挂载到“boot”下，在文件系统中对应的名称是“/dev/sda1”。想到“/dev”是设备目录，所有设备包括硬盘都会在“/dev”下有对应的文件进行管理，这里的“1”表示的就是当时划分的第一个分区，挂载到“boot”下，这是第一个分区。同样，上面有“/dev/sda3”，“3”表示当时划分的最后一个分区，第一个分区 1G，第二个 4G，最后一个 45G 的空间直接挂载到根目录下。所以看挂载点，其总大小 45G，已用 5.2G，剩余 40G，已用 12%，这就是当前最关心的磁盘占用情况。</p></li><li><p>当然，第一个引导分区“boot”的分区也能看到，当时容量给了 1G，其实现在只用了 169 兆，这也说明一般情况下，引导分区给 200 - 500 兆就足够了，给 1G 有点浪费，但也不重要，隐藏空间足够。</p></li><li><p>另外，会发现除了这两个分区，还有很多磁盘占用信息。需要注意的是，剩下的不完全都是磁盘占用的信息。因为可以看到文件系统不是在“/dev”目录下管理的，直接给的是“tmpfs”或“dev tmpfs”，这表示的是一个临时的文件系统。这是 Linux 中比较特殊的一种文件系统类型，是基于内存的文件系统。所以这里不光对硬盘有展示，对内存相应的设备也有展示。</p></li><li><p>什么样的设备对应的是这个内存设置的临时文件系统呢？不管是真正的内存还是“swap”分区，因为“swap”分区主要跟内存进行页面置换和交换，可以当作虚拟内存，所以它们的文件系统一致，都使用“tmpfs”这个临时文件系统。在这里也能看得很清楚，有一个文件系统，挂载点是“/dev/shm”，“shm”是“shared memory”，即共享内存，意味着这块内存空间是所有系统进程都能共享的，都能访问这个目录并共享这块内存。当然，其大小默认是系统内存的一半，即 2G。另外还能看到一些，比如直接挂载到“raw”目录，肯定与运行时有关。所以想到内存和“swap”分区，它们都与系统或运行时有关，所以都挂载到这些下面。这里有一个特殊的“devtmpfs”，它表示在 Linux 内核一开始启动时，就会创建这样一个文件系统和“/dev”目录，用于管理当前所有设备，这是启动时的创建。</p></li><li><p>所以大概能看出，这里的 2G、2G 等加起来约 8G，本身“swap”当时分配了 4G，内存如果要管理，内存本身也是 4G，所以这里对应的容量看起来也就是 4G 左右。</p></li><li><p>除了使用“df”命令查看当前的磁盘空间，既然涉及到内存相关，能否直接查看当前内存的使用情况呢？有一个很简单的命令，相信大家可能也知道，就是“free”，也可以加“-h”，看得更清楚。一敲，就能看到当前的物理内存以及虚拟内存（即“swap”分区）的占用情况。可以看到当前物理内存 3.8G，占用了 943 兆，剩余 22.0G，除了空闲空间，还有当前正在共享的内存空间，以及用作缓存的空间，总共可用 2.6G。下面是“swap”分区，目前未被使用。这就是一些简单的查看命令，需要知道“df”是查看当前磁盘空间使用情况的基本命令。</p></li></ul><h3 id="_3、磁盘相关命令及设备信息" tabindex="-1"><a class="header-anchor" href="#_3、磁盘相关命令及设备信息" aria-hidden="true">#</a> 3、磁盘相关命令及设备信息</h3><ul><li><p>我们已经了解了“du”和“df”两个命令，现在已知道如何查看磁盘的使用和剩余状况。此时，对磁盘有了基本认识，但会发现这两个命令只是简单查看，按照之前的想法，一块磁盘划分了三个分区，其中的挂载信息和磁盘分区情况并未详细展示。如何查看真正的磁盘信息呢？这需要使用其他命令，接下来要介绍的命令是“lsblk”，即“list block”，列出当前所有块设备的挂载情况。“block”即“BLK”，是块设备的意思，包括硬盘、光盘等存储设备。</p></li><li><p>接下来，直接使用“lsblk”进行查看。可以看到这里展示得很清晰，当前有哪些块设备和存储设备，比如“sda”，后面清晰显示其“type”为“DISK”，这是一块硬盘。该硬盘分为 3 部分，即“sda1”“sda2”“sda3”，这是它的三个分区，后面还有对应的“mount point”，即挂载点。当时进行硬盘分区操作时划分的三个区，现在清晰可见。第一个分区“sda1”挂载到“boot”下，即引导分区；第二个分区之前未显示，实际挂载到“swap”上，是交换分区，即虚拟内存；最后一个“sda3”挂载到根目录下。这就是完整的硬盘分区和挂载信息。</p></li><li><p>除了“sda”这块硬盘，下面还有一个“sr0”。这是什么呢？看到其总共 1G，“type”为“ROM”，就会想到安装系统时使用的光盘，通过光驱加载 ISO 镜像文件并从光驱启动来安装系统。现在虽未使用光盘里的信息，也未将其挂载，但该设备仍在，光驱仍在，其“type”就是“CD-ROM”，所以在系统中的名字就是“sr0”。</p></li><li><p>在所有设备都在“/dev”目录下，当然可以找到“/dev/sr0”。对应的，也能找出完整的信息。“/dev/sr0”，此时会发现，在“/dev”下，除了本身的“sr0”，其类型是“block”，即块存储设备，此外还能找到一个叫“cdrom”。这是 Linux 为方便管理，由于“sr0”看起来不太清晰，所以给了一个更易理解的名字“cdrom”，即光盘驱动器，它其实是一个软链接，直接链接到“sr0”，其文件类型是“link”。这样，当前能查找到的所有存储设备就都清楚了，且其大小与划分的大小完全一致。</p></li><li><p>再来解释一下“sda”这个名称。若使用其他硬盘，或在做虚拟机配置时选择了不同选项，可能会发现这里不叫“sda”，比如可能叫“hda”，也可能叫“vda”，最常见的是“sda”。它们分别表示什么意思呢？主要看第一个字母的含义。</p></li><li><p>在当前使用的机器上，不管是个人电脑还是服务器，所使用的硬盘类型主要有以下几种：一类是 IDE 硬盘，早期硬盘使用 IDE 较多，现在少见，因其读写性能和数据传输速率较慢。现在常见的是 SATA 硬盘以及 SCSI 硬盘。它们的区别在于，SATA 硬盘是串行 ATA 接口规范的硬盘，支持热插拔，比传统 IDE 硬盘快得多，个人电脑一般使用 SATA 硬盘。SCSI 硬盘是小型计算机系统接口标准的硬盘，不光硬盘可用这种接口，像光驱、扫描仪等各种电脑外设都能用，它有专门的控制器进行数据操作和传输，数据传输速度更快。SATA 硬盘的特点是数据存储容量大、成本低，个人电脑中常用；服务器对成本要求不高，但对性能要求高，所以用 SCSI 硬盘更多。</p></li><li><p>若还记得，之前做虚拟机配置时，查看设置会发现，硬盘默认选择的是 SCSI 硬盘。所以，现在可以解释了，当时选择的就是这种类型。对于 Linux 系统，指定硬盘名称时，如果是 IDE 硬盘，传统的那种，名字就是“hd”，即“h”和“disk”，硬盘，第一块硬盘叫“hda”，若 IDE 接口的硬盘有第二块，就是“hdb”。对应的，如果是 SATA 或 SCSI 硬盘，命名时都以“sd”开头，同样，第一块硬盘叫“sda”，第二块叫“sdb”。所以，硬盘的命名是按照硬盘类型来的。</p></li><li><p>有同学可能见到“vda”“vdb”，这表示什么呢？主要是使用了虚拟化的模拟设备，即 Virtue 硬盘，其标志就变成了“vda”。这种情况一般不常见，正常情况下应是“sda”“sdb”。所以，“abc”后面的字母，最后一个字母表示第几块硬盘，后面若每块硬盘要分区，就在后面加“sda1”“sda2”。所以，现在知道“sda3”表示的是 SATA 或 SCSI 硬盘第一块硬盘下的第三个分区。若有“hdb2”，则表示 IDE 硬盘的第二块硬盘的第二个分区。现在对于硬盘的名称标识有了更深刻的理解。</p></li><li><p>对于“lsblk”命令，不光能看到基本信息，后面也可以跟选项。一般跟的选项是“-f”，可以显示文件系统的相关信息。因为现在看不到当前每个分区对应的文件系统信息，直接“lsblk -f”，显示的信息与上面不同，除了硬盘和分区的名称以及挂载点这两个主要信息，还有文件系统类型，比如选用的是 XFS，这是 64 位高性能的日志文件系统。当然，若选择的是 EXT4，即第四代扩展文件系统，这里显示的就是 EXT4。另外，第二个分区不同，其文件类型是“swap”，后面还有一串字符，这是所谓的 UUID，即系统为当前每个分区创建的唯一标识符，是 40 位的 ID，用这个 ID 可唯一指定当前分区。这就是“list block”（“lsblk”）命令的具体用法。</p></li></ul><h3 id="_4、磁盘挂载与卸载" tabindex="-1"><a class="header-anchor" href="#_4、磁盘挂载与卸载" aria-hidden="true">#</a> 4、磁盘挂载与卸载</h3><ul><li><p>了解“lsblk”命令后，对于当前所有块设备、存储设备的挂载情况，包括它们的文件系统和挂载点已十分清楚，对硬盘也有了清晰的认识。但会发现下面还有未设置挂载点的光盘，无法直接访问。</p></li><li><p>要访问光盘内容，需设置挂载点，这涉及“mount”命令（有“mount”就有“umount”，即卸载操作）。关于 Linux 中的挂载和卸载，之前讲硬盘分区时曾提及挂载点，现再复习一下。</p></li><li><p>之前提到有一块硬盘被划分成 3 个分区，分别为 1G、4G 和 45G。平常操作时，不会直接指定文件存放到哪个分区，而是基于文件系统，根目录为“/”，其下有各种子目录，如“bin”“root”“boot”等。使用时，直接将文件放入对应的目录即可。而目录与硬盘存储位置的对应关系通过挂载来表示，即目录这一虚拟目录结构与底层存储位置的映射。在硬盘分区时一次性配置好这种映射关系，后续无需再管。例如，第一个分区的挂载点为“boot”，则存放在“boot”目录下的文件都会存入 1G 的第一个分区磁盘空间；第二个分区为 4G 的“swap”分区，不会存放文件；45G 的第三个分区直接挂载到根目录，除“boot”目录中的内容，其余文件和文件夹都存放在这 45G 的空间里。</p></li><li><p>现在多了一个光盘，尽管光盘不是硬盘且无需分区，但仍需考虑光盘中的文件在文件系统中通过哪个目录查找。例如，有“mnt”目录，其为“mount”的缩写，用于挂载外部存储设备，可将光盘挂载到“mnt”目录下，之后在该目录就能访问光盘内容。</p></li><li><p>接下来进行实际操作。首先，要挂载光盘，虚拟机中虽无实际光盘，但有镜像文件。需在虚拟机设置中找到“CD/DVD”（光驱），使用 ISO 镜像文件，并将其状态改为已连接，让系统识别该设备，然后点击确定。确定后，桌面弹出光盘图标，与 Windows 类似，系统默认在桌面环境中将其挂载，点击可查看其中信息，如“image.iso”“ISO Linux”“package.iso”以及与“CentOS 7”相关的文件等。</p></li><li><p>这看似没问题，且可直接使用，但并非希望在桌面访问文件，而是在命令行中操作。查看其挂载点，用“lsblk”命令，发现默认挂载到“/run/media/root/CentOS 7 x86_64”目录。若要访问其中内容，可找到该目录，能看到“image.iso”等信息。</p></li><li><p>此过程为系统自动挂载，若要手动尝试“mount”命令，可先右键弹出光驱，此时挂载点消失，虽能识别光盘（4.4G 大小），但无访问目录，如执行“ls”命令，会提示无此文件或目录。此时需手动挂载，执行“mount”命令。</p></li><li><p>“mount”命令的使用较为简单，在文档中，其格式为“mount”，后面可跟选项。参数“-t”用于指定文件系统类型，对于光盘镜像，一般为“ISO9660”，也可不指定，系统通常能自动识别。“-o”可添加其他选项，如“ro”（只读方式挂载）或“rw”（可读可写方式挂载），对于光盘文件，一般选择只读方式。后面必须跟当前设备名称和目录名，目录名即挂载点。</p></li><li><p>找到光盘对应的设备名，之前看到为“sr0”或“cdrom”。不想将其挂载到“/run/media”下，可找个固定挂载点，如在“mount”目录下新建一个名为“cdrom”的文件夹，然后执行“mount -t ISO9660 /dev/cdrom /mount/cdrom”，回车后提示“mount: 在 /dev/sr0 上找不到媒体”，原因是之前做了弹出操作，此时查看“CD/DVD”，其状态非连接。</p></li><li><p>要进行测试，可关闭图形化界面，简单方式是注销当前用户，退到登录页面，重新连接光盘。再次查看，未挂载，执行“mount /mount/cdrom”，提示已挂载且为只读方式，查看能否读取光盘信息，无问题，“Images”“ISO Linux”“packages”等都在。此为手动挂载并读取内容的过程。</p></li><li><p>若要手动卸载，使用“umount”命令，后面可跟设备名或挂载点，因二者一一对应，给哪个都行。如“umount /dev/cdrom”，然后查看挂载信息，已卸载，若再访问之前目录，目录仍在但无内容。这就是“mount”和“umount”的挂载与卸载过程，在实际服务器操作中，通常需远程使用命令行进行挂载，而非依赖桌面环境的自动挂载。</p></li><li><p>可能会想到，若为光盘，每次插入临时挂载可接受，若想每次开机默认识别并挂载，如同系统分区一样，能否实现？答案是可以，但需进行开机启动配置，修改“/etc”目录下的“fstab”（“file system tab”）文件。</p></li><li><p>查看该文件，其中包含所有设备的挂载信息，如第一个分区“boot”，文件类型为“XFS”，第二个分区为“swap”，根目录为第三个分区。前面的“UUID”用于唯一标识分区，后面是挂载点、文件系统类型、“defaults”以及两个“0”。第一个“0”表示“dump”选项，安装系统时若未勾选“kdump”（用于系统备份，故障时回滚），则此处为“0”，表示不备份。第二个“0”表示文件系统检查的优先级。</p></li><li><p>另外，有“fsck”（“file system check”）命令用于检查和修复文件系统，系统默认开机执行检查，根据此处设置的优先级决定检查顺序，设为“1”优先级最高，设为“0”表示开机不检查。</p></li><li><p>若要将光盘挂载信息写入此文件实现开机自动挂载，格式为：可直接写设备名（如“/dev/cdrom”），后跟挂载点（如“/mnt/cdrom”）、文件类型（“ISO9660”）、“defaults”以及两个“0”。若不想记“UUID”，可通过“lsblk -f”查看，也可直接给设备名。完成后保存退出。此处无需此配置，直接回滚。若要设置开机启动挂载，可添加此配置行。</p></li><li><p>以上就是关于挂载和卸载的相关内容。</p></li></ul><h3 id="_5、硬盘分区、挂载与卸载" tabindex="-1"><a class="header-anchor" href="#_5、硬盘分区、挂载与卸载" aria-hidden="true">#</a> 5、硬盘分区、挂载与卸载</h3><ul><li><p>此前介绍了如何查看硬盘使用情况、块设备挂载情况，以及如何挂载和卸载新加入的设备（如光盘）。接下来关注的是新添加硬盘的处理方式，这不仅涉及简单的挂载，还包括分区、格式化及设置挂载点等操作。</p></li><li><p>硬盘分区有专门的命令“fdisk”用于分区和格式化操作。具体语法有两种：一种是“fdisk -l”，表示并非直接分区，而是查看当前磁盘的分区详情，其信息比“lsblk”看到的更详细；另一种是在实际挂载时，使用“fdisk”加上新添加硬盘设备的名称，如“/dev/sdb”（假设新硬盘为第二块，可能被命名为“sdb”）。需要注意，“fdisk”命令必须使用“root”用户权限才能操作。</p></li><li><p>先在控制台测试“fdisk -l”命令，能看到非常详细的信息。首先是磁盘名称，如“/dev/sda scsi”（第一块磁盘为“a”），总大小约 3.7G（计算方式与配置时的 50G 不同，但大小无误），还有具体字节数、扇区数、逻辑扇区大小、物理扇区大小、I/O 大小、标签类型、标识符等基本信息。接下来是每个分区对应的信息，如设备名称（“/dev/sda1”“/dev/sda2”“/dev/sda3”），“sda1”表示第一块硬盘的第一个分区，“boot”选项若有星号则为引导分区，还有分区的起始和结束位置。由于初始配置时从 2048 开始，会有一定空余，未完全利用磁盘空间进行分区。“blocks”指分区的容量大小，如约 1G、4G、45G（乘以 1024 计算）。“ID”为分区类型的标识，“system”为系统分区类型，“sda1”和“sda3”为标准分区，类型为“Linux”，第二个分区为交换分区，类型为“Linux swap”或“solaris”。此为“fdisk -l”查看的分区信息。</p></li><li><p>然而，更关心的是若新增一块硬盘，如何将其用于当前系统，进行分区并使用。先在虚拟机中进行基本配置：在设置里查看硬件设备，如内存、处理器、硬盘等，添加新硬盘，选择硬盘类型（如“scsi”），创建新虚拟磁盘，设定容量（如 20G）并命名，完成后，此时查看（如“fdisk -l”或“lsblk”），可能未出现新硬盘“sdb”，因添加硬盘后不像光盘可热插拔，需重启（执行“reboot”），重启后重新连接，再查看（如“lsblk”），会发现新增了“sdb”，其类型为“DISK”，但未分区和设置挂载点，接下来对其进行处理。</p></li><li><p>使用“fdisk -l”可看到新增磁盘“/dev/sdb”的信息。对其分区，使用“fdisk /dev/sdb”，会有中文提示，输入“m”获取帮助，可看到可用的命令操作，主要有：“n”添加新分区；“q”直接退出（不保存更改）；“w”保存更改并退出；“p”打印当前分区表信息。先输入“n”开始分区，选择分区类型（“p”为主分区，“Linux”系统一块磁盘最多划分 4 个主分区，若还需更多分区，可将一个主分区替换为扩展分区，扩展分区可再划分出若干逻辑分区，编号 1 - 4 为主分区或扩展分区，5 - 16 为逻辑分区，最多 16 个分区，设备名称如“/dev/sdb1”至“/dev/sdb16”）。此处仅划分一个主分区，输入“p”，默认编号为 1，起始扇区默认 2048，可直接回车，结束扇区默认最大，再输入“p”查看分区信息，如“/dev/sdb1”从 2048 开始至 41943039 结束，约 20G，然后输入“w”保存退出。此时同步磁盘，完成后可看到分区信息。</p></li><li><p>若使用“lsblk -f”查看，会发现无文件系统、UUID 和挂载点，需进行格式化。使用“mkfs”命令创建文件系统，如“mkfs -t xfs /dev/sdb1”，完成后查看信息，有了文件系统类型和 UUID。最后进行挂载，将其挂载到“/home/atguigu”目录下（“mount /dev/sdb1 /home/atguigu”），配置好挂载点后，可查看硬盘占用空间（“df -h”），已写入初始配置信息，占用 33 兆，共 20G，已用 1%。将一个 61 兆的“myroot.zip”文件复制到“/home/atguigu”目录下，再查看磁盘使用情况，“/dev/sdb1”分区空间占用变大，已用 94 兆，表明文件存于第二块新硬盘。此为使用“fdisk”命令进行硬盘分区、挂载及使用新硬盘保存数据的完整过程。</p></li><li><p>若不再使用新硬盘，可执行“umount”卸载，后面可跟设备名称“/dev/sdb1”或挂载点“/home/atguigu”。卸载后，使用“df -h”不再有“/dev/sdb”的信息，“lsblk”仍能识别但已卸载。此时访问“/home/atguigu”目录，原存于新硬盘的文件无法访问，因其已划归“/dev/sda3”分区保存和使用。</p></li><li><p>此即硬盘挂载和卸载的全过程。</p></li></ul><h2 id="八、进程管理类" tabindex="-1"><a class="header-anchor" href="#八、进程管理类" aria-hidden="true">#</a> 八、进程管理类：</h2><h3 id="_1、linux-进程管理命令" tabindex="-1"><a class="header-anchor" href="#_1、linux-进程管理命令" aria-hidden="true">#</a> 1、Linux 进程管理命令</h3><ul><li><p>接下来要介绍的是 Linux 中非常重要的一类命令，即进程管理类命令。关于进程的概念，之前在讲解系统服务管理时曾提及，指的是计算机中一个正在执行的程序或命令，英文为“process”。每个进程都是一个正在运行的实体，拥有自己的地址空间，并占用相应资源。整个操作系统会给其占用的内存一个专门的识别码，即进程的 ID（往往称为“PID”，即“当前的 process ID”）。在后续进程管理的讲解中，“PID”可唯一标识当前进程。</p></li><li><p>已知有些进程，比如在控制台输入“ls”查看当前目录下的所有内容，或者输入“cd”切换到某个目录，这类命令执行迅速，在内存中停留时间很短。而有些进程，例如之前提到的网络服务以及一些系统服务进程，在系统启动后会一直驻留内存，这类进程被称为服务。</p></li><li><p>对于 Linux 系统中的进程，总的来说可分为两大类，即前台显示的进程和后台平常看不到的进程，按其运行方式可作此划分。像前面提到的服务，尤其是系统服务，因其常驻内存，启动后持续存在，往往属于后台进程。具体执行这些系统服务的进程，通常被称为守护进程。在 Linux 中，守护进程的命名颇具特点，一般服务名称后会加一个“d”，表示“demon”，比如在 CentOS 7 中，主要使用“systemd”启动进程来管理系统服务，其所有服务位于“/usr/lib/systemd”目录下，其中还有一个“system”目录，包含众多具体的不同“service”，包括“target”（可视为一组服务的集合）。在此可以进行筛选，在上述语句后添加管道，筛选“grep .service”，会发现许多服务以“d”结尾并以“.service”为后缀，例如“sshd.service”，其中“sshd”就是 SSH 服务的守护进程，负责 SSH 服务，用于远程连接虚拟机或服务器。一般而言，在 Linux 中，守护进程和系统服务可视为完全对应的关系。</p></li><li><p>此前已介绍过 Linux 中系统服务的管理，在 CentOS 6 版本中，使用“service”加上服务名称以及“start”“stop”“restart”“status”来查看状态、启动、停止等操作。而在 CentOS 7 版本，则统一使用“systemctl”这一工具进行系统服务的管理。会发现，在 Linux 系统中，不仅有系统服务，还有用户调用的众多进程，甚至可将用户调用的进程视为服务，整体来看，既有系统级别的进程或服务，也有用户级别的进程或服务，进程的运行可在前台或后台。因此，需要一个统一的工具对所有进程进行管理、查看和监控，能够查看进程、了解其状态、进行启动和停止操作，这便是进程管理的工作，相较于之前的系统服务管理，更为通用和深入。</p></li><li><p>进程管理并非陌生概念，在 Windows 中，通过按下“Ctrl + Alt + Delete”可打开任务管理器，其中分为应用和后台进程，可认为前者是前台运行的用户进程，后者多为系统进程和系统服务，整体划分较为简单。在 Linux 中，也有类似的查看方式，不过并非窗口化查看，而是使用命令，其中最简单基本的命令是“ps”（并非“Photoshop”），指的是“process status”，用于查看当前进程状态。在当前命令行中直接输入“ps”，可看到当前的一些进程，如“bash”和“ps”。这很好理解，因为远程登录时使用的交互式 shell 控制台工具，当前打开的窗口即为一个 shell 界面、控制台，默认使用“bash”，所以有“bash”进程很正常，而“ps”则是刚输入的命令，每输入一个命令即运行一段程序，所以它也是一个进程。但一个系统中运行的进程远不止这两个，系统服务众多，直接调用“ps”输出的信息有限，仅显示当前用户调用的进程以及与当前终端控制台相关联的进程，系统服务多在后台运行，与终端控制台无关，且很多进程并非以当前用户身份执行，系统中有诸多为启动系统服务创建的伪用户。所以，一般使用“ps”时会添加一些选项参数。</p></li><li><p>下面介绍一些常用选项。“ps”的用法较为丰富，其选项参数总体有两大风格：一类前面不加横线，另一类前面加一个横线。熟悉的选项风格通常是加横线的，即所谓的标准 Unix 风格，Linux 继承自 Unix，支持这种标准风格。而不加横线直接写小写字母的选项属于 BSD 风格。在 Unix 的演变过程中，有一个衍生版本叫 BSD，至今，FreeBSD 仍是重要的开源版本，对后来的苹果系统也有影响。</p></li><li><p>首先是 BSD 风格的选项，小写“a”表示列出带有终端的所有用户的进程（默认“ps”只输出列出当前用户的进程），但不显示后台的系统服务。还有一个选项“x”，指的是列出当前用户的所有进程，包括前台有终端和后台无终端的服务。所以“a”和“x”在 BSD 风格中常合在一起使用，克服了“ps”默认的两个限制，即只显示当前用户且只显示有终端的进程，合起来可显示当前所有进程。另外还有选项“u”，指的是以对用户更友好的显示风格，展示更多信息，如资源占用情况等。这三个选项组合得到常见的“ps”用法“ps aux”，输入该命令可查看到非常多的进程，若翻页查看不便，可通过管道接“less”或“more”进行分屏显示，若要退出查看界面，在“less”中直接按“q”即可。这是查看当前所有进程的经典操作，也可通过管道接“grep”筛选感兴趣的进程查看相关信息。</p></li><li><p>除了 BSD 风格的“aux”语法，还有标准 Unix 风格的语法，即带横线的写法。常见参数选项如“-e”，直接列出当前的所有进程，相当于“a”和“x”功能的总和，包含所有用户以及前台后台、有无终端的所有进程。还有“-U”，在标准 Unix 风格中，与 BSD 风格的“u”不同，指的是列出与某个用户关联的所有进程，理论上后面要接用户名以筛选出对应用户的所有进程。另外常用的“-f”，在标准 Unix 风格中，由于“ps”本身显示信息少，BSD 风格中用“u”增加如系统资源占用等更多显示项，而标准 Unix 风格中用“-f”可显示更多信息，展示完整格式的进程列表。这种风格中，常见的使用方式如“ps -ef”，输出项目可能与之前有所不同，但主要项目类似，且多了一个“PPID”，“PID”指当前进程的 ID，“PPID”则是父进程的 ID，通过这种方式“ps -ef”，不仅能查看所有进程，还能查看进程之间的父子关系，在很多场景下非常有用，能直接梳理出进程关系。</p></li><li><p>在此需多说明一点，可能很多同学见过平时书写时不太严谨的情况，如“ps -ef”或“ps -aux”（看起来像“奥克斯”），这种方式可以说也对，但不好，在官方文档中不推荐使用。因为使用“-au”这两个参数后，后面其实要筛选一个叫做“x”的用户，如果系统中真有一个叫“x”的用户，最后显示的是该用户的所有进程。一般情况下，可能不会专门给用户取名为“x”，所以默认若找不到“x”用户，Linux 会自动理解为去掉横线后的“ps aux”。既然如此麻烦且可能有 bug，就不要使用，若使用 BSD 风格，就直接写“ps aux”，若使用 Unix 标准风格，就直接写“ps -ef”。</p></li></ul><h3 id="_2、ps-aux-和-ps-ef-的区别" tabindex="-1"><a class="header-anchor" href="#_2、ps-aux-和-ps-ef-的区别" aria-hidden="true">#</a> 2、PS AUX 和 PS -EF 的区别</h3><ul><li><p>大家可能最关心的问题是 PS AUX 和 PS -EF 到底有何区别，接下来详细阐述它们列出的数据和信息的不同之处。</p></li><li><p>先看 PS AUX ，依次查看每一列的含义。首先是“USER”，即当前用户名，用于标识哪个用户调用了当前进程。接着是“PID”，这是进程的 ID ，由系统分配编号。然后是“%CPU”，表示当前进程占用 CPU 的百分比。还有“%MEM”，代表当前进程占用内存空间的百分比。大部分进程对系统资源（CPU 和内存）的占用都较小，主要关注的通常是前面这几项。此外，还可能关心进程状态和调用该进程的命令，即“COMMAND”。</p></li><li><p>中间部分，“VSZ”指当前进程所占用的虚拟内存，“RSS”指当前进程所占用的实际物理内存，其中“V”代表“Virtual”，“R”代表“Real”。会发现有些进程的虚拟内存占用多于物理内存，这是因为 Linux 内核对内存管理有一套完整机制和算法。一般而言，内核会判断内存中的页面是否常用，对于长时间未使用的页面，不会等到物理内存占满才替换到虚拟内存中，而是直接将其置换到虚拟内存，把经常使用的页面保留在物理内存中，从而更高效地利用内存，空出更多物理内存处理其他事务。操作系统内核进行内存页面置换所使用的算法通常是 LRU（Least Recently Used），即最近最少使用规则，将最近一段时间内使用最少的页面置换到虚拟内存空间，因为长时间未使用的页面后续使用的概率较小。</p></li><li><p>“TTY”表示当前的终端，用于显示该命令或进程是通过哪个终端调用的。若显示为问号，则表示没有终端，属于后台服务。通过空格向下查看，会发现有“TTY1”“PTS0”等终端。“TTY”早期指的是“teletype writer”（电子打印机），即早期的交互式终端，类似打字机的控制设备，在 Linux 系统中，“TTY”有几种不同的显示情况。“TTY1 - 6”表示本地运行的控制台终端，对于 CentOS 7 ，“TTY1”是图形化终端（桌面环境），“TTY2 - 6”是本地的字符界面终端（大黑屏），通过在虚拟机上按“Ctrl + Alt + F1 - F6”可来回切换。“PTS0 - 255”代表虚拟终端或伪终端，例如在虚拟机中打开终端或远程登录打开终端时产生的就是虚拟终端。刚才打开终端后再查看，会发现除了原有的“TTY1”和“PTS0”，又多了“PTS1”，其运行的进程是“bash”，远程连接的控制端就是“PTS0”这样的虚拟控制终端。</p></li><li><p>后面一列是“STATE”，即进程状态，有各种不同的标识，如大写的“S”、小写的“s”、小于号等。常见的状态如“S”表示“sleep”（睡眠），进程已启动但未处理，在等待事件或信号，收到对应事件会唤醒并执行；“R”表示“running”（运行）；“T”表示暂停；“Z”表示僵尸状态，进程即将结束但有些信息未删除，只剩空壳，正常情况下副进程退出时会彻底清除，若未清除会占用系统资源，所以有时需关注并清除僵尸进程；小写的“s”表示包含子进程；小写的“l”表示进程是多线程运行。此外，“+”表示当前状态在前台显示，小于号表示当前进程优先级高，大写的“N”表示进程优先级低。</p></li><li><p>再往后是“START”，即当前进程的启动时间，还有“TIME”，指当前进程占用 CPU 的运算时间，大部分进程启动后进入睡眠状态，等待时间较长。最后是调用该进程执行的命令。这就是 PS AUX 所展示的全部信息，对进程的了解较为详尽。</p></li><li><p>需要介绍的是，PID 为 1 的进程，即一号进程，执行的命令是“/usr/lib/systemd/systemd”，在 CentOS 7 中，这是最初执行的初始用户进程，早期版本 CentOS 6 中是“init”进程。此外，2 号进程“kthreadd”是非常重要的守护进程，从名字可看出其负责所有内核线程的调度和管理，始终运行在内核空间，很多系统级别的服务都以系统线程形式运行，由其统一管理和启动。</p></li><li><p>再看 PS -EF ，整体上主体部分有些与 PS AUX 类似，如“START”（启动时间）、“TTY”（终端）、“TIME”（占用 CPU 计算时间）、“COMMAND”（调用当前进程的命令），还显示了“UID”（用户）和“PID”（进程 ID ），最大的区别是多了“PPID”，即父进程的 ID 。每个进程可能由另一个进程启动，存在父子关系，父进程是启动当前进程的那个进程。1 号进程“systemd”的父进程是 0 号进程，0 号进程较为特殊，是“idle”进程，运行在系统内核态。0 号进程启动了“systemd”和“kthreadd”，从而启动所有用户进程和系统线程的管理。往后看，大部分系统级别的进程的父进程都是 2 号进程“kthreadd”，用户进程的父进程则是 1 号进程。由此可以清晰看到所有进程启动时的父子关系，加深对 Linux 系统运行架构的理解。对于“kthreadd”，其主要管理系统内核的线程，线程可视为轻量级的进程，一个进程可包含多个线程，如“watch dog”（看门狗）进程用于监测系统运行状态，出现死机等情况时进行重启。</p></li><li><p>对于 PS AUX 和 PS -EF 这两个命令，可得出如下结论：若想查看资源占用率（CPU 和内存），使用 PS AUX ；若想查看父子进程关系，则使用 PS -EF ，它们都能查到当前的所有进程。</p></li></ul><h3 id="_3、sshd-进程的查看与分析" tabindex="-1"><a class="header-anchor" href="#_3、sshd-进程的查看与分析" aria-hidden="true">#</a> 3、SSHD 进程的查看与分析</h3><ul><li><p>此前介绍了查看进程的基本命令“ps”，常见用法为“ps aux”和“ps -ef”，这两种用法均可查看所有进程。有时若想查看特定信息，可在后面加“|”（管道）进行筛选。接下来通过一个实际案例进行说明，查看与远程登录相关的“sshd”进程。</p></li><li><p>首先，查看当前有哪些“sshd”对应的进程。可先使用“ps -ef | grep sshd”，能搜索出三条结果。</p></li><li><p>第一条为“user s b sshd”，这显然是直接启动“sshd”服务的命令，该进程的“PID”为 1130，父进程为一号进程“systemd”，即系统启动时“systemd”直接启动了“sshd”服务。若想查看其状态，可使用“systemctl status sshd”，此为系统服务，状态为正在运行且开机启动。</p></li><li><p>其次，除上述进程外，还有“sshd root”使用“PTS0”进行远程登录，这指的是当前以“root”身份通过虚拟终端登录到远程服务器时使用的“sshd”服务。此进程的父进程为“sshd”守护进程创建的子进程，当前进程编号为 3195，父进程“PPID”为 1130。</p></li><li><p>另外，还有“grep color = auto sshd”，此进程与前面的进程无关，是执行“ps -ef | grep sshd”这条命令筛选“sshd”时产生的进程，其终端为“PTS1”，并非在后台。</p></li><li><p>真正与当前远程登录操作相关的是前面两条。若再创建一个以“root”身份登录的远程链接，执行相同命令会新增一条“sshd”进程，如“sshd root PTS2”，其父进程同样为 1130，只是子进程“PID”不同。</p></li><li><p>还可进一步测试，当前登录用户均为“root”，若以其他用户身份，如“atguigu”进行远程登录，筛选后会发现新增了两个“sshd”进程。下面较简单的进程为“atguigu @ PTS3”，表示又打开了一个远程登录的虚拟终端。上面的进程为“atguigu priv”，这是为了权限分离。仔细观察会发现两个进程调用的用户不同，下面的进程是以“atguigu”用户身份登录，上面以“root”身份登录，这样在执行操作时进行权限分离，使用不同进程，在安全性和性能上能得到更好保证。</p></li><li><p>通过此例，能清晰了解所有进程的情况以及它们与服务的关系。</p></li></ul><h3 id="_4、kill-命令的使用" tabindex="-1"><a class="header-anchor" href="#_4、kill-命令的使用" aria-hidden="true">#</a> 4、kill 命令的使用</h3><ul><li><p>了解了 ps 命令后，对进程的查看已基本掌握。此时可将屏幕清掉。</p></li><li><p>自然会想到，除查看进程外，可能还需对进程进行其他操作。比如有时执行进程到一半，发现某个进程运行缓慢、卡顿，耗费过多系统资源，想将其终止。这就需要用到终止进程的命令，即著名的 kill 命令。若不懂用 kill 终止进程，进程管理就无法发挥真正作用，毕竟只能查看而无法管理。</p></li><li><p>kill 的使用较为简单，直接在 kill 后加上当前进程号（PID），就能通过 PID 直接终止对应的进程。这是终止单个进程的方法。还有一种更强大的方式，即 killall 。killall 后面跟的是进程的名称，比如输入“killall sshd”，则所有与 sshd 相关的进程都会被终止，此操作需谨慎使用。</p></li><li><p>接下来看具体例子。kill 非常有用，比如之前看到的 sshd 进程，后台启动了一个守护进程，远程以 root 身份在 PTS0 虚拟终端登录一个，在 PTS2 虚拟终端又登录一个，还有 atguigu 在 PTS3 登录（因权限分离，此情况有两个进程）。假如发现 atguigu 是未授权或非法用户，想将其踢掉，是完全可行的。先查看所有登录信息，然后将 atguigu 对应的进程用 kill 终止。这里可能会有疑问，即两个 ID 到底终止哪个。实际上，直接终止 3539（atguigu 用户登录的控制台对应的远程登录进程），就能将其踢出，同时其对应的做权限分离的 root 用户进程也会被终止。若终止上面那个进程（父进程）也行，因为它是子进程的父进程。比如 kill 3535 ，随后就能看到该用户被踢出，显示“connection closed by foreign host”。再查看，这两个进程就都不存在了。</p></li><li><p>同样，以 root 身份登录，若想将 PTS2 终端登录的用户踢掉，也可直接尝试 kill 对应的 PID（3481），能看到终端直接变黑，表明已将其踢出。使用 kill 踢掉不需要的用户或进程，非常实用。</p></li><li><p>不仅能逐个踢掉用户，还能自己踢自己。即直接 kill 自己当前登录的进程，然后就会自动退出，而不影响其他用户的正常使用和访问。</p></li><li><p>但要注意，若将后台守护进程 sshd（PID 为 1130）终止，会发现已登录的两个进程仍存在，此时操作和查看都没问题。但再想登录新用户（无论是 root 还是 atguigu ），会发现无法连接，因为后台的 sshd 服务已关闭。而且原本 sshd 是登录进程的父进程，父进程被终止后，子进程的父进程会变为 1 ，子进程仍能存活。所以在远程连接服务器时，操作后台守护进程要特别小心。若不小心终止了守护进程，想再次进行远程连接，只要当前控制台还活着，直接将服务重新启动（先查看状态“systemctl status sshd”，发现服务已关闭，再执行“systemctl start sshd”）即可。重新启动后，就能再次登录 atguigu 等用户。再查看 sshd 进程，会发现因之前已有两个终端，重新启动后它们之间无父子关系，但新启动的远程连接终端的父进程应为新启动的 3811 号守护进程。</p></li><li><p>关于 kill 的基本用法就介绍到这。可能有人会好奇进程的父子关系，比如最后 grep 时，sshd 的父进程（PPID）为 3746 ，这是什么进程？若感兴趣，可直接 grep 3746 。会发现 3746 是当前打开的 bash 界面，即控制终端或控制台页面，因为 shell 的实现是 bash ，所以它是一个进程，其父进程 3742 是当前的 sshd 远程登录进程。这样，从 systemd 一号进程启动开始，先后启动了 sshd 后台守护进程、PTS0 远程登录进程，该登录进程又启动了当前的 bash 进程，父子调用关系就清晰了。若对 bash 感兴趣，可直接 grep bash ，能看到每个虚拟终端都有对应的 bash 进程，而实际终端（若未启动文本界面的控制台）则不是 bash 。</p></li><li><p>可尝试 kill 某个 bash 进程，比如想终止 PTS0 控制台对应的 bash 进程，直接回车发现未被终止。这是因为与远程连接不同，bash 是当前正在运行的控制台界面，直接操作无法终止，需强行终止。强行终止的命令是加“-9”参数，表示强迫进程立刻停止。“-9”是系统的信号值，可通过“kill -l”查看，其代表“SIGKILL”（kill 信号）。所以输入“kill -9”就是给当前进程传递强制终止的消息。比如要终止 PID 为 3273 的进程，再查看 PTS1 ，就会发现已被终止。若要终止 PTS3 ，同样操作即可，终端会断开连接（红点表示断开）。当然也能自己终止自己（PID 为 3746 ），同样需加“-9”参数，然后就会像 x 直接退出一样。</p></li><li><p>除了 kill ，还有 killall 。比如想一次性终止所有名为 sshd 的进程，输入“killall sshd”即可，但此操作要非常小心，因为会连守护进程一起关掉，导致重连完全无法进行。此时只能到机房的物理机上打开终端，输入“systemctl start sshd”启动服务，然后才能重新连接。在实际工作中一定要谨慎操作。</p></li><li><p>以上就是关于 kill 的所有用法。</p></li></ul><h3 id="_5、pstree-命令的使用" tabindex="-1"><a class="header-anchor" href="#_5、pstree-命令的使用" aria-hidden="true">#</a> 5、pstree 命令的使用</h3><ul><li><p>前面介绍了如何使用 ps 命令查看当前进程状态，以及如何使用 kill 命令终止进程，其中提到 killall 通杀功能强大，需谨慎使用，一般推荐单独使用 kill 并指定进程号（PID）来终止进程。</p></li><li><p>在终止进程的过程中，可能会涉及复杂的进程间父子关系。如在一个 bash 中执行命令，其父进程是 bash ，bash 的父进程可能是远程登录进程，而远程登录进程的父进程又是 SSHD 对应的系统服务守护进程。若每次都通过“ps -ef”查找 PID 来查看父子关系，过程较为繁琐。</p></li><li><p>有没有更直观的方式能一次性看清所有父子关系呢？有的，那就是 pstree 命令。直接输入“pstree”即可，若系统未安装 pstree ，可使用 CentOS 里的包管理工具，通过“yum install pstree”进行安装。这里已安装，可直接输入“pstree”，为方便查看，可加上“less”进行分页显示。</p></li><li><p>可以看到，最顶层是“systemd”，即当前的用户初始进程，之后有“network manager”等由“systemd”启动的系统服务。早期版本的初始进程是“init”。这里是“systemd”，然后翻页查找关心的“ssh”，能看到“ssh”相关的父子关系：“systemd”一号进程启动了后台的“sshd”守护进程，进行远程登录时又产生一个“sshd”进程，基于此远程登录进程又打开了“bash”及控制台界面，在该界面中执行的“ps tree”和“less”等命令，它们是基于“bash”产生的子进程。通过这样的树形结构，父子关系清晰明了。若要退出，按“q”即可。</p></li><li><p>除了基本使用，pstree 还有一些优化选项。比如加“-p”参数可显示每个进程的 PID ，因为在默认显示中只有进程名，若要终止某个进程，PID 更方便。输入“pstree -p | less”，所有进程的 PID 编号会以括号形式跟在进程名后，由于增加了 PID 信息，篇幅会更大，如“sshd”的 PID 是 4107 ，远程登录服务的 PID 是 4114 。若加“-u”参数，可显示进程的所属用户。默认情况下，若进程所属用户与父进程相同，则不显示，只有用户不同时，才会在后面以括号形式显示。如“colord”的用户是“colord”，“dbus demon”的用户是“dbus”，“DNSMASQ”的用户是“nobody”，若子进程用户变为“root”，会进行专门声明。</p></li><li><p>这就是 pstree 的具体用法，可通过它清晰地看到竖状的父子进程关系。</p></li></ul><h3 id="_6、top-命令" tabindex="-1"><a class="header-anchor" href="#_6、top-命令" aria-hidden="true">#</a> 6、top 命令</h3><ul><li><p>接下来要介绍的是 Linux 中另一个重要的命令——top ，它用于监控和查看当前系统进程状态。</p></li><li><p>top 命令十分重要且有趣。它与 ps 命令相似，均用于查看系统进程，但二者存在区别。ps 更像是对当前活动进程信息的快照，将其瞬间拍下，再通过 more 或 less 进行分页展示，查看其中内容。而 top 则是实时监控展示，会打开一个交互式界面，实时刷新当前进程信息。这在实际监控和运维中极为重要。</p></li><li><p>其使用方法非常简单，直接输入“top”即可打开。页面内容不断变化，每隔几秒就会跳变一次。该页面主体分为两大部分，上面部分展示的是当前系统运行状态及 CPU、内存占用等系统级信息，下面部分则是以表格形式列出的所有正在运行的进程。</p></li><li><p>先看上面的系统信息。首先是“top”，这是程序名称，后面是当前时间，如 10:26 。接着是“up”，后面跟的“2 小时 04 分”表示系统启动运行至今的持续时间，可能还会有天数，这里没有，只有小时和分钟。然后是当前登录使用机器的用户数，有三个用户。这里解释一下，当前远程登录是一个用户，之前在图形页面打开的虚拟登录窗口中的 root 用户是一个，图形化桌面环境登录时也是一个 root 用户，所以是三个。可以将其关闭一个，再看，实时刷新后变成两个用户，变化很明显。而且，从时间上能看到，约 3 秒钟刷新一次。</p></li><li><p>接下来是当前的平均负载，有三个数值，分别代表过去 1 分钟、5 分钟和 15 分钟内系统的平均负载。通常，平均负载小于 0.7 时，负载较小；大于 1 时，超出系统负荷。</p></li><li><p>后面是“task”，即当前正在执行的任务，也可视为进程。正在运行的程序有 249 个，其中 1 个处于“running”状态，后面是进程状态。之前介绍“state”时提到过具体的状态名称，这里 1 个是“running”状态（即“r”状态），248 个是“sleeping”状态（即“s”状态），0 个“stopped”（即“t”状态），还有 0 个“zombie”（即“z”状态），说明当前没有僵尸进程，系统运行状态较为健康。</p></li><li><p>下面是 CPU 占用情况，指标较多。“US”指“user”，即用户进程占用 CPU 的时间比，但这里的用户进程是默认情况下未专门更改优先级的。“SY”指“system”，即系统进程（内核进程）占用 CPU 时间的百分比。“NI”是“nice”的前两个字母，在 Linux 系统中有 nice 命令，它可给运行的进程指定优先级。“nice”有友好之意，进程越友好，优先级越低，会为其他进程让路；反之，优先级越高。这里的“NI”指通过 nice 调整优先级后的用户进程在 CPU 运行时间中的占比。“id”指“idle”，即空闲，当前空闲时间近乎 100% 。“wa”指“wait”，显示当前等待 I/O 操作的时间占比。“hi”指“Hardware Interrupt”，即硬件中断服务请求时间的占比；“si”指“Software Interrupt”，即软件中断服务请求时间的占比。“st”指“Stolen”，表示被虚拟化设备占用的时间占比。当前未创建虚拟机，此值为 0 。</p></li><li><p>下面是内存相关，包括内存占用情况和交换内存（虚拟内存）占用情况，单位是 KB ，能看到总共多少、空闲多少、已占用多少以及缓存多少，整体较为简单。</p></li><li><p>这是系统运行状态的信息，下面是具体的进程运行状态。首先是“PID”，即进程编号；“user”，表示当前调用进程的用户；“PR”，指系统任务调度的优先级；“NI”，是进程调度运行时用户指定的 nice 值（优先级），二者有区别。接着是“Virt”，即“Virtual memory size”，虚拟内存占用大小；“RES”，指“resident memory size”，实际内存（物理内存）占用大小；“SHR”，指“share memory size”，即共享内存大小。后面的“s”表示进程状态，大部分是“s”（“sleeping”）状态，如这里运行的“top”程序进程是“r”（“running”）状态。后面还有“%CPU”，即当前进程 CPU 计算时间的占比；“%MEM”，即内存占比；“TIME+”，指当前运行占用 CPU 的总时间，“+”表示精度精确到 0.01 秒；最后是“command”，即生成当前进程的命令。整体与 ps 显示的内容类似，进程状态一目了然。</p></li><li><p>在此界面还能进行一些基本操作。默认按 CPU 占比排序，想按内存大小排序可按“Shift + m”（大写 M ），若想按 CPU 占比排序则按“Shift + p”（大写 P ），按进程号大小排序可按“Shift + n”（大写 N ），默认从小到大，按下后从大到小。还可用上下键或“Page Down”“Page Up”查看更多信息，退出直接按“q”。</p></li><li><p>除基本信息外，top 还可指定选项参数。比如“-d”，后跟秒数，用于设置刷新间隔，默认 3 秒，可根据需要调大或调小。“-i”使 top 命令不显示闲置或将死的进程，但并非所有“s”状态进程都不显示，标准是从上一次显示到本次显示期间一直未占用 CPU 的进程为闲置，不显示，状态不变则不显示，所以显示的进程未必都是“r”状态。还可通过“-p”指定进程 PID 监控某个进程状态。</p></li><li><p>可尝试“top -d 1”，会发现跳变很快，1 秒钟刷新一次。按“q”退出。“top -i”后进程数减少，有时“r”进程在，有时“s”进程在。比如“4910”是 top 进程，若只想看它，可先退出，输入“top -p 4910”，但由于已退出 top 进程，可能没有该进程了。可先“top -i”查看活跃进程，比如“2655”，退出后输入“top -p 2655”，可监视该进程状态。</p></li><li><p>一般还是指定刷新时间查看所有进程。还可按“u”（小写）筛选监控固定用户，比如登录“atguigu”用户，就能看到其相关信息，包括 SSHD 远程登录进程和当前的控制台界面。</p></li><li><p>若要终止进程，也可在 top 中操作，类似 ps 和 kill ，按“k”，输入 PID ，确认发送的信号，可输入信号名称或数字，如 9 ，即可终止进程，比如终止“atguigu”用户的相关进程。</p></li><li><p>总之，top 命令使用方便灵活。</p></li></ul><h3 id="_7、网络状态查看命令-netstat" tabindex="-1"><a class="header-anchor" href="#_7、网络状态查看命令-netstat" aria-hidden="true">#</a> 7、网络状态查看命令：netstat</h3><ul><li><p>在进程管理这一节的最后，来介绍一个查看网络状态的命令。</p></li><li><p>此前介绍网络连接时，大家已知与网络相关的常见命令主要有两个，一是在 Linux 中的“ifconfig”，用于查看当前所有的网络连接和 IP 信息；另一个是“ping”，可直接测试，比如当前局域网中的主机是 111.1 ，能ping 通则表明当前网络连接正常。这是最简单、直接测试网络或查看网络信息的两个命令，但它们能做的事少，能看到的信息也有限。</p></li><li><p>现在要介绍的是另一个更强大、更常用，能显示网络状态和端口占用信息的命令——“netstat”。其名称即“net status”，意为显示网络状态，能显示的网络信息非常多，比如当前的网络连接状态、所有的路由表信息，还能监控每个端口的占用状态以及涉及的进程信息，正因如此，将其置于进程管理类别中，因为它与进程相关。实际使用中，往往会结合起来，比如先通过“netstat”查看哪些端口被占用及是哪个进程占用，然后用“ps”查看进程状态，可能还会用“kill”终止进程。</p></li><li><p>接下来看“netstat”的具体用法。一般情况下，“netstat”后面要加一些基本选项。首先常用的选项有“-a”，由于“netstat”列出的信息众多，“-a”表示显示所有正在监听或未监听的套接字（SOCKET）。熟悉计算机网络的同学对套接字应不陌生，进程间进行网络通信时，在机器上的接口可视为套接字。</p></li><li><p>以两台机器通信为例，比如考虑当前一台是自己的 PC 主机，另一台是远程服务器（此处为 VM ），若要通过 SSH 服务远程连接到虚拟机，就会有一个远程连接进程与服务器端的“sshd”进程进行通信。此时，两者进行网络通信，需在本机开一个口，数据从此口出，经网络传输，远程服务器端也要开一个口，数据从此口进，传递给相应服务，如此，两进程完成通信，实现数据传输。这里开的口，即所谓的套接字。</p></li><li><p>通常，套接字的表示形式为一个 IP 或主机名后跟一个冒号，再指定当前的端口号，即哪个房子的哪个门，在计算机领域，房子即机器，所以一般给定主机名或 IP （如当前的 IP 是 111.100 ），同时还需指定门的名称，即机器上的端口号。对于一台机器，一个 IP 可有 65535 个端口（端口号从 0 到 65535 ），部分端口已被固定服务占用，如 SSH 占用 22 端口，浏览器网页服务占用 80 端口，自行安装的 MySQL 服务默认占用 3306 端口。所以在 0 到 65535 中选一个数指定当前门的号码即可。这便是关于端口及套接字的基本概念，借此复习计算机网络知识。</p></li><li><p>“-a”参数能显示所有正在监听和未监听的套接字，即 IP 加上端口号的形式。监听指的是其当前状态为“listen”，即进程间通信要建立连接时，首先需进行监听，看此门是否有数据或有人要来。若已建立连接（如 TCP 协议的三次握手成功），其状态会由监听变为“established”（已建立连接）。这是关于网络状态的基本概念，所以“-a”参数能显示所有套接字。</p></li><li><p>此外，常用选项还有“-n”，意为拒绝所有别名，即主机名等形式，不解析主机名，直接显示为数字形式的地址，即全部用 IP （如 192.168. ）形式；“-l”，是“listen”的首字母，只显示当前正在监听的服务或套接字；“-p”，指将当前套接字端口占用所对应的进程显示出来，列出其 PID 和名称，从而将进程管理与网络通信状态相连接。一般使用“netstat”时，会将这几个选项结合，如“netstat -anp”，列出所有监听和未监听的套接字信息及调用的进程，还可筛选进程号查看其占用端口及状态，或直接 grep 端口号查看端口占用情况。</p></li><li><p>接下来通过一个具体例子进一步了解。直接输入“netstat -anp”，信息较多，可加管道“| less”分页显示。先解析表头，“proto”指协议，使用套接字进行网络传输时会涉及网络协议，常见的有 TCP 、UDP ，TCP6 和 UDP6 则是 IPv6 下的相关协议，此处暂不考虑。“Receive Q”指连接到当前套接字的用户程序未拷贝的字节数，即已接收但未拷贝出来的字节数量。“Send Q”指已发送但远程主机未确认收到的字节数，即可能被丢弃需重传的数据。后面的“Local Address”和“Foreign Address”分别指本地地址和远程地址。</p></li><li><p>这里需解释一下显示的地址形式，即套接字形式，前面是 IP ，后面是冒号加端口号。出现的不同 IP 中，0.0.0.0 在网络中表示本机本地的所有地址，包括局域网地址（如 192.168.111.100 ）和本地创建虚拟网络的地址等。监听 0.0.0.0 相当于监听本地所有地址的对应端口。127.0.0.1 是经典的本地回环地址，一般用于本地监听和测试，代表本地主机，等同于“localhost”，查看 host 文件时通常能看到其定义。IPv6 相关的写法此处略过。能看到的本机 IP 即上述几种，远程地址有 0.0.0.0 ，连接到的远程地址有时是本机（如使用 XSHARE 远程连接时，物理机是本地，虚拟机或服务器是远程；查看服务器状态时，虚拟机或服务器是本地，物理机是远程，此关系需理清）。</p></li><li><p>以一条有特色的信息为例，其状态为“established”（已建立连接），后面是 PID 和进程名，显然是“sshd”远程连接进程。其使用 TCP 协议进行远程连接，从本机的 60100 端口连接到虚拟机或服务器的 22 端口（XShell 本机出去的端口号随机分配，数字较大以避免冲突，虚拟机或服务器的服务端口固定，如 SSHD 的 22 端口）。为更明确了解网络状态，可再登录一个“atguigu”用户，由于“netstat”是静态快照，需退出后重新查看，此时会多一个“atguigu”用户远程登录建立的连接，从本地物理机的 60222 端口连接到远程服务器的 22 端口。</p></li><li><p>可如此画图：本机为主机，远程服务器为虚拟机（VM ），VM 启动“sshd”提供远程登录服务，其守护进程的端口号为 22 ，要进行远程登录需指定连接到对应服务器（ 192.168.111.100 ）的 22 端口。可能有不同用户同时连接，如“root”用户创建远程连接进程（ PID 为 4658 ），“atguigu”用户创建远程连接进程（ PID 为 5288 ），开不同的门（ 60100 和 60222 ），都可连接到远程服务器的“sshd”服务开放的 22 端口进行远程操作和数据传输。</p></li><li><p>可能有人会问，22 端口是否会拥堵。对于同一服务启动后的所有远程连接信息走同一个端口是没问题的，多用户同时连接时 SSH 能处理。但若服务器上的 22 端口已被占用，再启动“sshd”可能无法启动，因为其要求必须指定此端口。通过此例，可进一步看清进程与网络状态的关系，更清楚地了解 Linux 中的进程管理方法。</p></li><li><p>以上便是关于进程管理类命令的讲解。</p></li></ul><h2 id="九、系统定时任务" tabindex="-1"><a class="header-anchor" href="#九、系统定时任务" aria-hidden="true">#</a> 九、系统定时任务：</h2><h3 id="_1、定时任务命令-crontab" tabindex="-1"><a class="header-anchor" href="#_1、定时任务命令-crontab" aria-hidden="true">#</a> 1、定时任务命令：Crontab</h3><ul><li><p>在本章的最后，介绍一个有趣的命令——Crontab，它主要用于设置系统定时任务。顾名思义，就是为系统设定在特定时间执行特定任务，如同设置闹钟，可指定每天的具体时间点执行某项操作或命令。如此，能完成诸多与系统管理和维护相关的任务。</p></li><li><p>例如，每天零点定时进行清理、系统自检或重要数据的存盘备份。又如，在一个小组中，同事们使用 Git 作为代码管理工具，每天可能需对所有同事提交的代码进行打包，生成软件版本，再于固定时间执行标准测试流程，测试完成后打包发布为稳定版本。这些均可通过设置定时任务实现自动化，无需手动触发，固定时间就能自动完成代码打包等操作。在实际应用中，其应用场景十分广泛。</p></li><li><p>那么，如何使用 Crontab 服务呢？其后台有一个守护进程，名为“crond”。首先，需确认“crond”是否开启。在控制台，输入“systemctl status crond”，查看其状态。若显示为开启，且系统启动时默认开启，便无需其他操作。若为关闭状态，直接执行“start”或“restart”即可。</p></li><li><p>有了“crond”守护进程后，便可使用“crontab”命令。“crontab”命令常用选项有三个，分别是“-e”（用于编辑当前定时任务）、“-l”（查询当前所有定时任务）、“-r”（删除当前用户所有定时任务）。</p></li><li><p>先使用“crontab -l”列举当前定时任务，发现 root 用户未设置定时任务，接着使用“crontab -e”进行编辑。进入后，界面类似 Vim，本质上如同操作一个文本配置文件。</p></li><li><p>对于其编辑内容，基本格式为“***** 要执行的任务”，前面的五颗星含义如下：第一颗星表示一小时中的第几分钟，范围 0 - 59；第二颗星表示一天中的第几小时，范围 0 - 23；第三颗星表示一个月中的第几天；第四颗星表示一年中的第几个月；第五颗星表示一周中的星期几。需注意，星期几的取值为 0 - 7，其中 0 和 7 均代表星期日。</p></li><li><p>配置时，在相应位置给定数字即可。例如“45 22 ***** 命令”，表示每天晚上 22 点 45 分执行后面的命令，因为后面是星号，代表任意时间均可。若为逗号分隔的数字，如“8,12,16 * * * 命令”，表示每天的 8 点、12 点、16 点整执行命令。若为横杠表示连续时间范围，如“0 5 * * 1 - 6”，表示星期一到星期六的凌晨 5 点 0 分执行命令。还有“* /10 * * * * 命令”，表示每隔 10 分钟执行一次命令。</p></li><li><p>以下是具体示例：前面提到的每天晚上 10 点 45 分执行命令；“0 17 * * 1”表示每周一 17 点整执行命令；第三位为 1 和 15 ，表示每月 1 号和 15 号凌晨 5 点执行命令；“40 4 * * 1 - 5”表示周一到周五凌晨 4 点 40 分执行命令；“0 4 * * * /10 命令”表示每天凌晨 4 点开始，每隔 10 分钟执行一次命令。</p></li><li><p>另外，还有“0 0 1,15 * MON 命令”，表示每月 1 号和 15 号以及每个月的周一 0 点执行命令。需注意，星期几和具体日期可能会冲突，最好不同时出现，否则管理易混乱。</p></li><li><p>接下来看一个具体案例，比如每隔一分钟在某个文件中追加一句话，如“hello world”，追加到“hello”文件中。其配置为“* * * * * echo &#39;hello world&#39; &gt;&gt; /root/hello”。保存后，稍等片刻，最初可能未生成“hello”文件，直到整点才会写入。查看文件内容“cat hello”，能看到写入的“hello world”。若想查看文件变化，可“tail -f hello”，耐心等待一分钟，便能看到追加的内容。</p></li><li><p>若查看当前定时任务列表，会看到新增的此任务。若要清除，使用“crontab -r”，它会删除当前 root 用户的所有定时任务，此后“hello”文件不再增长。</p></li><li><p>这便是定时任务的使用方法，在实际工作中应用广泛，大家可尝试测试。</p></li></ul>`,97);function f(k,_){const a=o("router-link");return t(),r("div",null,[c,h,d(" more "),m,l("nav",g,[l("ul",null,[l("li",null,[s(a,{to:"#概述框架"},{default:e(()=>[i("概述框架")]),_:1})]),l("li",null,[s(a,{to:"#g-第7章常用基本命令-1"},{default:e(()=>[i("G-第7章常用基本命令")]),_:1})]),l("li",null,[s(a,{to:"#一、linux-系统实操篇-常用基本命令学习"},{default:e(()=>[i("一、Linux 系统实操篇：常用基本命令学习")]),_:1})]),l("li",null,[s(a,{to:"#二、文件目录类"},{default:e(()=>[i("二、文件目录类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、linux-文件目录类命令"},{default:e(()=>[i("1、Linux 文件目录类命令")]),_:1})]),l("li",null,[s(a,{to:"#_2、linux-命令-ls"},{default:e(()=>[i("2、Linux 命令：LS")]),_:1})]),l("li",null,[s(a,{to:"#_3、文件夹的操作"},{default:e(()=>[i("3、文件夹的操作")]),_:1})]),l("li",null,[s(a,{to:"#_4、linux-文件操作-创建文件"},{default:e(()=>[i("4、Linux 文件操作：创建文件")]),_:1})]),l("li",null,[s(a,{to:"#_5、linux-命令-复制文件-cp"},{default:e(()=>[i("5、Linux 命令：复制文件（CP）")]),_:1})]),l("li",null,[s(a,{to:"#_6、linux-文件操作-删除与移动"},{default:e(()=>[i("6、Linux 文件操作：删除与移动")]),_:1})]),l("li",null,[s(a,{to:"#_7、linux-文件内容查看指令"},{default:e(()=>[i("7、Linux 文件内容查看指令")]),_:1})]),l("li",null,[s(a,{to:"#_8、linux-命令-echo-与输出重定向"},{default:e(()=>[i("8、Linux 命令：Echo 与输出重定向")]),_:1})]),l("li",null,[s(a,{to:"#_9、linux-查看文件内容的特殊方法-head-和-tail"},{default:e(()=>[i("9、Linux 查看文件内容的特殊方法：head 和 tail")]),_:1})]),l("li",null,[s(a,{to:"#_10、linux-命令-ln-与软链接、硬链接"},{default:e(()=>[i("10、Linux 命令：ln 与软链接、硬链接")]),_:1})]),l("li",null,[s(a,{to:"#_11、linux-命令-history"},{default:e(()=>[i("11、Linux 命令：history")]),_:1})])])]),l("li",null,[s(a,{to:"#三、时间日期类"},{default:e(()=>[i("三、时间日期类：")]),_:1})]),l("li",null,[s(a,{to:"#四、用户权限类"},{default:e(()=>[i("四、用户权限类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、linux-用户管理命令"},{default:e(()=>[i("1、Linux 用户管理命令")]),_:1})]),l("li",null,[s(a,{to:"#_2、linux-用户管理进阶命令"},{default:e(()=>[i("2、Linux 用户管理进阶命令")]),_:1})]),l("li",null,[s(a,{to:"#_3、用户组管理命令"},{default:e(()=>[i("3、用户组管理命令")]),_:1})]),l("li",null,[s(a,{to:"#_4、文件权限管理"},{default:e(()=>[i("4、文件权限管理")]),_:1})]),l("li",null,[s(a,{to:"#_5、文件权限更改"},{default:e(()=>[i("5、文件权限更改")]),_:1})]),l("li",null,[s(a,{to:"#_6、linux-用户管理与文件权限综合应用练习"},{default:e(()=>[i("6、Linux 用户管理与文件权限综合应用练习")]),_:1})])])]),l("li",null,[s(a,{to:"#五、搜索查找类"},{default:e(()=>[i("五、搜索查找类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、搜索查找类命令"},{default:e(()=>[i("1、搜索查找类命令")]),_:1})]),l("li",null,[s(a,{to:"#_2、搜索查找命令-grep-及相关操作"},{default:e(()=>[i("2、搜索查找命令：grep 及相关操作")]),_:1})])])]),l("li",null,[s(a,{to:"#六、压缩解压类"},{default:e(()=>[i("六、压缩解压类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、linux-中的压缩与解压命令"},{default:e(()=>[i("1、Linux 中的压缩与解压命令")]),_:1})])])]),l("li",null,[s(a,{to:"#七、磁盘管理类"},{default:e(()=>[i("七、磁盘管理类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、文件目录相关操作及磁盘空间查看"},{default:e(()=>[i("1、文件目录相关操作及磁盘空间查看")]),_:1})]),l("li",null,[s(a,{to:"#_2、磁盘空间查看相关命令"},{default:e(()=>[i("2、磁盘空间查看相关命令")]),_:1})]),l("li",null,[s(a,{to:"#_3、磁盘相关命令及设备信息"},{default:e(()=>[i("3、磁盘相关命令及设备信息")]),_:1})]),l("li",null,[s(a,{to:"#_4、磁盘挂载与卸载"},{default:e(()=>[i("4、磁盘挂载与卸载")]),_:1})]),l("li",null,[s(a,{to:"#_5、硬盘分区、挂载与卸载"},{default:e(()=>[i("5、硬盘分区、挂载与卸载")]),_:1})])])]),l("li",null,[s(a,{to:"#八、进程管理类"},{default:e(()=>[i("八、进程管理类：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、linux-进程管理命令"},{default:e(()=>[i("1、Linux 进程管理命令")]),_:1})]),l("li",null,[s(a,{to:"#_2、ps-aux-和-ps-ef-的区别"},{default:e(()=>[i("2、PS AUX 和 PS -EF 的区别")]),_:1})]),l("li",null,[s(a,{to:"#_3、sshd-进程的查看与分析"},{default:e(()=>[i("3、SSHD 进程的查看与分析")]),_:1})]),l("li",null,[s(a,{to:"#_4、kill-命令的使用"},{default:e(()=>[i("4、kill 命令的使用")]),_:1})]),l("li",null,[s(a,{to:"#_5、pstree-命令的使用"},{default:e(()=>[i("5、pstree 命令的使用")]),_:1})]),l("li",null,[s(a,{to:"#_6、top-命令"},{default:e(()=>[i("6、top 命令")]),_:1})]),l("li",null,[s(a,{to:"#_7、网络状态查看命令-netstat"},{default:e(()=>[i("7、网络状态查看命令：netstat")]),_:1})])])]),l("li",null,[s(a,{to:"#九、系统定时任务"},{default:e(()=>[i("九、系统定时任务：")]),_:1}),l("ul",null,[l("li",null,[s(a,{to:"#_1、定时任务命令-crontab"},{default:e(()=>[i("1、定时任务命令：Crontab")]),_:1})])])])])]),b,v,x])}const S=p(u,[["render",f],["__file","G-第7章常用基本命令.html.vue"]]);export{S as default};
